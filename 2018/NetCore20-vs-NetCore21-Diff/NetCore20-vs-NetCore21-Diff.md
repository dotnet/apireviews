```diff
 namespace System {
+    public static class AdminHelpers {
+        public static bool IsProcessElevated();
+        public static int RunAsSudo(string commandLine);
+    }
+    public sealed class ApplicationIdentity : ISerializable {
+        public ApplicationIdentity(string applicationIdentityFullName);
+        public string CodeBase { get; }
+        public string FullName { get; }
+        void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
+        public override string ToString();
+    }
-    public class ArgumentException : SystemException, ISerializable {
+    public class ArgumentException : SystemException {
     }
-    public class ArgumentOutOfRangeException : ArgumentException, ISerializable {
+    public class ArgumentOutOfRangeException : ArgumentException {
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct ArraySegment<T> : ICollection<T>, IEnumerable, IEnumerable<T>, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T> {
-        void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
     }
+    public static class AssertExtensions {
+        public static void Contains(string value, string substring);
+        public static void Equal(byte[] expected, byte[] actual);
+        public static void GreaterThan<T>(T actual, T greaterThan, string userMessage=null) where T : IComparable;
+        public static void GreaterThanOrEqualTo<T>(T actual, T greaterThanOrEqualTo, string userMessage=null) where T : IComparable;
+        public static void LessThan<T>(T actual, T lessThan, string userMessage=null) where T : IComparable;
+        public static void LessThanOrEqualTo<T>(T actual, T lessThanOrEqualTo, string userMessage=null) where T : IComparable;
+        public static void Throws<T>(Action action, string message) where T : Exception;
+        public static T Throws<T>(string paramName, Action action) where T : ArgumentException;
+        public static T Throws<T>(string paramName, Func<object> testCode) where T : ArgumentException;
+        public static void Throws<T>(string netCoreParamName, string netFxParamName, Action action) where T : ArgumentException;
+        public static Exception Throws<TNetCoreExceptionType, TNetFxExceptionType>(Action action) where TNetCoreExceptionType : Exception where TNetFxExceptionType : Exception;
+        public static void Throws<TNetCoreExceptionType, TNetFxExceptionType>(string paramName, Action action) where TNetCoreExceptionType : ArgumentException where TNetFxExceptionType : ArgumentException;
+        public static void Throws<TNetCoreExceptionType, TNetFxExceptionType>(string netCoreParamName, string netFxParamName, Action action) where TNetCoreExceptionType : ArgumentException where TNetFxExceptionType : ArgumentException;
+        public static void ThrowsAny<TFirstExceptionType, TSecondExceptionType>(Action action) where TFirstExceptionType : Exception where TSecondExceptionType : Exception;
+        public static void ThrowsAny<TFirstExceptionType, TSecondExceptionType, TThirdExceptionType>(Action action) where TFirstExceptionType : Exception where TSecondExceptionType : Exception where TThirdExceptionType : Exception;
+        public static void ThrowsAny(Type firstExceptionType, Type secondExceptionType, Action action);
+        public static Task<T> ThrowsAsync<T>(string paramName, Func<Task> testCode) where T : ArgumentException;
+        public static void ThrowsIf<T>(bool condition, Action action) where T : Exception;
+    }
     public static class BitConverter {
+        public static bool ToBoolean(ReadOnlySpan<byte> value);
+        public static char ToChar(ReadOnlySpan<byte> value);
+        public static double ToDouble(ReadOnlySpan<byte> value);
+        public static short ToInt16(ReadOnlySpan<byte> value);
+        public static int ToInt32(ReadOnlySpan<byte> value);
+        public static long ToInt64(ReadOnlySpan<byte> value);
+        public static float ToSingle(ReadOnlySpan<byte> value);
+        public static ushort ToUInt16(ReadOnlySpan<byte> value);
+        public static uint ToUInt32(ReadOnlySpan<byte> value);
+        public static ulong ToUInt64(ReadOnlySpan<byte> value);
+        public static bool TryWriteBytes(Span<byte> destination, char value);
+        public static bool TryWriteBytes(Span<byte> destination, short value);
+        public static bool TryWriteBytes(Span<byte> destination, int value);
+        public static bool TryWriteBytes(Span<byte> destination, long value);
+        public static bool TryWriteBytes(Span<byte> destination, ushort value);
+        public static bool TryWriteBytes(Span<byte> destination, uint value);
+        public static bool TryWriteBytes(Span<byte> destination, ulong value);
+        public static bool TryWriteBytes(Span<byte> destination, float value);
+        public static bool TryWriteBytes(Span<byte> destination, double value);
+        public static bool TryWriteBytes(Span<byte> destination, bool value);
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct Boolean : IComparable, IComparable<bool>, IConvertible, IEquatable<bool> {
+        public static Boolean Parse(ReadOnlySpan<char> value);
+        public Boolean TryFormat(Span<char> destination, out int charsWritten);
+        public static Boolean TryParse(ReadOnlySpan<char> value, out Boolean result);
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct Byte : IComparable, IComparable<byte>, IConvertible, IEquatable<byte>, IFormattable {
+        public static Byte Parse(ReadOnlySpan<char> s, NumberStyles style=(NumberStyles)(7), IFormatProvider provider=null);
+        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format=default(ReadOnlySpan<char>), IFormatProvider provider=null);
+        public static bool TryParse(ReadOnlySpan<char> s, out Byte result);
+        public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider, out Byte result);
     }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
-    public struct ConsoleKeyInfo {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ConsoleKeyInfo {
     }
     public static class Convert {
+        public static string ToBase64String(ReadOnlySpan<byte> bytes, Base64FormattingOptions options=(Base64FormattingOptions)(0));
+        public static bool TryFromBase64Chars(ReadOnlySpan<char> chars, Span<byte> bytes, out int bytesWritten);
+        public static bool TryFromBase64String(string s, Span<byte> bytes, out int bytesWritten);
+        public static bool TryToBase64Chars(ReadOnlySpan<byte> bytes, Span<char> chars, out int charsWritten, Base64FormattingOptions options=(Base64FormattingOptions)(0));
     }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
-    public struct DateTime : IComparable, IComparable<DateTime>, IConvertible, IEquatable<DateTime>, IFormattable, ISerializable {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct DateTime : IComparable, IComparable<DateTime>, IConvertible, IEquatable<DateTime>, IFormattable, ISerializable {
+        public static readonly DateTime UnixEpoch;
+        public static DateTime Parse(ReadOnlySpan<char> s, IFormatProvider provider=null, DateTimeStyles styles=(DateTimeStyles)(0));
+        public static DateTime ParseExact(ReadOnlySpan<char> s, string[] formats, IFormatProvider provider, DateTimeStyles style=(DateTimeStyles)(0));
+        public static DateTime ParseExact(ReadOnlySpan<char> s, ReadOnlySpan<char> format, IFormatProvider provider, DateTimeStyles style=(DateTimeStyles)(0));
-        int System.IComparable.CompareTo(object value);
-        TypeCode System.IConvertible.GetTypeCode();
+        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format=default(ReadOnlySpan<char>), IFormatProvider provider=null);
+        public static bool TryParse(ReadOnlySpan<char> s, out DateTime result);
+        public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider provider, DateTimeStyles styles, out DateTime result);
+        public static bool TryParseExact(ReadOnlySpan<char> s, string[] formats, IFormatProvider provider, DateTimeStyles style, out DateTime result);
+        public static bool TryParseExact(ReadOnlySpan<char> s, ReadOnlySpan<char> format, IFormatProvider provider, DateTimeStyles style, out DateTime result);
     }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
-    public struct DateTimeOffset : IComparable, IComparable<DateTimeOffset>, IDeserializationCallback, IEquatable<DateTimeOffset>, IFormattable, ISerializable {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct DateTimeOffset : IComparable, IComparable<DateTimeOffset>, IDeserializationCallback, IEquatable<DateTimeOffset>, IFormattable, ISerializable {
+        public static readonly DateTimeOffset UnixEpoch;
+        public static DateTimeOffset Parse(ReadOnlySpan<char> input, IFormatProvider formatProvider=null, DateTimeStyles styles=(DateTimeStyles)(0));
+        public static DateTimeOffset ParseExact(ReadOnlySpan<char> input, string[] formats, IFormatProvider formatProvider, DateTimeStyles styles=(DateTimeStyles)(0));
+        public static DateTimeOffset ParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format, IFormatProvider formatProvider, DateTimeStyles styles=(DateTimeStyles)(0));
+        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format=default(ReadOnlySpan<char>), IFormatProvider formatProvider=null);
+        public static bool TryParse(ReadOnlySpan<char> input, out DateTimeOffset result);
+        public static bool TryParse(ReadOnlySpan<char> input, IFormatProvider formatProvider, DateTimeStyles styles, out DateTimeOffset result);
+        public static bool TryParseExact(ReadOnlySpan<char> input, string[] formats, IFormatProvider formatProvider, DateTimeStyles styles, out DateTimeOffset result);
+        public static bool TryParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format, IFormatProvider formatProvider, DateTimeStyles styles, out DateTimeOffset result);
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct Decimal : IComparable, IComparable<decimal>, IConvertible, IDeserializationCallback, IEquatable<decimal>, IFormattable {
+        public static Decimal Parse(ReadOnlySpan<char> s, NumberStyles style=(NumberStyles)(7), IFormatProvider provider=null);
+        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format=default(ReadOnlySpan<char>), IFormatProvider provider=null);
+        public static bool TryParse(ReadOnlySpan<char> s, out Decimal result);
+        public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider, out Decimal result);
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct Double : IComparable, IComparable<double>, IConvertible, IEquatable<double>, IFormattable {
+        public static bool IsFinite(Double d);
+        public static bool IsNegative(Double d);
+        public static bool IsNormal(Double d);
+        public static bool IsSubnormal(Double d);
+        public static Double Parse(ReadOnlySpan<char> s, NumberStyles style=(NumberStyles)(7), IFormatProvider provider=null);
+        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format=default(ReadOnlySpan<char>), IFormatProvider provider=null);
+        public static bool TryParse(ReadOnlySpan<char> s, out Double result);
+        public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider, out Double result);
     }
-    public class DuplicateWaitObjectException : ArgumentException, ISerializable {
+    public class DuplicateWaitObjectException : ArgumentException {
     }
     public abstract class Enum : ValueType, IComparable, IConvertible, IFormattable {
-        TypeCode System.IConvertible.GetTypeCode();
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct Guid : IComparable, IComparable<Guid>, IEquatable<Guid>, IFormattable {
+        public Guid(ReadOnlySpan<byte> b);
+        public static Guid Parse(ReadOnlySpan<char> input);
+        public static Guid ParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format);
+        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format=default(ReadOnlySpan<char>));
+        public static bool TryParse(ReadOnlySpan<char> input, out Guid result);
+        public static bool TryParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format, out Guid result);
+        public bool TryWriteBytes(Span<byte> destination);
     }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct HashCode {
+        public void Add<T>(T value);
+        public void Add<T>(T value, IEqualityComparer<T> comparer);
+        public static int Combine<T1>(T1 value1);
+        public static int Combine<T1, T2>(T1 value1, T2 value2);
+        public static int Combine<T1, T2, T3>(T1 value1, T2 value2, T3 value3);
+        public static int Combine<T1, T2, T3, T4>(T1 value1, T2 value2, T3 value3, T4 value4);
+        public static int Combine<T1, T2, T3, T4, T5>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
+        public static int Combine<T1, T2, T3, T4, T5, T6>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
+        public static int Combine<T1, T2, T3, T4, T5, T6, T7>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);
+        public static int Combine<T1, T2, T3, T4, T5, T6, T7, T8>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public int ToHashCode();
+    }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct Int16 : IComparable, IComparable<short>, IConvertible, IEquatable<short>, IFormattable {
+        public static Int16 Parse(ReadOnlySpan<char> s, NumberStyles style=(NumberStyles)(7), IFormatProvider provider=null);
+        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format=default(ReadOnlySpan<char>), IFormatProvider provider=null);
+        public static bool TryParse(ReadOnlySpan<char> s, out Int16 result);
+        public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider, out Int16 result);
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct Int32 : IComparable, IComparable<int>, IConvertible, IEquatable<int>, IFormattable {
+        public static Int32 Parse(ReadOnlySpan<char> s, NumberStyles style=(NumberStyles)(7), IFormatProvider provider=null);
+        public bool TryFormat(Span<char> destination, out Int32 charsWritten, ReadOnlySpan<char> format=default(ReadOnlySpan<char>), IFormatProvider provider=null);
+        public static bool TryParse(ReadOnlySpan<char> s, out Int32 result);
+        public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider, out Int32 result);
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct Int64 : IComparable, IComparable<long>, IConvertible, IEquatable<long>, IFormattable {
+        public static Int64 Parse(ReadOnlySpan<char> s, NumberStyles style=(NumberStyles)(7), IFormatProvider provider=null);
+        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format=default(ReadOnlySpan<char>), IFormatProvider provider=null);
+        public static bool TryParse(ReadOnlySpan<char> s, out Int64 result);
+        public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider, out Int64 result);
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct IntPtr : IEquatable<IntPtr>, ISerializable {
-        bool System.IEquatable<System.IntPtr>.Equals(IntPtr other);
+        bool System.IEquatable<System.IntPtr>.Equals(IntPtr value);
     }
     public static class Math {
+        public static double Acosh(double d);
+        public static double Asinh(double d);
+        public static double Atanh(double d);
+        public static double Cbrt(double d);
     }
     public static class MathF {
+        public static float Acosh(float x);
+        public static float Asinh(float x);
+        public static float Atanh(float x);
+        public static float Cbrt(float x);
     }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Memory<T> {
+        public Memory(T[] array);
+        public Memory(T[] array, int start, int length);
+        public static Memory<T> Empty { get; }
+        public bool IsEmpty { get; }
+        public int Length { get; }
+        public Span<T> Span { get; }
+        public void CopyTo(Memory<T> destination);
+        public bool Equals(Memory<T> other);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static implicit operator Memory<T> (ArraySegment<T> arraySegment);
+        public static implicit operator ReadOnlyMemory<T> (Memory<T> memory);
+        public static implicit operator Memory<T> (T[] array);
+        public MemoryHandle Retain(bool pin=false);
+        public Memory<T> Slice(int start);
+        public Memory<T> Slice(int start, int length);
+        public T[] ToArray();
+        public bool TryCopyTo(Memory<T> destination);
+    }
+    public static class MemoryExtensions {
+        public static Span<byte> AsBytes<T>(this Span<T> source) where T : struct;
+        public static ReadOnlySpan<byte> AsBytes<T>(this ReadOnlySpan<T> source) where T : struct;
+        public static Memory<T> AsMemory<T>(this T[] array);
+        public static Memory<T> AsMemory<T>(this T[] array, int start);
+        public static Memory<T> AsMemory<T>(this ArraySegment<T> segment);
+        public static Memory<T> AsMemory<T>(this T[] array, int start, int length);
+        public static Memory<T> AsMemory<T>(this ArraySegment<T> segment, int start);
+        public static Memory<T> AsMemory<T>(this ArraySegment<T> segment, int start, int length);
+        public static ReadOnlyMemory<char> AsMemory(this string text);
+        public static ReadOnlyMemory<char> AsMemory(this string text, int start);
+        public static ReadOnlyMemory<char> AsMemory(this string text, int start, int length);
+        public static ReadOnlyMemory<T> AsReadOnlyMemory<T>(this Memory<T> memory);
+        public static ReadOnlySpan<T> AsReadOnlySpan<T>(this T[] array);
+        public static ReadOnlySpan<T> AsReadOnlySpan<T>(this Span<T> span);
+        public static ReadOnlySpan<T> AsReadOnlySpan<T>(this ArraySegment<T> arraySegment);
+        public static Span<T> AsSpan<T>(this T[] array);
+        public static Span<T> AsSpan<T>(this T[] array, int start);
+        public static Span<T> AsSpan<T>(this ArraySegment<T> segment);
+        public static Span<T> AsSpan<T>(this T[] array, int start, int length);
+        public static Span<T> AsSpan<T>(this ArraySegment<T> segment, int start);
+        public static Span<T> AsSpan<T>(this ArraySegment<T> segment, int start, int length);
+        public static ReadOnlySpan<char> AsSpan(this string text);
+        public static ReadOnlySpan<char> AsSpan(this string text, int start);
+        public static ReadOnlySpan<char> AsSpan(this string text, int start, int length);
+        public static int BinarySearch<T>(this Span<T> span, IComparable<T> comparable);
+        public static int BinarySearch<T>(this ReadOnlySpan<T> span, IComparable<T> comparable);
+        public static int BinarySearch<T, TComparer>(this Span<T> span, T value, TComparer comparer) where TComparer : IComparer<T>;
+        public static int BinarySearch<T, TComparable>(this Span<T> span, TComparable comparable) where TComparable : IComparable<T>;
+        public static int BinarySearch<T, TComparer>(this ReadOnlySpan<T> span, T value, TComparer comparer) where TComparer : IComparer<T>;
+        public static int BinarySearch<T, TComparable>(this ReadOnlySpan<T> span, TComparable comparable) where TComparable : IComparable<T>;
+        public static int CompareTo(this ReadOnlySpan<char> span, ReadOnlySpan<char> value, StringComparison comparisonType);
+        public static bool Contains(this ReadOnlySpan<char> span, ReadOnlySpan<char> value, StringComparison comparisonType);
+        public static void CopyTo<T>(this T[] array, Span<T> destination);
+        public static void CopyTo<T>(this T[] array, Memory<T> destination);
+        public static bool EndsWith<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>;
+        public static bool EndsWith<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>;
+        public static bool EndsWith(this ReadOnlySpan<char> span, ReadOnlySpan<char> value, StringComparison comparisonType);
+        public static bool Equals(this ReadOnlySpan<char> span, ReadOnlySpan<char> value, StringComparison comparisonType);
+        public static int IndexOf<T>(this Span<T> span, T value) where T : IEquatable<T>;
+        public static int IndexOf<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>;
+        public static int IndexOf<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>;
+        public static int IndexOf<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>;
+        public static int IndexOf(this ReadOnlySpan<char> span, ReadOnlySpan<char> value, StringComparison comparisonType);
+        public static int IndexOfAny<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>;
+        public static int IndexOfAny<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>;
+        public static int IndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>;
+        public static int IndexOfAny<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>;
+        public static int IndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>;
+        public static int IndexOfAny<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>;
+        public static bool IsWhiteSpace(this ReadOnlySpan<char> span);
+        public static int LastIndexOf<T>(this Span<T> span, T value) where T : IEquatable<T>;
+        public static int LastIndexOf<T>(this ReadOnlySpan<T> span, T value) where T : IEquatable<T>;
+        public static int LastIndexOf<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>;
+        public static int LastIndexOf<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>;
+        public static int LastIndexOfAny<T>(this Span<T> span, T value0, T value1) where T : IEquatable<T>;
+        public static int LastIndexOfAny<T>(this Span<T> span, T value0, T value1, T value2) where T : IEquatable<T>;
+        public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1) where T : IEquatable<T>;
+        public static int LastIndexOfAny<T>(this Span<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>;
+        public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, T value0, T value1, T value2) where T : IEquatable<T>;
+        public static int LastIndexOfAny<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> values) where T : IEquatable<T>;
+        public static bool Overlaps<T>(this Span<T> first, ReadOnlySpan<T> second);
+        public static bool Overlaps<T>(this Span<T> first, ReadOnlySpan<T> second, out int elementOffset);
+        public static bool Overlaps<T>(this ReadOnlySpan<T> first, ReadOnlySpan<T> second);
+        public static bool Overlaps<T>(this ReadOnlySpan<T> first, ReadOnlySpan<T> second, out int elementOffset);
+        public static void Reverse<T>(this Span<T> span);
+        public static int SequenceCompareTo<T>(this Span<T> first, ReadOnlySpan<T> second) where T : IComparable<T>;
+        public static int SequenceCompareTo<T>(this ReadOnlySpan<T> first, ReadOnlySpan<T> second) where T : IComparable<T>;
+        public static bool SequenceEqual<T>(this Span<T> first, ReadOnlySpan<T> second) where T : IEquatable<T>;
+        public static bool SequenceEqual<T>(this ReadOnlySpan<T> first, ReadOnlySpan<T> second) where T : IEquatable<T>;
+        public static bool StartsWith<T>(this Span<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>;
+        public static bool StartsWith<T>(this ReadOnlySpan<T> span, ReadOnlySpan<T> value) where T : IEquatable<T>;
+        public static bool StartsWith(this ReadOnlySpan<char> span, ReadOnlySpan<char> value, StringComparison comparisonType);
+        public static int ToLower(this ReadOnlySpan<char> source, Span<char> destination, CultureInfo culture);
+        public static int ToLowerInvariant(this ReadOnlySpan<char> source, Span<char> destination);
+        public static int ToUpper(this ReadOnlySpan<char> source, Span<char> destination, CultureInfo culture);
+        public static int ToUpperInvariant(this ReadOnlySpan<char> source, Span<char> destination);
+        public static ReadOnlySpan<char> Trim(this ReadOnlySpan<char> span);
+        public static ReadOnlySpan<char> Trim(this ReadOnlySpan<char> span, char trimChar);
+        public static ReadOnlySpan<char> Trim(this ReadOnlySpan<char> span, ReadOnlySpan<char> trimChars);
+        public static ReadOnlySpan<char> TrimEnd(this ReadOnlySpan<char> span);
+        public static ReadOnlySpan<char> TrimEnd(this ReadOnlySpan<char> span, char trimChar);
+        public static ReadOnlySpan<char> TrimEnd(this ReadOnlySpan<char> span, ReadOnlySpan<char> trimChars);
+        public static ReadOnlySpan<char> TrimStart(this ReadOnlySpan<char> span);
+        public static ReadOnlySpan<char> TrimStart(this ReadOnlySpan<char> span, char trimChar);
+        public static ReadOnlySpan<char> TrimStart(this ReadOnlySpan<char> span, ReadOnlySpan<char> trimChars);
+    }
-    public class MissingMethodException : MissingMemberException, ISerializable {
+    public class MissingMethodException : MissingMemberException {
     }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
-    public struct ModuleHandle {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ModuleHandle {
     }
+    public static class PlatformDetection {
+        public static bool IsReflectionEmitSupported;
+        public static bool ClientWebSocketPartialMessagesSupported { get; }
+        public static bool HasWindowsShell { get; }
+        public static Version ICUVersion { get; }
+        public static bool IsArmProcess { get; }
+        public static bool IsCentos6 { get; }
+        public static bool IsDebian { get; }
+        public static bool IsDebian8 { get; }
+        public static bool IsDomainJoinedMachine { get; }
+        public static bool IsDrawingSupported { get; }
+        public static bool IsFedora { get; }
+        public static bool IsFreeBSD { get; }
+        public static bool IsFullFramework { get; }
+        public static bool IsInAppContainer { get; }
+        public static bool IsInvokingStaticConstructorsSupported { get; }
+        public static bool IsMacOsHighSierraOrHigher { get; }
+        public static bool IsNetBSD { get; }
+        public static bool IsNetCore { get; }
+        public static bool IsNetfx462OrNewer { get; }
+        public static bool IsNetfx470OrNewer { get; }
+        public static bool IsNetfx471OrNewer { get; }
+        public static bool IsNetNative { get; }
+        public static bool IsNonZeroLowerBoundArraySupported { get; }
+        public static bool IsNotArmProcess { get; }
+        public static bool IsNotFedoraOrRedHatFamily { get; }
+        public static bool IsNotInAppContainer { get; }
+        public static bool IsNotMacOsHighSierraOrHigher { get; }
+        public static bool IsNotNetNativeRunningAsConsoleApp { get; }
+        public static bool IsNotOneCoreUAP { get; }
+        public static bool IsNotRedHatFamily { get; }
+        public static bool IsNotRedHatFamily6 { get; }
+        public static bool IsNotWindows8x { get; }
+        public static bool IsNotWindowsIoTCore { get; }
+        public static bool IsNotWindowsNanoServer { get; }
+        public static bool IsNotWindowsServerCore { get; }
+        public static bool IsNotWindowsSubsystemForLinux { get; }
+        public static bool IsNotWinRTSupported { get; }
+        public static bool IsOpenSUSE { get; }
+        public static bool IsOSX { get; }
+        public static bool IsRedHatFamily { get; }
+        public static bool IsRedHatFamily6 { get; }
+        public static bool IsRedHatFamily7 { get; }
+        public static bool IsSuperUser { get; }
+        public static bool IsTizen { get; }
+        public static bool IsUap { get; }
+        public static bool IsUbuntu { get; }
+        public static bool IsUbuntu1404 { get; }
+        public static bool IsUbuntu1604 { get; }
+        public static bool IsUbuntu1704 { get; }
+        public static bool IsUbuntu1710 { get; }
+        public static bool IsUbuntu1710OrHigher { get; }
+        public static bool IsUbuntu1804 { get; }
+        public static bool IsWindows { get; }
+        public static bool IsWindows10Version1607OrGreater { get; }
+        public static bool IsWindows10Version1703OrGreater { get; }
+        public static bool IsWindows10Version1709OrGreater { get; }
+        public static bool IsWindows7 { get; }
+        public static bool IsWindows8x { get; }
+        public static bool IsWindowsAndElevated { get; }
+        public static bool IsWindowsIoTCore { get; }
+        public static bool IsWindowsNanoServer { get; }
+        public static bool IsWindowsServerCore { get; }
+        public static bool IsWindowsSubsystemForLinux { get; }
+        public static bool IsWinRTSupported { get; }
+        public static bool IsXmlDsigXsltTransformSupported { get; }
+        public static string LibcRelease { get; }
+        public static string LibcVersion { get; }
+        public static Version OpenSslVersion { get; }
+        public static Version OSXVersion { get; }
+        public static bool TargetsNetFx452OrLower { get; }
+        public static int WindowsVersion { get; }
+        public static string GetDistroVersionString();
+    }
     public class Random {
+        public virtual void NextBytes(Span<byte> buffer);
     }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ReadOnlyMemory<T> {
+        public ReadOnlyMemory(T[] array);
+        public ReadOnlyMemory(T[] array, int start, int length);
+        public static ReadOnlyMemory<T> Empty { get; }
+        public bool IsEmpty { get; }
+        public int Length { get; }
+        public ReadOnlySpan<T> Span { get; }
+        public void CopyTo(Memory<T> destination);
+        public override bool Equals(object obj);
+        public bool Equals(ReadOnlyMemory<T> other);
+        public override int GetHashCode();
+        public static implicit operator ReadOnlyMemory<T> (ArraySegment<T> arraySegment);
+        public static implicit operator ReadOnlyMemory<T> (T[] array);
+        public MemoryHandle Retain(bool pin=false);
+        public ReadOnlyMemory<T> Slice(int start);
+        public ReadOnlyMemory<T> Slice(int start, int length);
+        public T[] ToArray();
+        public override string ToString();
+        public bool TryCopyTo(Memory<T> destination);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ReadOnlySpan<T> {
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator {
+            public ref T Current { get; }
+            public bool MoveNext();
+        }
+        public ReadOnlySpan(T[] array);
+        public ReadOnlySpan(T[] array, int start, int length);
+        public unsafe ReadOnlySpan(void* pointer, int length);
+        public static ReadOnlySpan<T> Empty { get; }
+        public bool IsEmpty { get; }
+        public ref T this[int index] { get; }
+        public int Length { get; }
+        public void CopyTo(Span<T> destination);
+        public override bool Equals(object obj);
+        public ReadOnlySpan<T>.Enumerator GetEnumerator();
+        public override int GetHashCode();
+        public static bool operator ==(ReadOnlySpan<T> left, ReadOnlySpan<T> right);
+        public static implicit operator ReadOnlySpan<T> (ArraySegment<T> arraySegment);
+        public static implicit operator ReadOnlySpan<T> (T[] array);
+        public static bool operator !=(ReadOnlySpan<T> left, ReadOnlySpan<T> right);
+        public ReadOnlySpan<T> Slice(int start);
+        public ReadOnlySpan<T> Slice(int start, int length);
+        public T[] ToArray();
+        public override string ToString();
+        public bool TryCopyTo(Span<T> destination);
+    }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct SByte : IComparable, IComparable<sbyte>, IConvertible, IEquatable<sbyte>, IFormattable {
+        public static SByte Parse(ReadOnlySpan<char> s, NumberStyles style=(NumberStyles)(7), IFormatProvider provider=null);
+        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format=default(ReadOnlySpan<char>), IFormatProvider provider=null);
+        public static bool TryParse(ReadOnlySpan<char> s, out SByte result);
+        public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider, out SByte result);
     }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SequencePosition : IEquatable<SequencePosition> {
+        public SequencePosition(object segment, int index);
+        public override bool Equals(object obj);
+        public bool Equals(SequencePosition position);
+        public override int GetHashCode();
+        public int GetInteger();
+        public object GetObject();
+        public static bool operator ==(SequencePosition left, SequencePosition right);
+        public static bool operator !=(SequencePosition left, SequencePosition right);
+        public override string ToString();
+    }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct Single : IComparable, IComparable<float>, IConvertible, IEquatable<float>, IFormattable {
+        public static bool IsFinite(Single f);
+        public static bool IsNegative(Single f);
+        public static bool IsNormal(Single f);
+        public static bool IsSubnormal(Single f);
+        public static Single Parse(ReadOnlySpan<char> s, NumberStyles style=(NumberStyles)(7), IFormatProvider provider=null);
+        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format=default(ReadOnlySpan<char>), IFormatProvider provider=null);
+        public static bool TryParse(ReadOnlySpan<char> s, out Single result);
+        public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider, out Single result);
     }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Span<T> {
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator {
+            public ref T Current { get; }
+            public bool MoveNext();
+        }
+        public Span(T[] array);
+        public Span(T[] array, int start, int length);
+        public unsafe Span(void* pointer, int length);
+        public static Span<T> Empty { get; }
+        public bool IsEmpty { get; }
+        public ref T this[int index] { get; }
+        public int Length { get; }
+        public void Clear();
+        public void CopyTo(Span<T> destination);
+        public override bool Equals(object obj);
+        public void Fill(T value);
+        public Span<T>.Enumerator GetEnumerator();
+        public override int GetHashCode();
+        public static bool operator ==(Span<T> left, Span<T> right);
+        public static implicit operator Span<T> (ArraySegment<T> arraySegment);
+        public static implicit operator ReadOnlySpan<T> (Span<T> span);
+        public static implicit operator Span<T> (T[] array);
+        public static bool operator !=(Span<T> left, Span<T> right);
+        public Span<T> Slice(int start);
+        public Span<T> Slice(int start, int length);
+        public T[] ToArray();
+        public override string ToString();
+        public bool TryCopyTo(Span<T> destination);
+    }
     public sealed class String : ICloneable, IComparable, IComparable<string>, IConvertible, IEnumerable, IEnumerable<char>, IEquatable<string> {
+        public String(ReadOnlySpan<char> value);
+        public bool Contains(char value);
+        public bool Contains(char value, StringComparison comparisonType);
+        public bool Contains(String value, StringComparison comparisonType);
+        public static String Create<TState>(int length, TState state, SpanAction<char, TState> action);
+        public int IndexOf(char value, StringComparison comparisonType);
+        public static implicit operator ReadOnlySpan<char> (String value);
     }
     public abstract class StringComparer : IComparer, IComparer<string>, IEqualityComparer, IEqualityComparer<string> {
+        public static StringComparer Create(CultureInfo culture, CompareOptions options);
     }
+    public static class TestEnvironment {
+        public static bool IsStressModeEnabled { get; }
+    }
+    public static class TheoryExtensions {
+        public static TheoryData ToTheoryData<T>(this IEnumerable<T> data);
+    }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct TimeSpan : IComparable, IComparable<TimeSpan>, IEquatable<TimeSpan>, IFormattable {
+        public static TimeSpan Parse(ReadOnlySpan<char> input, IFormatProvider formatProvider=null);
+        public static TimeSpan ParseExact(ReadOnlySpan<char> input, string[] formats, IFormatProvider formatProvider, TimeSpanStyles styles=(TimeSpanStyles)(0));
+        public static TimeSpan ParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format, IFormatProvider formatProvider, TimeSpanStyles styles=(TimeSpanStyles)(0));
+        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format=default(ReadOnlySpan<char>), IFormatProvider formatProvider=null);
+        public static bool TryParse(ReadOnlySpan<char> s, out TimeSpan result);
+        public static bool TryParse(ReadOnlySpan<char> input, IFormatProvider formatProvider, out TimeSpan result);
+        public static bool TryParseExact(ReadOnlySpan<char> input, string[] formats, IFormatProvider formatProvider, out TimeSpan result);
+        public static bool TryParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format, IFormatProvider formatProvider, out TimeSpan result);
+        public static bool TryParseExact(ReadOnlySpan<char> input, string[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, out TimeSpan result);
+        public static bool TryParseExact(ReadOnlySpan<char> input, ReadOnlySpan<char> format, IFormatProvider formatProvider, TimeSpanStyles styles, out TimeSpan result);
     }
     public abstract class Type : MemberInfo, IReflect {
+        public virtual bool IsByRefLike { get; }
+        public virtual bool IsGenericMethodParameter { get; }
+        public virtual bool IsGenericTypeParameter { get; }
+        public virtual bool IsSignatureType { get; }
+        public MethodInfo GetMethod(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
+        public MethodInfo GetMethod(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
+        public MethodInfo GetMethod(string name, int genericParameterCount, Type[] types);
+        public MethodInfo GetMethod(string name, int genericParameterCount, Type[] types, ParameterModifier[] modifiers);
+        protected virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
+        public static Type MakeGenericMethodParameter(int position);
     }
-    public class TypeUnloadedException : SystemException, ISerializable {
+    public class TypeUnloadedException : SystemException {
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct UInt16 : IComparable, IComparable<ushort>, IConvertible, IEquatable<ushort>, IFormattable {
+        public static UInt16 Parse(ReadOnlySpan<char> s, NumberStyles style=(NumberStyles)(7), IFormatProvider provider=null);
+        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format=default(ReadOnlySpan<char>), IFormatProvider provider=null);
+        public static bool TryParse(ReadOnlySpan<char> s, out UInt16 result);
+        public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider, out UInt16 result);
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct UInt32 : IComparable, IComparable<uint>, IConvertible, IEquatable<uint>, IFormattable {
+        public static UInt32 Parse(ReadOnlySpan<char> s, NumberStyles style=(NumberStyles)(7), IFormatProvider provider=null);
+        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format=default(ReadOnlySpan<char>), IFormatProvider provider=null);
+        public static bool TryParse(ReadOnlySpan<char> s, out UInt32 result);
+        public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider, out UInt32 result);
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct UInt64 : IComparable, IComparable<ulong>, IConvertible, IEquatable<ulong>, IFormattable {
+        public static UInt64 Parse(ReadOnlySpan<char> s, NumberStyles style=(NumberStyles)(7), IFormatProvider provider=null);
+        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format=default(ReadOnlySpan<char>), IFormatProvider provider=null);
+        public static bool TryParse(ReadOnlySpan<char> s, out UInt64 result);
+        public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider, out UInt64 result);
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct UIntPtr : IEquatable<UIntPtr>, ISerializable {
-        bool System.IEquatable<System.UIntPtr>.Equals(UIntPtr other);
+        bool System.IEquatable<System.UIntPtr>.Equals(UIntPtr value);
     }
+    public enum UriIdnScope {
+        All = 2,
+        AllExceptIntranet = 1,
+        None = 0,
+    }
-    public struct ValueTuple<T1, T2> : IComparable, IComparable<ValueTuple<T1, T2>>, IEquatable<ValueTuple<T1, T2>>, IStructuralComparable, IStructuralEquatable, ITuple {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ValueTuple<T1, T2> : IComparable, IComparable<ValueTuple<T1, T2>>, IEquatable<ValueTuple<T1, T2>>, IStructuralComparable, IStructuralEquatable, ITuple {
     }
-    public struct ValueTuple<T1, T2, T3> : IComparable, IComparable<ValueTuple<T1, T2, T3>>, IEquatable<ValueTuple<T1, T2, T3>>, IStructuralComparable, IStructuralEquatable, ITuple {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ValueTuple<T1, T2, T3> : IComparable, IComparable<ValueTuple<T1, T2, T3>>, IEquatable<ValueTuple<T1, T2, T3>>, IStructuralComparable, IStructuralEquatable, ITuple {
     }
-    public struct ValueTuple<T1, T2, T3, T4> : IComparable, IComparable<ValueTuple<T1, T2, T3, T4>>, IEquatable<ValueTuple<T1, T2, T3, T4>>, IStructuralComparable, IStructuralEquatable, ITuple {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ValueTuple<T1, T2, T3, T4> : IComparable, IComparable<ValueTuple<T1, T2, T3, T4>>, IEquatable<ValueTuple<T1, T2, T3, T4>>, IStructuralComparable, IStructuralEquatable, ITuple {
     }
-    public struct ValueTuple<T1, T2, T3, T4, T5> : IComparable, IComparable<ValueTuple<T1, T2, T3, T4, T5>>, IEquatable<ValueTuple<T1, T2, T3, T4, T5>>, IStructuralComparable, IStructuralEquatable, ITuple {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ValueTuple<T1, T2, T3, T4, T5> : IComparable, IComparable<ValueTuple<T1, T2, T3, T4, T5>>, IEquatable<ValueTuple<T1, T2, T3, T4, T5>>, IStructuralComparable, IStructuralEquatable, ITuple {
     }
-    public struct ValueTuple<T1, T2, T3, T4, T5, T6> : IComparable, IComparable<ValueTuple<T1, T2, T3, T4, T5, T6>>, IEquatable<ValueTuple<T1, T2, T3, T4, T5, T6>>, IStructuralComparable, IStructuralEquatable, ITuple {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ValueTuple<T1, T2, T3, T4, T5, T6> : IComparable, IComparable<ValueTuple<T1, T2, T3, T4, T5, T6>>, IEquatable<ValueTuple<T1, T2, T3, T4, T5, T6>>, IStructuralComparable, IStructuralEquatable, ITuple {
     }
-    public struct ValueTuple<T1, T2, T3, T4, T5, T6, T7> : IComparable, IComparable<ValueTuple<T1, T2, T3, T4, T5, T6, T7>>, IEquatable<ValueTuple<T1, T2, T3, T4, T5, T6, T7>>, IStructuralComparable, IStructuralEquatable, ITuple {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ValueTuple<T1, T2, T3, T4, T5, T6, T7> : IComparable, IComparable<ValueTuple<T1, T2, T3, T4, T5, T6, T7>>, IEquatable<ValueTuple<T1, T2, T3, T4, T5, T6, T7>>, IStructuralComparable, IStructuralEquatable, ITuple {
     }
-    public struct ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> : IComparable, IComparable<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>>, IEquatable<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>>, IStructuralComparable, IStructuralEquatable, ITuple where TRest : struct {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> : IComparable, IComparable<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>>, IEquatable<ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>>, IStructuralComparable, IStructuralEquatable, ITuple where TRest : struct {
     }
     public sealed class Version : ICloneable, IComparable, IComparable<Version>, IEquatable<Version> {
+        public static Version Parse(ReadOnlySpan<char> input);
+        public bool TryFormat(Span<char> destination, out int charsWritten);
+        public bool TryFormat(Span<char> destination, int fieldCount, out int charsWritten);
+        public static bool TryParse(ReadOnlySpan<char> input, out Version result);
     }
 }
 namespace System.Buffers {
+    public static class BuffersExtensions {
+        public static void CopyTo<T>(this ref ReadOnlySequence<T> sequence, Span<T> destination);
+        public static Nullable<SequencePosition> PositionOf<T>(this ref ReadOnlySequence<T> sequence, T value) where T : IEquatable<T>;
+        public static T[] ToArray<T>(this ref ReadOnlySequence<T> sequence);
+        public static void Write<T>(this IBufferWriter<T> bufferWriter, ReadOnlySpan<T> source);
+    }
+    public interface IBufferWriter<T> {
+        void Advance(int count);
+        Memory<T> GetMemory(int sizeHint=0);
+        Span<T> GetSpan(int sizeHint=0);
+    }
+    public interface IRetainable {
+        bool Release();
+        void Retain();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct MemoryHandle : IDisposable {
+        public unsafe MemoryHandle(IRetainable owner, void* pointer=null, GCHandle handle=default(GCHandle));
+        public bool HasPointer { get; }
+        public unsafe void* Pointer { get; }
+        public void Dispose();
+    }
+    public abstract class MemoryPool<T> : IDisposable {
+        protected MemoryPool();
+        public abstract int MaxBufferSize { get; }
+        public static MemoryPool<T> Shared { get; }
+        public void Dispose();
+        protected abstract void Dispose(bool disposing);
+        public abstract OwnedMemory<T> Rent(int minBufferSize=-1);
+    }
+    public enum OperationStatus {
+        DestinationTooSmall = 1,
+        Done = 0,
+        InvalidData = 3,
+        NeedMoreData = 2,
+    }
+    public abstract class OwnedMemory<T> : IDisposable, IRetainable {
+        protected OwnedMemory();
+        public abstract bool IsDisposed { get; }
+        protected abstract bool IsRetained { get; }
+        public abstract int Length { get; }
+        public Memory<T> Memory { get; }
+        public abstract Span<T> Span { get; }
+        public void Dispose();
+        protected abstract void Dispose(bool disposing);
+        public abstract MemoryHandle Pin(int byteOffset=0);
+        public abstract bool Release();
+        public abstract void Retain();
+        protected internal abstract bool TryGetArray(out ArraySegment<T> arraySegment);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ReadOnlySequence<T> {
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct Enumerator {
+            public Enumerator(ref ReadOnlySequence<T> sequence);
+            public ReadOnlyMemory<T> Current { get; }
+            public bool MoveNext();
+        }
+        public static readonly ReadOnlySequence<T> Empty;
+        public ReadOnlySequence(OwnedMemory<T> memory);
+        public ReadOnlySequence(OwnedMemory<T> memory, int start, int length);
+        public ReadOnlySequence(ReadOnlyMemory<T> memory);
+        public ReadOnlySequence(ReadOnlySequenceSegment<T> startSegment, int startIndex, ReadOnlySequenceSegment<T> endSegment, int endIndex);
+        public ReadOnlySequence(T[] array);
+        public ReadOnlySequence(T[] array, int start, int length);
+        public SequencePosition End { get; }
+        public ReadOnlyMemory<T> First { get; }
+        public bool IsEmpty { get; }
+        public bool IsSingleSegment { get; }
+        public long Length { get; }
+        public SequencePosition Start { get; }
+        public ReadOnlySequence<T>.Enumerator GetEnumerator();
+        public SequencePosition GetPosition(long offset);
+        public SequencePosition GetPosition(long offset, SequencePosition origin);
+        public ReadOnlySequence<T> Slice(int start, int length);
+        public ReadOnlySequence<T> Slice(int start, SequencePosition end);
+        public ReadOnlySequence<T> Slice(long start);
+        public ReadOnlySequence<T> Slice(long start, long length);
+        public ReadOnlySequence<T> Slice(long start, SequencePosition end);
+        public ReadOnlySequence<T> Slice(SequencePosition start);
+        public ReadOnlySequence<T> Slice(SequencePosition start, int length);
+        public ReadOnlySequence<T> Slice(SequencePosition start, long length);
+        public ReadOnlySequence<T> Slice(SequencePosition start, SequencePosition end);
+        public override string ToString();
+        public bool TryGet(ref SequencePosition position, out ReadOnlyMemory<T> data, bool advance=true);
+    }
+    public abstract class ReadOnlySequenceSegment<T> {
+        protected ReadOnlySequenceSegment();
+        public ReadOnlyMemory<T> Memory { get; protected set; }
+        public ReadOnlySequenceSegment<T> Next { get; protected set; }
+        public long RunningIndex { get; protected set; }
+    }
+    public delegate void ReadOnlySpanAction<T, in TArg>(ReadOnlySpan<T> span, TArg arg); {
+        public ReadOnlySpanAction(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(ReadOnlySpan<T> span, TArg arg, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(ReadOnlySpan<T> span, TArg arg);
+    }
+    public delegate void SpanAction<T, in TArg>(Span<T> span, TArg arg); {
+        public SpanAction(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(Span<T> span, TArg arg, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(Span<T> span, TArg arg);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct StandardFormat : IEquatable<StandardFormat> {
+        public const byte MaxPrecision = (byte)99;
+        public const byte NoPrecision = (byte)255;
+        public StandardFormat(char symbol, byte precision=(byte)255);
+        public bool HasPrecision { get; }
+        public bool IsDefault { get; }
+        public byte Precision { get; }
+        public char Symbol { get; }
+        public override bool Equals(object obj);
+        public bool Equals(StandardFormat other);
+        public override int GetHashCode();
+        public static bool operator ==(StandardFormat left, StandardFormat right);
+        public static implicit operator StandardFormat (char symbol);
+        public static bool operator !=(StandardFormat left, StandardFormat right);
+        public static StandardFormat Parse(ReadOnlySpan<char> format);
+        public static StandardFormat Parse(string format);
+        public override string ToString();
+    }
 }
+namespace System.Buffers.Binary {
+    public static class BinaryPrimitives {
+        public static short ReadInt16BigEndian(ReadOnlySpan<byte> buffer);
+        public static short ReadInt16LittleEndian(ReadOnlySpan<byte> buffer);
+        public static int ReadInt32BigEndian(ReadOnlySpan<byte> buffer);
+        public static int ReadInt32LittleEndian(ReadOnlySpan<byte> buffer);
+        public static long ReadInt64BigEndian(ReadOnlySpan<byte> buffer);
+        public static long ReadInt64LittleEndian(ReadOnlySpan<byte> buffer);
+        public static T ReadMachineEndian<T>(ReadOnlySpan<byte> buffer) where T : struct;
+        public static ushort ReadUInt16BigEndian(ReadOnlySpan<byte> buffer);
+        public static ushort ReadUInt16LittleEndian(ReadOnlySpan<byte> buffer);
+        public static uint ReadUInt32BigEndian(ReadOnlySpan<byte> buffer);
+        public static uint ReadUInt32LittleEndian(ReadOnlySpan<byte> buffer);
+        public static ulong ReadUInt64BigEndian(ReadOnlySpan<byte> buffer);
+        public static ulong ReadUInt64LittleEndian(ReadOnlySpan<byte> buffer);
+        public static byte ReverseEndianness(byte value);
+        public static short ReverseEndianness(short value);
+        public static int ReverseEndianness(int value);
+        public static long ReverseEndianness(long value);
+        public static sbyte ReverseEndianness(sbyte value);
+        public static ushort ReverseEndianness(ushort value);
+        public static uint ReverseEndianness(uint value);
+        public static ulong ReverseEndianness(ulong value);
+        public static bool TryReadInt16BigEndian(ReadOnlySpan<byte> buffer, out short value);
+        public static bool TryReadInt16LittleEndian(ReadOnlySpan<byte> buffer, out short value);
+        public static bool TryReadInt32BigEndian(ReadOnlySpan<byte> buffer, out int value);
+        public static bool TryReadInt32LittleEndian(ReadOnlySpan<byte> buffer, out int value);
+        public static bool TryReadInt64BigEndian(ReadOnlySpan<byte> buffer, out long value);
+        public static bool TryReadInt64LittleEndian(ReadOnlySpan<byte> buffer, out long value);
+        public static bool TryReadMachineEndian<T>(ReadOnlySpan<byte> buffer, out T value) where T : struct;
+        public static bool TryReadUInt16BigEndian(ReadOnlySpan<byte> buffer, out ushort value);
+        public static bool TryReadUInt16LittleEndian(ReadOnlySpan<byte> buffer, out ushort value);
+        public static bool TryReadUInt32BigEndian(ReadOnlySpan<byte> buffer, out uint value);
+        public static bool TryReadUInt32LittleEndian(ReadOnlySpan<byte> buffer, out uint value);
+        public static bool TryReadUInt64BigEndian(ReadOnlySpan<byte> buffer, out ulong value);
+        public static bool TryReadUInt64LittleEndian(ReadOnlySpan<byte> buffer, out ulong value);
+        public static bool TryWriteInt16BigEndian(Span<byte> buffer, short value);
+        public static bool TryWriteInt16LittleEndian(Span<byte> buffer, short value);
+        public static bool TryWriteInt32BigEndian(Span<byte> buffer, int value);
+        public static bool TryWriteInt32LittleEndian(Span<byte> buffer, int value);
+        public static bool TryWriteInt64BigEndian(Span<byte> buffer, long value);
+        public static bool TryWriteInt64LittleEndian(Span<byte> buffer, long value);
+        public static bool TryWriteMachineEndian<T>(Span<byte> buffer, ref T value) where T : struct;
+        public static bool TryWriteUInt16BigEndian(Span<byte> buffer, ushort value);
+        public static bool TryWriteUInt16LittleEndian(Span<byte> buffer, ushort value);
+        public static bool TryWriteUInt32BigEndian(Span<byte> buffer, uint value);
+        public static bool TryWriteUInt32LittleEndian(Span<byte> buffer, uint value);
+        public static bool TryWriteUInt64BigEndian(Span<byte> buffer, ulong value);
+        public static bool TryWriteUInt64LittleEndian(Span<byte> buffer, ulong value);
+        public static void WriteInt16BigEndian(Span<byte> buffer, short value);
+        public static void WriteInt16LittleEndian(Span<byte> buffer, short value);
+        public static void WriteInt32BigEndian(Span<byte> buffer, int value);
+        public static void WriteInt32LittleEndian(Span<byte> buffer, int value);
+        public static void WriteInt64BigEndian(Span<byte> buffer, long value);
+        public static void WriteInt64LittleEndian(Span<byte> buffer, long value);
+        public static void WriteMachineEndian<T>(Span<byte> buffer, ref T value) where T : struct;
+        public static void WriteUInt16BigEndian(Span<byte> buffer, ushort value);
+        public static void WriteUInt16LittleEndian(Span<byte> buffer, ushort value);
+        public static void WriteUInt32BigEndian(Span<byte> buffer, uint value);
+        public static void WriteUInt32LittleEndian(Span<byte> buffer, uint value);
+        public static void WriteUInt64BigEndian(Span<byte> buffer, ulong value);
+        public static void WriteUInt64LittleEndian(Span<byte> buffer, ulong value);
+    }
+}
+namespace System.Buffers.Text {
+    public static class Base64 {
+        public static OperationStatus DecodeFromUtf8(ReadOnlySpan<byte> utf8, Span<byte> bytes, out int consumed, out int written, bool isFinalBlock=true);
+        public static OperationStatus DecodeFromUtf8InPlace(Span<byte> buffer, out int written);
+        public static OperationStatus EncodeToUtf8(ReadOnlySpan<byte> bytes, Span<byte> utf8, out int consumed, out int written, bool isFinalBlock=true);
+        public static OperationStatus EncodeToUtf8InPlace(Span<byte> buffer, int dataLength, out int written);
+        public static int GetMaxDecodedFromUtf8Length(int length);
+        public static int GetMaxEncodedToUtf8Length(int length);
+    }
+    public static class Utf8Formatter {
+        public static bool TryFormat(bool value, Span<byte> buffer, out int bytesWritten, StandardFormat format=default(StandardFormat));
+        public static bool TryFormat(byte value, Span<byte> buffer, out int bytesWritten, StandardFormat format=default(StandardFormat));
+        public static bool TryFormat(DateTime value, Span<byte> buffer, out int bytesWritten, StandardFormat format=default(StandardFormat));
+        public static bool TryFormat(DateTimeOffset value, Span<byte> buffer, out int bytesWritten, StandardFormat format=default(StandardFormat));
+        public static bool TryFormat(decimal value, Span<byte> buffer, out int bytesWritten, StandardFormat format=default(StandardFormat));
+        public static bool TryFormat(double value, Span<byte> buffer, out int bytesWritten, StandardFormat format=default(StandardFormat));
+        public static bool TryFormat(Guid value, Span<byte> buffer, out int bytesWritten, StandardFormat format=default(StandardFormat));
+        public static bool TryFormat(short value, Span<byte> buffer, out int bytesWritten, StandardFormat format=default(StandardFormat));
+        public static bool TryFormat(int value, Span<byte> buffer, out int bytesWritten, StandardFormat format=default(StandardFormat));
+        public static bool TryFormat(long value, Span<byte> buffer, out int bytesWritten, StandardFormat format=default(StandardFormat));
+        public static bool TryFormat(sbyte value, Span<byte> buffer, out int bytesWritten, StandardFormat format=default(StandardFormat));
+        public static bool TryFormat(float value, Span<byte> buffer, out int bytesWritten, StandardFormat format=default(StandardFormat));
+        public static bool TryFormat(TimeSpan value, Span<byte> buffer, out int bytesWritten, StandardFormat format=default(StandardFormat));
+        public static bool TryFormat(ushort value, Span<byte> buffer, out int bytesWritten, StandardFormat format=default(StandardFormat));
+        public static bool TryFormat(uint value, Span<byte> buffer, out int bytesWritten, StandardFormat format=default(StandardFormat));
+        public static bool TryFormat(ulong value, Span<byte> buffer, out int bytesWritten, StandardFormat format=default(StandardFormat));
+    }
+    public static class Utf8Parser {
+        public static bool TryParse(ReadOnlySpan<byte> text, out Guid value, out int bytesConsumed, char standardFormat='\0');
+        public static bool TryParse(ReadOnlySpan<byte> text, out byte value, out int bytesConsumed, char standardFormat='\0');
+        public static bool TryParse(ReadOnlySpan<byte> text, out sbyte value, out int bytesConsumed, char standardFormat='\0');
+        public static bool TryParse(ReadOnlySpan<byte> text, out short value, out int bytesConsumed, char standardFormat='\0');
+        public static bool TryParse(ReadOnlySpan<byte> text, out int value, out int bytesConsumed, char standardFormat='\0');
+        public static bool TryParse(ReadOnlySpan<byte> text, out long value, out int bytesConsumed, char standardFormat='\0');
+        public static bool TryParse(ReadOnlySpan<byte> text, out float value, out int bytesConsumed, char standardFormat='\0');
+        public static bool TryParse(ReadOnlySpan<byte> text, out double value, out int bytesConsumed, char standardFormat='\0');
+        public static bool TryParse(ReadOnlySpan<byte> text, out ushort value, out int bytesConsumed, char standardFormat='\0');
+        public static bool TryParse(ReadOnlySpan<byte> text, out uint value, out int bytesConsumed, char standardFormat='\0');
+        public static bool TryParse(ReadOnlySpan<byte> text, out ulong value, out int bytesConsumed, char standardFormat='\0');
+        public static bool TryParse(ReadOnlySpan<byte> text, out bool value, out int bytesConsumed, char standardFormat='\0');
+        public static bool TryParse(ReadOnlySpan<byte> text, out decimal value, out int bytesConsumed, char standardFormat='\0');
+        public static bool TryParse(ReadOnlySpan<byte> text, out DateTime value, out int bytesConsumed, char standardFormat='\0');
+        public static bool TryParse(ReadOnlySpan<byte> text, out TimeSpan value, out int bytesConsumed, char standardFormat='\0');
+        public static bool TryParse(ReadOnlySpan<byte> text, out DateTimeOffset value, out int bytesConsumed, char standardFormat='\0');
+    }
+}
+namespace System.CodeDom {
+    public class CodeArgumentReferenceExpression : CodeExpression {
+        public CodeArgumentReferenceExpression();
+        public CodeArgumentReferenceExpression(string parameterName);
+        public string ParameterName { get; set; }
+    }
+    public class CodeArrayCreateExpression : CodeExpression {
+        public CodeArrayCreateExpression();
+        public CodeArrayCreateExpression(CodeTypeReference createType, CodeExpression size);
+        public CodeArrayCreateExpression(CodeTypeReference createType, params CodeExpression[] initializers);
+        public CodeArrayCreateExpression(CodeTypeReference createType, int size);
+        public CodeArrayCreateExpression(string createType, CodeExpression size);
+        public CodeArrayCreateExpression(string createType, params CodeExpression[] initializers);
+        public CodeArrayCreateExpression(string createType, int size);
+        public CodeArrayCreateExpression(Type createType, CodeExpression size);
+        public CodeArrayCreateExpression(Type createType, params CodeExpression[] initializers);
+        public CodeArrayCreateExpression(Type createType, int size);
+        public CodeTypeReference CreateType { get; set; }
+        public CodeExpressionCollection Initializers { get; }
+        public int Size { get; set; }
+        public CodeExpression SizeExpression { get; set; }
+    }
+    public class CodeArrayIndexerExpression : CodeExpression {
+        public CodeArrayIndexerExpression();
+        public CodeArrayIndexerExpression(CodeExpression targetObject, params CodeExpression[] indices);
+        public CodeExpressionCollection Indices { get; }
+        public CodeExpression TargetObject { get; set; }
+    }
+    public class CodeAssignStatement : CodeStatement {
+        public CodeAssignStatement();
+        public CodeAssignStatement(CodeExpression left, CodeExpression right);
+        public CodeExpression Left { get; set; }
+        public CodeExpression Right { get; set; }
+    }
+    public class CodeAttachEventStatement : CodeStatement {
+        public CodeAttachEventStatement();
+        public CodeAttachEventStatement(CodeEventReferenceExpression eventRef, CodeExpression listener);
+        public CodeAttachEventStatement(CodeExpression targetObject, string eventName, CodeExpression listener);
+        public CodeEventReferenceExpression Event { get; set; }
+        public CodeExpression Listener { get; set; }
+    }
+    public class CodeAttributeArgument {
+        public CodeAttributeArgument();
+        public CodeAttributeArgument(CodeExpression value);
+        public CodeAttributeArgument(string name, CodeExpression value);
+        public string Name { get; set; }
+        public CodeExpression Value { get; set; }
+    }
+    public class CodeAttributeArgumentCollection : CollectionBase {
+        public CodeAttributeArgumentCollection();
+        public CodeAttributeArgumentCollection(CodeAttributeArgumentCollection value);
+        public CodeAttributeArgumentCollection(CodeAttributeArgument[] value);
+        public CodeAttributeArgument this[int index] { get; set; }
+        public int Add(CodeAttributeArgument value);
+        public void AddRange(CodeAttributeArgumentCollection value);
+        public void AddRange(CodeAttributeArgument[] value);
+        public bool Contains(CodeAttributeArgument value);
+        public void CopyTo(CodeAttributeArgument[] array, int index);
+        public int IndexOf(CodeAttributeArgument value);
+        public void Insert(int index, CodeAttributeArgument value);
+        public void Remove(CodeAttributeArgument value);
+    }
+    public class CodeAttributeDeclaration {
+        public CodeAttributeDeclaration();
+        public CodeAttributeDeclaration(CodeTypeReference attributeType);
+        public CodeAttributeDeclaration(CodeTypeReference attributeType, params CodeAttributeArgument[] arguments);
+        public CodeAttributeDeclaration(string name);
+        public CodeAttributeDeclaration(string name, params CodeAttributeArgument[] arguments);
+        public CodeAttributeArgumentCollection Arguments { get; }
+        public CodeTypeReference AttributeType { get; }
+        public string Name { get; set; }
+    }
+    public class CodeAttributeDeclarationCollection : CollectionBase {
+        public CodeAttributeDeclarationCollection();
+        public CodeAttributeDeclarationCollection(CodeAttributeDeclarationCollection value);
+        public CodeAttributeDeclarationCollection(CodeAttributeDeclaration[] value);
+        public CodeAttributeDeclaration this[int index] { get; set; }
+        public int Add(CodeAttributeDeclaration value);
+        public void AddRange(CodeAttributeDeclarationCollection value);
+        public void AddRange(CodeAttributeDeclaration[] value);
+        public bool Contains(CodeAttributeDeclaration value);
+        public void CopyTo(CodeAttributeDeclaration[] array, int index);
+        public int IndexOf(CodeAttributeDeclaration value);
+        public void Insert(int index, CodeAttributeDeclaration value);
+        public void Remove(CodeAttributeDeclaration value);
+    }
+    public class CodeBaseReferenceExpression : CodeExpression {
+        public CodeBaseReferenceExpression();
+    }
+    public class CodeBinaryOperatorExpression : CodeExpression {
+        public CodeBinaryOperatorExpression();
+        public CodeBinaryOperatorExpression(CodeExpression left, CodeBinaryOperatorType op, CodeExpression right);
+        public CodeExpression Left { get; set; }
+        public CodeBinaryOperatorType Operator { get; set; }
+        public CodeExpression Right { get; set; }
+    }
+    public enum CodeBinaryOperatorType {
+        Add = 0,
+        Assign = 5,
+        BitwiseAnd = 10,
+        BitwiseOr = 9,
+        BooleanAnd = 12,
+        BooleanOr = 11,
+        Divide = 3,
+        GreaterThan = 15,
+        GreaterThanOrEqual = 16,
+        IdentityEquality = 7,
+        IdentityInequality = 6,
+        LessThan = 13,
+        LessThanOrEqual = 14,
+        Modulus = 4,
+        Multiply = 2,
+        Subtract = 1,
+        ValueEquality = 8,
+    }
+    public class CodeCastExpression : CodeExpression {
+        public CodeCastExpression();
+        public CodeCastExpression(CodeTypeReference targetType, CodeExpression expression);
+        public CodeCastExpression(string targetType, CodeExpression expression);
+        public CodeCastExpression(Type targetType, CodeExpression expression);
+        public CodeExpression Expression { get; set; }
+        public CodeTypeReference TargetType { get; set; }
+    }
+    public class CodeCatchClause {
+        public CodeCatchClause();
+        public CodeCatchClause(string localName);
+        public CodeCatchClause(string localName, CodeTypeReference catchExceptionType);
+        public CodeCatchClause(string localName, CodeTypeReference catchExceptionType, params CodeStatement[] statements);
+        public CodeTypeReference CatchExceptionType { get; set; }
+        public string LocalName { get; set; }
+        public CodeStatementCollection Statements { get; }
+    }
+    public class CodeCatchClauseCollection : CollectionBase {
+        public CodeCatchClauseCollection();
+        public CodeCatchClauseCollection(CodeCatchClauseCollection value);
+        public CodeCatchClauseCollection(CodeCatchClause[] value);
+        public CodeCatchClause this[int index] { get; set; }
+        public int Add(CodeCatchClause value);
+        public void AddRange(CodeCatchClauseCollection value);
+        public void AddRange(CodeCatchClause[] value);
+        public bool Contains(CodeCatchClause value);
+        public void CopyTo(CodeCatchClause[] array, int index);
+        public int IndexOf(CodeCatchClause value);
+        public void Insert(int index, CodeCatchClause value);
+        public void Remove(CodeCatchClause value);
+    }
+    public class CodeChecksumPragma : CodeDirective {
+        public CodeChecksumPragma();
+        public CodeChecksumPragma(string fileName, Guid checksumAlgorithmId, byte[] checksumData);
+        public Guid ChecksumAlgorithmId { get; set; }
+        public byte[] ChecksumData { get; set; }
+        public string FileName { get; set; }
+    }
+    public class CodeComment : CodeObject {
+        public CodeComment();
+        public CodeComment(string text);
+        public CodeComment(string text, bool docComment);
+        public bool DocComment { get; set; }
+        public string Text { get; set; }
+    }
+    public class CodeCommentStatement : CodeStatement {
+        public CodeCommentStatement();
+        public CodeCommentStatement(CodeComment comment);
+        public CodeCommentStatement(string text);
+        public CodeCommentStatement(string text, bool docComment);
+        public CodeComment Comment { get; set; }
+    }
+    public class CodeCommentStatementCollection : CollectionBase {
+        public CodeCommentStatementCollection();
+        public CodeCommentStatementCollection(CodeCommentStatementCollection value);
+        public CodeCommentStatementCollection(CodeCommentStatement[] value);
+        public CodeCommentStatement this[int index] { get; set; }
+        public int Add(CodeCommentStatement value);
+        public void AddRange(CodeCommentStatementCollection value);
+        public void AddRange(CodeCommentStatement[] value);
+        public bool Contains(CodeCommentStatement value);
+        public void CopyTo(CodeCommentStatement[] array, int index);
+        public int IndexOf(CodeCommentStatement value);
+        public void Insert(int index, CodeCommentStatement value);
+        public void Remove(CodeCommentStatement value);
+    }
+    public class CodeCompileUnit : CodeObject {
+        public CodeCompileUnit();
+        public CodeAttributeDeclarationCollection AssemblyCustomAttributes { get; }
+        public CodeDirectiveCollection EndDirectives { get; }
+        public CodeNamespaceCollection Namespaces { get; }
+        public StringCollection ReferencedAssemblies { get; }
+        public CodeDirectiveCollection StartDirectives { get; }
+    }
+    public class CodeConditionStatement : CodeStatement {
+        public CodeConditionStatement();
+        public CodeConditionStatement(CodeExpression condition, params CodeStatement[] trueStatements);
+        public CodeConditionStatement(CodeExpression condition, CodeStatement[] trueStatements, CodeStatement[] falseStatements);
+        public CodeExpression Condition { get; set; }
+        public CodeStatementCollection FalseStatements { get; }
+        public CodeStatementCollection TrueStatements { get; }
+    }
+    public class CodeConstructor : CodeMemberMethod {
+        public CodeConstructor();
+        public CodeExpressionCollection BaseConstructorArgs { get; }
+        public CodeExpressionCollection ChainedConstructorArgs { get; }
+    }
+    public class CodeDefaultValueExpression : CodeExpression {
+        public CodeDefaultValueExpression();
+        public CodeDefaultValueExpression(CodeTypeReference type);
+        public CodeTypeReference Type { get; set; }
+    }
+    public class CodeDelegateCreateExpression : CodeExpression {
+        public CodeDelegateCreateExpression();
+        public CodeDelegateCreateExpression(CodeTypeReference delegateType, CodeExpression targetObject, string methodName);
+        public CodeTypeReference DelegateType { get; set; }
+        public string MethodName { get; set; }
+        public CodeExpression TargetObject { get; set; }
+    }
+    public class CodeDelegateInvokeExpression : CodeExpression {
+        public CodeDelegateInvokeExpression();
+        public CodeDelegateInvokeExpression(CodeExpression targetObject);
+        public CodeDelegateInvokeExpression(CodeExpression targetObject, params CodeExpression[] parameters);
+        public CodeExpressionCollection Parameters { get; }
+        public CodeExpression TargetObject { get; set; }
+    }
+    public class CodeDirectionExpression : CodeExpression {
+        public CodeDirectionExpression();
+        public CodeDirectionExpression(FieldDirection direction, CodeExpression expression);
+        public FieldDirection Direction { get; set; }
+        public CodeExpression Expression { get; set; }
+    }
+    public class CodeDirective : CodeObject {
+        public CodeDirective();
+    }
+    public class CodeDirectiveCollection : CollectionBase {
+        public CodeDirectiveCollection();
+        public CodeDirectiveCollection(CodeDirectiveCollection value);
+        public CodeDirectiveCollection(CodeDirective[] value);
+        public CodeDirective this[int index] { get; set; }
+        public int Add(CodeDirective value);
+        public void AddRange(CodeDirectiveCollection value);
+        public void AddRange(CodeDirective[] value);
+        public bool Contains(CodeDirective value);
+        public void CopyTo(CodeDirective[] array, int index);
+        public int IndexOf(CodeDirective value);
+        public void Insert(int index, CodeDirective value);
+        public void Remove(CodeDirective value);
+    }
+    public class CodeEntryPointMethod : CodeMemberMethod {
+        public CodeEntryPointMethod();
+    }
+    public class CodeEventReferenceExpression : CodeExpression {
+        public CodeEventReferenceExpression();
+        public CodeEventReferenceExpression(CodeExpression targetObject, string eventName);
+        public string EventName { get; set; }
+        public CodeExpression TargetObject { get; set; }
+    }
+    public class CodeExpression : CodeObject {
+        public CodeExpression();
+    }
+    public class CodeExpressionCollection : CollectionBase {
+        public CodeExpressionCollection();
+        public CodeExpressionCollection(CodeExpressionCollection value);
+        public CodeExpressionCollection(CodeExpression[] value);
+        public CodeExpression this[int index] { get; set; }
+        public int Add(CodeExpression value);
+        public void AddRange(CodeExpressionCollection value);
+        public void AddRange(CodeExpression[] value);
+        public bool Contains(CodeExpression value);
+        public void CopyTo(CodeExpression[] array, int index);
+        public int IndexOf(CodeExpression value);
+        public void Insert(int index, CodeExpression value);
+        public void Remove(CodeExpression value);
+    }
+    public class CodeExpressionStatement : CodeStatement {
+        public CodeExpressionStatement();
+        public CodeExpressionStatement(CodeExpression expression);
+        public CodeExpression Expression { get; set; }
+    }
+    public class CodeFieldReferenceExpression : CodeExpression {
+        public CodeFieldReferenceExpression();
+        public CodeFieldReferenceExpression(CodeExpression targetObject, string fieldName);
+        public string FieldName { get; set; }
+        public CodeExpression TargetObject { get; set; }
+    }
+    public class CodeGotoStatement : CodeStatement {
+        public CodeGotoStatement();
+        public CodeGotoStatement(string label);
+        public string Label { get; set; }
+    }
+    public class CodeIndexerExpression : CodeExpression {
+        public CodeIndexerExpression();
+        public CodeIndexerExpression(CodeExpression targetObject, params CodeExpression[] indices);
+        public CodeExpressionCollection Indices { get; }
+        public CodeExpression TargetObject { get; set; }
+    }
+    public class CodeIterationStatement : CodeStatement {
+        public CodeIterationStatement();
+        public CodeIterationStatement(CodeStatement initStatement, CodeExpression testExpression, CodeStatement incrementStatement, params CodeStatement[] statements);
+        public CodeStatement IncrementStatement { get; set; }
+        public CodeStatement InitStatement { get; set; }
+        public CodeStatementCollection Statements { get; }
+        public CodeExpression TestExpression { get; set; }
+    }
+    public class CodeLabeledStatement : CodeStatement {
+        public CodeLabeledStatement();
+        public CodeLabeledStatement(string label);
+        public CodeLabeledStatement(string label, CodeStatement statement);
+        public string Label { get; set; }
+        public CodeStatement Statement { get; set; }
+    }
+    public class CodeLinePragma {
+        public CodeLinePragma();
+        public CodeLinePragma(string fileName, int lineNumber);
+        public string FileName { get; set; }
+        public int LineNumber { get; set; }
+    }
+    public class CodeMemberEvent : CodeTypeMember {
+        public CodeMemberEvent();
+        public CodeTypeReferenceCollection ImplementationTypes { get; }
+        public CodeTypeReference PrivateImplementationType { get; set; }
+        public CodeTypeReference Type { get; set; }
+    }
+    public class CodeMemberField : CodeTypeMember {
+        public CodeMemberField();
+        public CodeMemberField(CodeTypeReference type, string name);
+        public CodeMemberField(string type, string name);
+        public CodeMemberField(Type type, string name);
+        public CodeExpression InitExpression { get; set; }
+        public CodeTypeReference Type { get; set; }
+    }
+    public class CodeMemberMethod : CodeTypeMember {
+        public CodeMemberMethod();
+        public CodeTypeReferenceCollection ImplementationTypes { get; }
+        public CodeParameterDeclarationExpressionCollection Parameters { get; }
+        public CodeTypeReference PrivateImplementationType { get; set; }
+        public CodeTypeReference ReturnType { get; set; }
+        public CodeAttributeDeclarationCollection ReturnTypeCustomAttributes { get; }
+        public CodeStatementCollection Statements { get; }
+        public CodeTypeParameterCollection TypeParameters { get; }
+        public event EventHandler PopulateImplementationTypes;
+        public event EventHandler PopulateParameters;
+        public event EventHandler PopulateStatements;
+    }
+    public class CodeMemberProperty : CodeTypeMember {
+        public CodeMemberProperty();
+        public CodeStatementCollection GetStatements { get; }
+        public bool HasGet { get; set; }
+        public bool HasSet { get; set; }
+        public CodeTypeReferenceCollection ImplementationTypes { get; }
+        public CodeParameterDeclarationExpressionCollection Parameters { get; }
+        public CodeTypeReference PrivateImplementationType { get; set; }
+        public CodeStatementCollection SetStatements { get; }
+        public CodeTypeReference Type { get; set; }
+    }
+    public class CodeMethodInvokeExpression : CodeExpression {
+        public CodeMethodInvokeExpression();
+        public CodeMethodInvokeExpression(CodeExpression targetObject, string methodName, params CodeExpression[] parameters);
+        public CodeMethodInvokeExpression(CodeMethodReferenceExpression method, params CodeExpression[] parameters);
+        public CodeMethodReferenceExpression Method { get; set; }
+        public CodeExpressionCollection Parameters { get; }
+    }
+    public class CodeMethodReferenceExpression : CodeExpression {
+        public CodeMethodReferenceExpression();
+        public CodeMethodReferenceExpression(CodeExpression targetObject, string methodName);
+        public CodeMethodReferenceExpression(CodeExpression targetObject, string methodName, params CodeTypeReference[] typeParameters);
+        public string MethodName { get; set; }
+        public CodeExpression TargetObject { get; set; }
+        public CodeTypeReferenceCollection TypeArguments { get; }
+    }
+    public class CodeMethodReturnStatement : CodeStatement {
+        public CodeMethodReturnStatement();
+        public CodeMethodReturnStatement(CodeExpression expression);
+        public CodeExpression Expression { get; set; }
+    }
+    public class CodeNamespace : CodeObject {
+        public CodeNamespace();
+        public CodeNamespace(string name);
+        public CodeCommentStatementCollection Comments { get; }
+        public CodeNamespaceImportCollection Imports { get; }
+        public string Name { get; set; }
+        public CodeTypeDeclarationCollection Types { get; }
+        public event EventHandler PopulateComments;
+        public event EventHandler PopulateImports;
+        public event EventHandler PopulateTypes;
+    }
+    public class CodeNamespaceCollection : CollectionBase {
+        public CodeNamespaceCollection();
+        public CodeNamespaceCollection(CodeNamespaceCollection value);
+        public CodeNamespaceCollection(CodeNamespace[] value);
+        public CodeNamespace this[int index] { get; set; }
+        public int Add(CodeNamespace value);
+        public void AddRange(CodeNamespaceCollection value);
+        public void AddRange(CodeNamespace[] value);
+        public bool Contains(CodeNamespace value);
+        public void CopyTo(CodeNamespace[] array, int index);
+        public int IndexOf(CodeNamespace value);
+        public void Insert(int index, CodeNamespace value);
+        public void Remove(CodeNamespace value);
+    }
+    public class CodeNamespaceImport : CodeObject {
+        public CodeNamespaceImport();
+        public CodeNamespaceImport(string nameSpace);
+        public CodeLinePragma LinePragma { get; set; }
+        public string Namespace { get; set; }
+    }
+    public class CodeNamespaceImportCollection : ICollection, IEnumerable, IList {
+        public CodeNamespaceImportCollection();
+        public int Count { get; }
+        public CodeNamespaceImport this[int index] { get; set; }
+        int System.Collections.ICollection.Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public void Add(CodeNamespaceImport value);
+        public void AddRange(CodeNamespaceImport[] value);
+        public void Clear();
+        public IEnumerator GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        get;
+        get;
+        get;
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        int System.Collections.IList.Add(object value);
+        void System.Collections.IList.Clear();
+        bool System.Collections.IList.Contains(object value);
+        get;
+        get;
+        get;
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+        void System.Collections.IList.RemoveAt(int index);
+        set;
+    }
+    public class CodeObject {
+        public CodeObject();
+        public IDictionary UserData { get; }
+    }
+    public class CodeObjectCreateExpression : CodeExpression {
+        public CodeObjectCreateExpression();
+        public CodeObjectCreateExpression(CodeTypeReference createType, params CodeExpression[] parameters);
+        public CodeObjectCreateExpression(string createType, params CodeExpression[] parameters);
+        public CodeObjectCreateExpression(Type createType, params CodeExpression[] parameters);
+        public CodeTypeReference CreateType { get; set; }
+        public CodeExpressionCollection Parameters { get; }
+    }
+    public class CodeParameterDeclarationExpression : CodeExpression {
+        public CodeParameterDeclarationExpression();
+        public CodeParameterDeclarationExpression(CodeTypeReference type, string name);
+        public CodeParameterDeclarationExpression(string type, string name);
+        public CodeParameterDeclarationExpression(Type type, string name);
+        public CodeAttributeDeclarationCollection CustomAttributes { get; set; }
+        public FieldDirection Direction { get; set; }
+        public string Name { get; set; }
+        public CodeTypeReference Type { get; set; }
+    }
+    public class CodeParameterDeclarationExpressionCollection : CollectionBase {
+        public CodeParameterDeclarationExpressionCollection();
+        public CodeParameterDeclarationExpressionCollection(CodeParameterDeclarationExpressionCollection value);
+        public CodeParameterDeclarationExpressionCollection(CodeParameterDeclarationExpression[] value);
+        public CodeParameterDeclarationExpression this[int index] { get; set; }
+        public int Add(CodeParameterDeclarationExpression value);
+        public void AddRange(CodeParameterDeclarationExpressionCollection value);
+        public void AddRange(CodeParameterDeclarationExpression[] value);
+        public bool Contains(CodeParameterDeclarationExpression value);
+        public void CopyTo(CodeParameterDeclarationExpression[] array, int index);
+        public int IndexOf(CodeParameterDeclarationExpression value);
+        public void Insert(int index, CodeParameterDeclarationExpression value);
+        public void Remove(CodeParameterDeclarationExpression value);
+    }
+    public class CodePrimitiveExpression : CodeExpression {
+        public CodePrimitiveExpression();
+        public CodePrimitiveExpression(object value);
+        public object Value { get; set; }
+    }
+    public class CodePropertyReferenceExpression : CodeExpression {
+        public CodePropertyReferenceExpression();
+        public CodePropertyReferenceExpression(CodeExpression targetObject, string propertyName);
+        public string PropertyName { get; set; }
+        public CodeExpression TargetObject { get; set; }
+    }
+    public class CodePropertySetValueReferenceExpression : CodeExpression {
+        public CodePropertySetValueReferenceExpression();
+    }
+    public class CodeRegionDirective : CodeDirective {
+        public CodeRegionDirective();
+        public CodeRegionDirective(CodeRegionMode regionMode, string regionText);
+        public CodeRegionMode RegionMode { get; set; }
+        public string RegionText { get; set; }
+    }
+    public enum CodeRegionMode {
+        End = 2,
+        None = 0,
+        Start = 1,
+    }
+    public class CodeRemoveEventStatement : CodeStatement {
+        public CodeRemoveEventStatement();
+        public CodeRemoveEventStatement(CodeEventReferenceExpression eventRef, CodeExpression listener);
+        public CodeRemoveEventStatement(CodeExpression targetObject, string eventName, CodeExpression listener);
+        public CodeEventReferenceExpression Event { get; set; }
+        public CodeExpression Listener { get; set; }
+    }
+    public class CodeSnippetCompileUnit : CodeCompileUnit {
+        public CodeSnippetCompileUnit();
+        public CodeSnippetCompileUnit(string value);
+        public CodeLinePragma LinePragma { get; set; }
+        public string Value { get; set; }
+    }
+    public class CodeSnippetExpression : CodeExpression {
+        public CodeSnippetExpression();
+        public CodeSnippetExpression(string value);
+        public string Value { get; set; }
+    }
+    public class CodeSnippetStatement : CodeStatement {
+        public CodeSnippetStatement();
+        public CodeSnippetStatement(string value);
+        public string Value { get; set; }
+    }
+    public class CodeSnippetTypeMember : CodeTypeMember {
+        public CodeSnippetTypeMember();
+        public CodeSnippetTypeMember(string text);
+        public string Text { get; set; }
+    }
+    public class CodeStatement : CodeObject {
+        public CodeStatement();
+        public CodeDirectiveCollection EndDirectives { get; }
+        public CodeLinePragma LinePragma { get; set; }
+        public CodeDirectiveCollection StartDirectives { get; }
+    }
+    public class CodeStatementCollection : CollectionBase {
+        public CodeStatementCollection();
+        public CodeStatementCollection(CodeStatementCollection value);
+        public CodeStatementCollection(CodeStatement[] value);
+        public CodeStatement this[int index] { get; set; }
+        public int Add(CodeExpression value);
+        public int Add(CodeStatement value);
+        public void AddRange(CodeStatementCollection value);
+        public void AddRange(CodeStatement[] value);
+        public bool Contains(CodeStatement value);
+        public void CopyTo(CodeStatement[] array, int index);
+        public int IndexOf(CodeStatement value);
+        public void Insert(int index, CodeStatement value);
+        public void Remove(CodeStatement value);
+    }
+    public class CodeThisReferenceExpression : CodeExpression {
+        public CodeThisReferenceExpression();
+    }
+    public class CodeThrowExceptionStatement : CodeStatement {
+        public CodeThrowExceptionStatement();
+        public CodeThrowExceptionStatement(CodeExpression toThrow);
+        public CodeExpression ToThrow { get; set; }
+    }
+    public class CodeTryCatchFinallyStatement : CodeStatement {
+        public CodeTryCatchFinallyStatement();
+        public CodeTryCatchFinallyStatement(CodeStatement[] tryStatements, CodeCatchClause[] catchClauses);
+        public CodeTryCatchFinallyStatement(CodeStatement[] tryStatements, CodeCatchClause[] catchClauses, CodeStatement[] finallyStatements);
+        public CodeCatchClauseCollection CatchClauses { get; }
+        public CodeStatementCollection FinallyStatements { get; }
+        public CodeStatementCollection TryStatements { get; }
+    }
+    public class CodeTypeConstructor : CodeMemberMethod {
+        public CodeTypeConstructor();
+    }
+    public class CodeTypeDeclaration : CodeTypeMember {
+        public CodeTypeDeclaration();
+        public CodeTypeDeclaration(string name);
+        public CodeTypeReferenceCollection BaseTypes { get; }
+        public bool IsClass { get; set; }
+        public bool IsEnum { get; set; }
+        public bool IsInterface { get; set; }
+        public bool IsPartial { get; set; }
+        public bool IsStruct { get; set; }
+        public CodeTypeMemberCollection Members { get; }
+        public TypeAttributes TypeAttributes { get; set; }
+        public CodeTypeParameterCollection TypeParameters { get; }
+        public event EventHandler PopulateBaseTypes;
+        public event EventHandler PopulateMembers;
+    }
+    public class CodeTypeDeclarationCollection : CollectionBase {
+        public CodeTypeDeclarationCollection();
+        public CodeTypeDeclarationCollection(CodeTypeDeclarationCollection value);
+        public CodeTypeDeclarationCollection(CodeTypeDeclaration[] value);
+        public CodeTypeDeclaration this[int index] { get; set; }
+        public int Add(CodeTypeDeclaration value);
+        public void AddRange(CodeTypeDeclarationCollection value);
+        public void AddRange(CodeTypeDeclaration[] value);
+        public bool Contains(CodeTypeDeclaration value);
+        public void CopyTo(CodeTypeDeclaration[] array, int index);
+        public int IndexOf(CodeTypeDeclaration value);
+        public void Insert(int index, CodeTypeDeclaration value);
+        public void Remove(CodeTypeDeclaration value);
+    }
+    public class CodeTypeDelegate : CodeTypeDeclaration {
+        public CodeTypeDelegate();
+        public CodeTypeDelegate(string name);
+        public CodeParameterDeclarationExpressionCollection Parameters { get; }
+        public CodeTypeReference ReturnType { get; set; }
+    }
+    public class CodeTypeMember : CodeObject {
+        public CodeTypeMember();
+        public MemberAttributes Attributes { get; set; }
+        public CodeCommentStatementCollection Comments { get; }
+        public CodeAttributeDeclarationCollection CustomAttributes { get; set; }
+        public CodeDirectiveCollection EndDirectives { get; }
+        public CodeLinePragma LinePragma { get; set; }
+        public string Name { get; set; }
+        public CodeDirectiveCollection StartDirectives { get; }
+    }
+    public class CodeTypeMemberCollection : CollectionBase {
+        public CodeTypeMemberCollection();
+        public CodeTypeMemberCollection(CodeTypeMemberCollection value);
+        public CodeTypeMemberCollection(CodeTypeMember[] value);
+        public CodeTypeMember this[int index] { get; set; }
+        public int Add(CodeTypeMember value);
+        public void AddRange(CodeTypeMemberCollection value);
+        public void AddRange(CodeTypeMember[] value);
+        public bool Contains(CodeTypeMember value);
+        public void CopyTo(CodeTypeMember[] array, int index);
+        public int IndexOf(CodeTypeMember value);
+        public void Insert(int index, CodeTypeMember value);
+        public void Remove(CodeTypeMember value);
+    }
+    public class CodeTypeOfExpression : CodeExpression {
+        public CodeTypeOfExpression();
+        public CodeTypeOfExpression(CodeTypeReference type);
+        public CodeTypeOfExpression(string type);
+        public CodeTypeOfExpression(Type type);
+        public CodeTypeReference Type { get; set; }
+    }
+    public class CodeTypeParameter : CodeObject {
+        public CodeTypeParameter();
+        public CodeTypeParameter(string name);
+        public CodeTypeReferenceCollection Constraints { get; }
+        public CodeAttributeDeclarationCollection CustomAttributes { get; }
+        public bool HasConstructorConstraint { get; set; }
+        public string Name { get; set; }
+    }
+    public class CodeTypeParameterCollection : CollectionBase {
+        public CodeTypeParameterCollection();
+        public CodeTypeParameterCollection(CodeTypeParameterCollection value);
+        public CodeTypeParameterCollection(CodeTypeParameter[] value);
+        public CodeTypeParameter this[int index] { get; set; }
+        public int Add(CodeTypeParameter value);
+        public void Add(string value);
+        public void AddRange(CodeTypeParameterCollection value);
+        public void AddRange(CodeTypeParameter[] value);
+        public bool Contains(CodeTypeParameter value);
+        public void CopyTo(CodeTypeParameter[] array, int index);
+        public int IndexOf(CodeTypeParameter value);
+        public void Insert(int index, CodeTypeParameter value);
+        public void Remove(CodeTypeParameter value);
+    }
+    public class CodeTypeReference : CodeObject {
+        public CodeTypeReference();
+        public CodeTypeReference(CodeTypeParameter typeParameter);
+        public CodeTypeReference(CodeTypeReference arrayType, int rank);
+        public CodeTypeReference(string typeName);
+        public CodeTypeReference(string typeName, CodeTypeReferenceOptions codeTypeReferenceOption);
+        public CodeTypeReference(string typeName, params CodeTypeReference[] typeArguments);
+        public CodeTypeReference(string baseType, int rank);
+        public CodeTypeReference(Type type);
+        public CodeTypeReference(Type type, CodeTypeReferenceOptions codeTypeReferenceOption);
+        public CodeTypeReference ArrayElementType { get; set; }
+        public int ArrayRank { get; set; }
+        public string BaseType { get; set; }
+        public CodeTypeReferenceOptions Options { get; set; }
+        public CodeTypeReferenceCollection TypeArguments { get; }
+    }
+    public class CodeTypeReferenceCollection : CollectionBase {
+        public CodeTypeReferenceCollection();
+        public CodeTypeReferenceCollection(CodeTypeReferenceCollection value);
+        public CodeTypeReferenceCollection(CodeTypeReference[] value);
+        public CodeTypeReference this[int index] { get; set; }
+        public int Add(CodeTypeReference value);
+        public void Add(string value);
+        public void Add(Type value);
+        public void AddRange(CodeTypeReferenceCollection value);
+        public void AddRange(CodeTypeReference[] value);
+        public bool Contains(CodeTypeReference value);
+        public void CopyTo(CodeTypeReference[] array, int index);
+        public int IndexOf(CodeTypeReference value);
+        public void Insert(int index, CodeTypeReference value);
+        public void Remove(CodeTypeReference value);
+    }
+    public class CodeTypeReferenceExpression : CodeExpression {
+        public CodeTypeReferenceExpression();
+        public CodeTypeReferenceExpression(CodeTypeReference type);
+        public CodeTypeReferenceExpression(string type);
+        public CodeTypeReferenceExpression(Type type);
+        public CodeTypeReference Type { get; set; }
+    }
+    public enum CodeTypeReferenceOptions {
+        GenericTypeParameter = 2,
+        GlobalReference = 1,
+    }
+    public class CodeVariableDeclarationStatement : CodeStatement {
+        public CodeVariableDeclarationStatement();
+        public CodeVariableDeclarationStatement(CodeTypeReference type, string name);
+        public CodeVariableDeclarationStatement(CodeTypeReference type, string name, CodeExpression initExpression);
+        public CodeVariableDeclarationStatement(string type, string name);
+        public CodeVariableDeclarationStatement(string type, string name, CodeExpression initExpression);
+        public CodeVariableDeclarationStatement(Type type, string name);
+        public CodeVariableDeclarationStatement(Type type, string name, CodeExpression initExpression);
+        public CodeExpression InitExpression { get; set; }
+        public string Name { get; set; }
+        public CodeTypeReference Type { get; set; }
+    }
+    public class CodeVariableReferenceExpression : CodeExpression {
+        public CodeVariableReferenceExpression();
+        public CodeVariableReferenceExpression(string variableName);
+        public string VariableName { get; set; }
+    }
+    public enum FieldDirection {
+        In = 0,
+        Out = 1,
+        Ref = 2,
+    }
+    public enum MemberAttributes {
+        Abstract = 1,
+        AccessMask = 61440,
+        Assembly = 4096,
+        Const = 5,
+        Family = 12288,
+        FamilyAndAssembly = 8192,
+        FamilyOrAssembly = 16384,
+        Final = 2,
+        New = 16,
+        Overloaded = 256,
+        Override = 4,
+        Private = 20480,
+        Public = 24576,
+        ScopeMask = 15,
+        Static = 3,
+        VTableMask = 240,
+    }
+}
 namespace System.CodeDom.Compiler {
+    public abstract class CodeCompiler : CodeGenerator, ICodeCompiler {
+        protected CodeCompiler();
+        protected abstract string CompilerName { get; }
+        protected abstract string FileExtension { get; }
+        protected abstract string CmdArgsFromParameters(CompilerParameters options);
+        protected virtual CompilerResults FromDom(CompilerParameters options, CodeCompileUnit e);
+        protected virtual CompilerResults FromDomBatch(CompilerParameters options, CodeCompileUnit[] ea);
+        protected virtual CompilerResults FromFile(CompilerParameters options, string fileName);
+        protected virtual CompilerResults FromFileBatch(CompilerParameters options, string[] fileNames);
+        protected virtual CompilerResults FromSource(CompilerParameters options, string source);
+        protected virtual CompilerResults FromSourceBatch(CompilerParameters options, string[] sources);
+        protected virtual string GetResponseFileCmdArgs(CompilerParameters options, string cmdArgs);
+        protected static string JoinStringArray(string[] sa, string separator);
+        protected abstract void ProcessCompilerOutputLine(CompilerResults results, string line);
+        CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit e);
+        CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] ea);
+        CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromFile(CompilerParameters options, string fileName);
+        CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromFileBatch(CompilerParameters options, string[] fileNames);
+        CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromSource(CompilerParameters options, string source);
+        CompilerResults System.CodeDom.Compiler.ICodeCompiler.CompileAssemblyFromSourceBatch(CompilerParameters options, string[] sources);
+    }
+    public abstract class CodeDomProvider : Component {
+        protected CodeDomProvider();
+        public virtual string FileExtension { get; }
+        public virtual LanguageOptions LanguageOptions { get; }
+        public virtual CompilerResults CompileAssemblyFromDom(CompilerParameters options, params CodeCompileUnit[] compilationUnits);
+        public virtual CompilerResults CompileAssemblyFromFile(CompilerParameters options, params string[] fileNames);
+        public virtual CompilerResults CompileAssemblyFromSource(CompilerParameters options, params string[] sources);
+        public abstract ICodeCompiler CreateCompiler();
+        public virtual string CreateEscapedIdentifier(string value);
+        public abstract ICodeGenerator CreateGenerator();
+        public virtual ICodeGenerator CreateGenerator(string fileName);
+        public virtual ICodeGenerator CreateGenerator(TextWriter output);
+        public virtual ICodeParser CreateParser();
+        public static CodeDomProvider CreateProvider(string language);
+        public static CodeDomProvider CreateProvider(string language, IDictionary<string, string> providerOptions);
+        public virtual string CreateValidIdentifier(string value);
+        public virtual void GenerateCodeFromCompileUnit(CodeCompileUnit compileUnit, TextWriter writer, CodeGeneratorOptions options);
+        public virtual void GenerateCodeFromExpression(CodeExpression expression, TextWriter writer, CodeGeneratorOptions options);
+        public virtual void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options);
+        public virtual void GenerateCodeFromNamespace(CodeNamespace codeNamespace, TextWriter writer, CodeGeneratorOptions options);
+        public virtual void GenerateCodeFromStatement(CodeStatement statement, TextWriter writer, CodeGeneratorOptions options);
+        public virtual void GenerateCodeFromType(CodeTypeDeclaration codeType, TextWriter writer, CodeGeneratorOptions options);
+        public static CompilerInfo[] GetAllCompilerInfo();
+        public static CompilerInfo GetCompilerInfo(string language);
+        public virtual TypeConverter GetConverter(Type type);
+        public static string GetLanguageFromExtension(string extension);
+        public virtual string GetTypeOutput(CodeTypeReference type);
+        public static bool IsDefinedExtension(string extension);
+        public static bool IsDefinedLanguage(string language);
+        public virtual bool IsValidIdentifier(string value);
+        public virtual CodeCompileUnit Parse(TextReader codeStream);
+        public virtual bool Supports(GeneratorSupport generatorSupport);
+    }
+    public abstract class CodeGenerator : ICodeGenerator {
+        protected CodeGenerator();
+        protected CodeTypeDeclaration CurrentClass { get; }
+        protected CodeTypeMember CurrentMember { get; }
+        protected string CurrentMemberName { get; }
+        protected string CurrentTypeName { get; }
+        protected int Indent { get; set; }
+        protected bool IsCurrentClass { get; }
+        protected bool IsCurrentDelegate { get; }
+        protected bool IsCurrentEnum { get; }
+        protected bool IsCurrentInterface { get; }
+        protected bool IsCurrentStruct { get; }
+        protected abstract string NullToken { get; }
+        protected CodeGeneratorOptions Options { get; }
+        protected TextWriter Output { get; }
+        protected virtual void ContinueOnNewLine(string st);
+        protected abstract string CreateEscapedIdentifier(string value);
+        protected abstract string CreateValidIdentifier(string value);
+        protected abstract void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression e);
+        protected abstract void GenerateArrayCreateExpression(CodeArrayCreateExpression e);
+        protected abstract void GenerateArrayIndexerExpression(CodeArrayIndexerExpression e);
+        protected abstract void GenerateAssignStatement(CodeAssignStatement e);
+        protected abstract void GenerateAttachEventStatement(CodeAttachEventStatement e);
+        protected abstract void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes);
+        protected abstract void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes);
+        protected abstract void GenerateBaseReferenceExpression(CodeBaseReferenceExpression e);
+        protected virtual void GenerateBinaryOperatorExpression(CodeBinaryOperatorExpression e);
+        protected abstract void GenerateCastExpression(CodeCastExpression e);
+        public virtual void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options);
+        protected abstract void GenerateComment(CodeComment e);
+        protected virtual void GenerateCommentStatement(CodeCommentStatement e);
+        protected virtual void GenerateCommentStatements(CodeCommentStatementCollection e);
+        protected virtual void GenerateCompileUnit(CodeCompileUnit e);
+        protected virtual void GenerateCompileUnitEnd(CodeCompileUnit e);
+        protected virtual void GenerateCompileUnitStart(CodeCompileUnit e);
+        protected abstract void GenerateConditionStatement(CodeConditionStatement e);
+        protected abstract void GenerateConstructor(CodeConstructor e, CodeTypeDeclaration c);
+        protected virtual void GenerateDecimalValue(decimal d);
+        protected virtual void GenerateDefaultValueExpression(CodeDefaultValueExpression e);
+        protected abstract void GenerateDelegateCreateExpression(CodeDelegateCreateExpression e);
+        protected abstract void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression e);
+        protected virtual void GenerateDirectionExpression(CodeDirectionExpression e);
+        protected virtual void GenerateDirectives(CodeDirectiveCollection directives);
+        protected virtual void GenerateDoubleValue(double d);
+        protected abstract void GenerateEntryPointMethod(CodeEntryPointMethod e, CodeTypeDeclaration c);
+        protected abstract void GenerateEvent(CodeMemberEvent e, CodeTypeDeclaration c);
+        protected abstract void GenerateEventReferenceExpression(CodeEventReferenceExpression e);
+        protected void GenerateExpression(CodeExpression e);
+        protected abstract void GenerateExpressionStatement(CodeExpressionStatement e);
+        protected abstract void GenerateField(CodeMemberField e);
+        protected abstract void GenerateFieldReferenceExpression(CodeFieldReferenceExpression e);
+        protected abstract void GenerateGotoStatement(CodeGotoStatement e);
+        protected abstract void GenerateIndexerExpression(CodeIndexerExpression e);
+        protected abstract void GenerateIterationStatement(CodeIterationStatement e);
+        protected abstract void GenerateLabeledStatement(CodeLabeledStatement e);
+        protected abstract void GenerateLinePragmaEnd(CodeLinePragma e);
+        protected abstract void GenerateLinePragmaStart(CodeLinePragma e);
+        protected abstract void GenerateMethod(CodeMemberMethod e, CodeTypeDeclaration c);
+        protected abstract void GenerateMethodInvokeExpression(CodeMethodInvokeExpression e);
+        protected abstract void GenerateMethodReferenceExpression(CodeMethodReferenceExpression e);
+        protected abstract void GenerateMethodReturnStatement(CodeMethodReturnStatement e);
+        protected virtual void GenerateNamespace(CodeNamespace e);
+        protected abstract void GenerateNamespaceEnd(CodeNamespace e);
+        protected abstract void GenerateNamespaceImport(CodeNamespaceImport e);
+        protected void GenerateNamespaceImports(CodeNamespace e);
+        protected void GenerateNamespaces(CodeCompileUnit e);
+        protected abstract void GenerateNamespaceStart(CodeNamespace e);
+        protected abstract void GenerateObjectCreateExpression(CodeObjectCreateExpression e);
+        protected virtual void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e);
+        protected virtual void GeneratePrimitiveExpression(CodePrimitiveExpression e);
+        protected abstract void GenerateProperty(CodeMemberProperty e, CodeTypeDeclaration c);
+        protected abstract void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression e);
+        protected abstract void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e);
+        protected abstract void GenerateRemoveEventStatement(CodeRemoveEventStatement e);
+        protected virtual void GenerateSingleFloatValue(float s);
+        protected virtual void GenerateSnippetCompileUnit(CodeSnippetCompileUnit e);
+        protected abstract void GenerateSnippetExpression(CodeSnippetExpression e);
+        protected abstract void GenerateSnippetMember(CodeSnippetTypeMember e);
+        protected virtual void GenerateSnippetStatement(CodeSnippetStatement e);
+        protected void GenerateStatement(CodeStatement e);
+        protected void GenerateStatements(CodeStatementCollection stms);
+        protected abstract void GenerateThisReferenceExpression(CodeThisReferenceExpression e);
+        protected abstract void GenerateThrowExceptionStatement(CodeThrowExceptionStatement e);
+        protected abstract void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement e);
+        protected abstract void GenerateTypeConstructor(CodeTypeConstructor e);
+        protected abstract void GenerateTypeEnd(CodeTypeDeclaration e);
+        protected virtual void GenerateTypeOfExpression(CodeTypeOfExpression e);
+        protected virtual void GenerateTypeReferenceExpression(CodeTypeReferenceExpression e);
+        protected void GenerateTypes(CodeNamespace e);
+        protected abstract void GenerateTypeStart(CodeTypeDeclaration e);
+        protected abstract void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement e);
+        protected abstract void GenerateVariableReferenceExpression(CodeVariableReferenceExpression e);
+        protected abstract string GetTypeOutput(CodeTypeReference value);
+        protected abstract bool IsValidIdentifier(string value);
+        public static bool IsValidLanguageIndependentIdentifier(string value);
+        protected virtual void OutputAttributeArgument(CodeAttributeArgument arg);
+        protected virtual void OutputAttributeDeclarations(CodeAttributeDeclarationCollection attributes);
+        protected virtual void OutputDirection(FieldDirection dir);
+        protected virtual void OutputExpressionList(CodeExpressionCollection expressions);
+        protected virtual void OutputExpressionList(CodeExpressionCollection expressions, bool newlineBetweenItems);
+        protected virtual void OutputFieldScopeModifier(MemberAttributes attributes);
+        protected virtual void OutputIdentifier(string ident);
+        protected virtual void OutputMemberAccessModifier(MemberAttributes attributes);
+        protected virtual void OutputMemberScopeModifier(MemberAttributes attributes);
+        protected virtual void OutputOperator(CodeBinaryOperatorType op);
+        protected virtual void OutputParameters(CodeParameterDeclarationExpressionCollection parameters);
+        protected abstract void OutputType(CodeTypeReference typeRef);
+        protected virtual void OutputTypeAttributes(TypeAttributes attributes, bool isStruct, bool isEnum);
+        protected virtual void OutputTypeNamePair(CodeTypeReference typeRef, string name);
+        protected abstract string QuoteSnippetString(string value);
+        protected abstract bool Supports(GeneratorSupport support);
+        string System.CodeDom.Compiler.ICodeGenerator.CreateEscapedIdentifier(string value);
+        string System.CodeDom.Compiler.ICodeGenerator.CreateValidIdentifier(string value);
+        void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromCompileUnit(CodeCompileUnit e, TextWriter w, CodeGeneratorOptions o);
+        void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromExpression(CodeExpression e, TextWriter w, CodeGeneratorOptions o);
+        void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromNamespace(CodeNamespace e, TextWriter w, CodeGeneratorOptions o);
+        void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromStatement(CodeStatement e, TextWriter w, CodeGeneratorOptions o);
+        void System.CodeDom.Compiler.ICodeGenerator.GenerateCodeFromType(CodeTypeDeclaration e, TextWriter w, CodeGeneratorOptions o);
+        string System.CodeDom.Compiler.ICodeGenerator.GetTypeOutput(CodeTypeReference type);
+        bool System.CodeDom.Compiler.ICodeGenerator.IsValidIdentifier(string value);
+        bool System.CodeDom.Compiler.ICodeGenerator.Supports(GeneratorSupport support);
+        void System.CodeDom.Compiler.ICodeGenerator.ValidateIdentifier(string value);
+        protected virtual void ValidateIdentifier(string value);
+        public static void ValidateIdentifiers(CodeObject e);
+    }
+    public class CodeGeneratorOptions {
+        public CodeGeneratorOptions();
+        public bool BlankLinesBetweenMembers { get; set; }
+        public string BracingStyle { get; set; }
+        public bool ElseOnClosing { get; set; }
+        public string IndentString { get; set; }
+        public object this[string index] { get; set; }
+        public bool VerbatimOrder { get; set; }
+    }
+    public abstract class CodeParser : ICodeParser {
+        protected CodeParser();
+        public abstract CodeCompileUnit Parse(TextReader codeStream);
+    }
+    public class CompilerError {
+        public CompilerError();
+        public CompilerError(string fileName, int line, int column, string errorNumber, string errorText);
+        public int Column { get; set; }
+        public string ErrorNumber { get; set; }
+        public string ErrorText { get; set; }
+        public string FileName { get; set; }
+        public bool IsWarning { get; set; }
+        public int Line { get; set; }
+        public override string ToString();
+    }
+    public class CompilerErrorCollection : CollectionBase {
+        public CompilerErrorCollection();
+        public CompilerErrorCollection(CompilerErrorCollection value);
+        public CompilerErrorCollection(CompilerError[] value);
+        public bool HasErrors { get; }
+        public bool HasWarnings { get; }
+        public CompilerError this[int index] { get; set; }
+        public int Add(CompilerError value);
+        public void AddRange(CompilerErrorCollection value);
+        public void AddRange(CompilerError[] value);
+        public bool Contains(CompilerError value);
+        public void CopyTo(CompilerError[] array, int index);
+        public int IndexOf(CompilerError value);
+        public void Insert(int index, CompilerError value);
+        public void Remove(CompilerError value);
+    }
+    public sealed class CompilerInfo {
+        public Type CodeDomProviderType { get; }
+        public bool IsCodeDomProviderTypeValid { get; }
+        public CompilerParameters CreateDefaultCompilerParameters();
+        public CodeDomProvider CreateProvider();
+        public CodeDomProvider CreateProvider(IDictionary<string, string> providerOptions);
+        public override bool Equals(object o);
+        public string[] GetExtensions();
+        public override int GetHashCode();
+        public string[] GetLanguages();
+    }
+    public class CompilerParameters {
+        public CompilerParameters();
+        public CompilerParameters(string[] assemblyNames);
+        public CompilerParameters(string[] assemblyNames, string outputName);
+        public CompilerParameters(string[] assemblyNames, string outputName, bool includeDebugInformation);
+        public string CompilerOptions { get; set; }
+        public string CoreAssemblyFileName { get; set; }
+        public StringCollection EmbeddedResources { get; }
+        public bool GenerateExecutable { get; set; }
+        public bool GenerateInMemory { get; set; }
+        public bool IncludeDebugInformation { get; set; }
+        public StringCollection LinkedResources { get; }
+        public string MainClass { get; set; }
+        public string OutputAssembly { get; set; }
+        public StringCollection ReferencedAssemblies { get; }
+        public TempFileCollection TempFiles { get; set; }
+        public bool TreatWarningsAsErrors { get; set; }
+        public IntPtr UserToken { get; set; }
+        public int WarningLevel { get; set; }
+        public string Win32Resource { get; set; }
+    }
+    public class CompilerResults {
+        public CompilerResults(TempFileCollection tempFiles);
+        public Assembly CompiledAssembly { get; set; }
+        public CompilerErrorCollection Errors { get; }
+        public int NativeCompilerReturnValue { get; set; }
+        public StringCollection Output { get; }
+        public string PathToAssembly { get; set; }
+        public TempFileCollection TempFiles { get; set; }
+    }
+    public static class Executor {
+        public static void ExecWait(string cmd, TempFileCollection tempFiles);
+        public static int ExecWaitWithCapture(IntPtr userToken, string cmd, string currentDir, TempFileCollection tempFiles, ref string outputName, ref string errorName);
+        public static int ExecWaitWithCapture(IntPtr userToken, string cmd, TempFileCollection tempFiles, ref string outputName, ref string errorName);
+        public static int ExecWaitWithCapture(string cmd, string currentDir, TempFileCollection tempFiles, ref string outputName, ref string errorName);
+        public static int ExecWaitWithCapture(string cmd, TempFileCollection tempFiles, ref string outputName, ref string errorName);
+    }
+    public enum GeneratorSupport {
+        ArraysOfArrays = 1,
+        AssemblyAttributes = 4096,
+        ChainedConstructorArguments = 32768,
+        ComplexExpressions = 524288,
+        DeclareDelegates = 512,
+        DeclareEnums = 256,
+        DeclareEvents = 2048,
+        DeclareIndexerProperties = 33554432,
+        DeclareInterfaces = 1024,
+        DeclareValueTypes = 128,
+        EntryPointMethod = 2,
+        GenericTypeDeclaration = 16777216,
+        GenericTypeReference = 8388608,
+        GotoStatements = 4,
+        MultidimensionalArrays = 8,
+        MultipleInterfaceMembers = 131072,
+        NestedTypes = 65536,
+        ParameterAttributes = 8192,
+        PartialTypes = 4194304,
+        PublicStaticMembers = 262144,
+        ReferenceParameters = 16384,
+        Resources = 2097152,
+        ReturnTypeAttributes = 64,
+        StaticConstructors = 16,
+        TryCatchStatements = 32,
+        Win32Resources = 1048576,
+    }
+    public interface ICodeCompiler {
+        CompilerResults CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit compilationUnit);
+        CompilerResults CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] compilationUnits);
+        CompilerResults CompileAssemblyFromFile(CompilerParameters options, string fileName);
+        CompilerResults CompileAssemblyFromFileBatch(CompilerParameters options, string[] fileNames);
+        CompilerResults CompileAssemblyFromSource(CompilerParameters options, string source);
+        CompilerResults CompileAssemblyFromSourceBatch(CompilerParameters options, string[] sources);
+    }
+    public interface ICodeGenerator {
+        string CreateEscapedIdentifier(string value);
+        string CreateValidIdentifier(string value);
+        void GenerateCodeFromCompileUnit(CodeCompileUnit e, TextWriter w, CodeGeneratorOptions o);
+        void GenerateCodeFromExpression(CodeExpression e, TextWriter w, CodeGeneratorOptions o);
+        void GenerateCodeFromNamespace(CodeNamespace e, TextWriter w, CodeGeneratorOptions o);
+        void GenerateCodeFromStatement(CodeStatement e, TextWriter w, CodeGeneratorOptions o);
+        void GenerateCodeFromType(CodeTypeDeclaration e, TextWriter w, CodeGeneratorOptions o);
+        string GetTypeOutput(CodeTypeReference type);
+        bool IsValidIdentifier(string value);
+        bool Supports(GeneratorSupport supports);
+        void ValidateIdentifier(string value);
+    }
+    public interface ICodeParser {
+        CodeCompileUnit Parse(TextReader codeStream);
+    }
+    public enum LanguageOptions {
+        CaseInsensitive = 1,
+        None = 0,
+    }
+    public class TempFileCollection : ICollection, IDisposable, IEnumerable {
+        public TempFileCollection();
+        public TempFileCollection(string tempDir);
+        public TempFileCollection(string tempDir, bool keepFiles);
+        public string BasePath { get; }
+        public int Count { get; }
+        public bool KeepFiles { get; set; }
+        int System.Collections.ICollection.Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public string TempDir { get; }
+        public string AddExtension(string fileExtension);
+        public string AddExtension(string fileExtension, bool keepFile);
+        public void AddFile(string fileName, bool keepFile);
+        public void CopyTo(string[] fileNames, int start);
+        public void Delete();
+        protected virtual void Dispose(bool disposing);
+        ~TempFileCollection();
+        public IEnumerator GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int start);
+        get;
+        get;
+        get;
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        void System.IDisposable.Dispose();
+    }
 }
 namespace System.Collections.Generic {
     public class Dictionary<TKey, TValue> : ICollection, ICollection<KeyValuePair<TKey, TValue>>, IDeserializationCallback, IDictionary, IDictionary<TKey, TValue>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue>, ISerializable {
+        public int EnsureCapacity(int capacity);
+        public void TrimExcess();
+        public void TrimExcess(int capacity);
     }
     public class HashSet<T> : ICollection<T>, IDeserializationCallback, IEnumerable, IEnumerable<T>, IReadOnlyCollection<T>, ISerializable, ISet<T> {
+        public int EnsureCapacity(int capacity);
     }
-    public class KeyNotFoundException : SystemException, ISerializable {
+    public class KeyNotFoundException : SystemException {
     }
 }
 namespace System.Collections.Immutable {
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct ImmutableArray<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IEquatable<ImmutableArray<T>>, IImmutableList<T>, IList, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T>, IStructuralComparable, IStructuralEquatable {
         public sealed class Builder : ICollection<T>, IEnumerable, IEnumerable<T>, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T> {
+            public ref T ItemRef(int index);
         }
+        public ref T ItemRef(int index);
     }
     public sealed class ImmutableList<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IImmutableList<T>, IList, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T> {
         public sealed class Builder : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IList, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T> {
+            public ref T ItemRef(int index);
         }
+        public ref T ItemRef(int index);
     }
     public sealed class ImmutableQueue<T> : IEnumerable, IEnumerable<T>, IImmutableQueue<T> {
+        public ref T PeekRef();
     }
     public sealed class ImmutableSortedDictionary<TKey, TValue> : ICollection, ICollection<KeyValuePair<TKey, TValue>>, IDictionary, IDictionary<TKey, TValue>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IImmutableDictionary<TKey, TValue>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue> {
         public sealed class Builder : ICollection, ICollection<KeyValuePair<TKey, TValue>>, IDictionary, IDictionary<TKey, TValue>, IEnumerable, IEnumerable<KeyValuePair<TKey, TValue>>, IReadOnlyCollection<KeyValuePair<TKey, TValue>>, IReadOnlyDictionary<TKey, TValue> {
+            public ref TValue ValueRef(TKey key);
         }
+        public ref TValue ValueRef(TKey key);
     }
     public sealed class ImmutableSortedSet<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IImmutableSet<T>, IList, IList<T>, IReadOnlyCollection<T>, IReadOnlyList<T>, ISet<T> {
         public sealed class Builder : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IReadOnlyCollection<T>, ISet<T> {
+            public ref T ItemRef(int index);
         }
+        public ref T ItemRef(int index);
     }
     public sealed class ImmutableStack<T> : IEnumerable, IEnumerable<T>, IImmutableStack<T> {
+        public ref T PeekRef();
     }
 }
 namespace System.ComponentModel.DataAnnotations {
     public class DisplayFormatAttribute : Attribute {
+        public Type NullDisplayTextResourceType { get; set; }
+        public string GetNullDisplayText();
     }
     public class RangeAttribute : ValidationAttribute {
+        public bool ConvertValueInInvariantCulture { get; set; }
+        public bool ParseLimitsInInvariantCulture { get; set; }
     }
 }
+namespace System.Composition {
+    public abstract class CompositionContext {
+        protected CompositionContext();
+        public TExport GetExport<TExport>();
+        public TExport GetExport<TExport>(string contractName);
+        public object GetExport(CompositionContract contract);
+        public object GetExport(Type exportType);
+        public object GetExport(Type exportType, string contractName);
+        public IEnumerable<TExport> GetExports<TExport>();
+        public IEnumerable<TExport> GetExports<TExport>(string contractName);
+        public IEnumerable<object> GetExports(Type exportType);
+        public IEnumerable<object> GetExports(Type exportType, string contractName);
+        public bool TryGetExport<TExport>(out TExport export);
+        public bool TryGetExport<TExport>(string contractName, out TExport export);
+        public abstract bool TryGetExport(CompositionContract contract, out object export);
+        public bool TryGetExport(Type exportType, out object export);
+        public bool TryGetExport(Type exportType, string contractName, out object export);
+    }
+    public static class CompositionContextExtensions {
+        public static void SatisfyImports(this CompositionContext compositionContext, object objectWithLooseImports);
+        public static void SatisfyImports(this CompositionContext compositionContext, object objectWithLooseImports, AttributedModelProvider conventions);
+    }
+    public sealed class Export<T> : IDisposable {
+        public Export(T value, Action disposeAction);
+        public T Value { get; }
+        public void Dispose();
+    }
+    public class ExportAttribute : Attribute {
+        public ExportAttribute();
+        public ExportAttribute(string contractName);
+        public ExportAttribute(string contractName, Type contractType);
+        public ExportAttribute(Type contractType);
+        public string ContractName { get; }
+        public Type ContractType { get; }
+    }
+    public class ExportFactory<T> {
+        public ExportFactory(Func<Tuple<T, Action>> exportCreator);
+        public Export<T> CreateExport();
+    }
+    public class ExportFactory<T, TMetadata> : ExportFactory<T> {
+        public ExportFactory(Func<Tuple<T, Action>> exportCreator, TMetadata metadata);
+        public TMetadata Metadata { get; }
+    }
+    public sealed class ExportMetadataAttribute : Attribute {
+        public ExportMetadataAttribute(string name, object value);
+        public string Name { get; }
+        public object Value { get; }
+    }
+    public class ImportAttribute : Attribute {
+        public ImportAttribute();
+        public ImportAttribute(string contractName);
+        public bool AllowDefault { get; set; }
+        public string ContractName { get; }
+    }
+    public sealed class ImportingConstructorAttribute : Attribute {
+        public ImportingConstructorAttribute();
+    }
+    public class ImportManyAttribute : Attribute {
+        public ImportManyAttribute();
+        public ImportManyAttribute(string contractName);
+        public string ContractName { get; }
+    }
+    public sealed class ImportMetadataConstraintAttribute : Attribute {
+        public ImportMetadataConstraintAttribute(string name, object value);
+        public string Name { get; }
+        public object Value { get; }
+    }
+    public sealed class MetadataAttributeAttribute : Attribute {
+        public MetadataAttributeAttribute();
+    }
+    public sealed class OnImportsSatisfiedAttribute : Attribute {
+        public OnImportsSatisfiedAttribute();
+    }
+    public class PartMetadataAttribute : Attribute {
+        public PartMetadataAttribute(string name, object value);
+        public string Name { get; }
+        public object Value { get; }
+    }
+    public sealed class PartNotDiscoverableAttribute : Attribute {
+        public PartNotDiscoverableAttribute();
+    }
+    public class SharedAttribute : PartMetadataAttribute {
+        public SharedAttribute();
+        public SharedAttribute(string sharingBoundaryName);
+        public string SharingBoundary { get; }
+    }
+    public sealed class SharingBoundaryAttribute : Attribute {
+        public SharingBoundaryAttribute(params string[] sharingBoundaryNames);
+        public ReadOnlyCollection<string> SharingBoundaryNames { get; }
+    }
+}
+namespace System.Composition.Convention {
+    public abstract class AttributedModelProvider {
+        protected AttributedModelProvider();
+        public abstract IEnumerable<Attribute> GetCustomAttributes(Type reflectedType, MemberInfo member);
+        public abstract IEnumerable<Attribute> GetCustomAttributes(Type reflectedType, ParameterInfo parameter);
+    }
+    public class ConventionBuilder : AttributedModelProvider {
+        public ConventionBuilder();
+        public PartConventionBuilder<T> ForType<T>();
+        public PartConventionBuilder ForType(Type type);
+        public PartConventionBuilder<T> ForTypesDerivedFrom<T>();
+        public PartConventionBuilder ForTypesDerivedFrom(Type type);
+        public PartConventionBuilder<T> ForTypesMatching<T>(Predicate<Type> typeFilter);
+        public PartConventionBuilder ForTypesMatching(Predicate<Type> typeFilter);
+        public override IEnumerable<Attribute> GetCustomAttributes(Type reflectedType, MemberInfo member);
+        public override IEnumerable<Attribute> GetCustomAttributes(Type reflectedType, ParameterInfo parameter);
+    }
+    public sealed class ExportConventionBuilder {
+        public ExportConventionBuilder AddMetadata(string name, Func<Type, object> getValueFromPartType);
+        public ExportConventionBuilder AddMetadata(string name, object value);
+        public ExportConventionBuilder AsContractName(Func<Type, string> getContractNameFromPartType);
+        public ExportConventionBuilder AsContractName(string contractName);
+        public ExportConventionBuilder AsContractType<T>();
+        public ExportConventionBuilder AsContractType(Type type);
+    }
+    public sealed class ImportConventionBuilder {
+        public ImportConventionBuilder AddMetadataConstraint(string name, Func<Type, object> getConstraintValueFromPartType);
+        public ImportConventionBuilder AddMetadataConstraint(string name, object value);
+        public ImportConventionBuilder AllowDefault();
+        public ImportConventionBuilder AsContractName(Func<Type, string> getContractNameFromPartType);
+        public ImportConventionBuilder AsContractName(string contractName);
+        public ImportConventionBuilder AsMany();
+        public ImportConventionBuilder AsMany(bool isMany);
+    }
+    public abstract class ParameterImportConventionBuilder {
+        public T Import<T>();
+        public T Import<T>(Action<ImportConventionBuilder> configure);
+    }
+    public class PartConventionBuilder {
+        public PartConventionBuilder AddPartMetadata(string name, Func<Type, object> getValueFromPartType);
+        public PartConventionBuilder AddPartMetadata(string name, object value);
+        public PartConventionBuilder Export<T>();
+        public PartConventionBuilder Export<T>(Action<ExportConventionBuilder> exportConfiguration);
+        public PartConventionBuilder Export();
+        public PartConventionBuilder Export(Action<ExportConventionBuilder> exportConfiguration);
+        public PartConventionBuilder ExportInterfaces();
+        public PartConventionBuilder ExportInterfaces(Predicate<Type> interfaceFilter);
+        public PartConventionBuilder ExportInterfaces(Predicate<Type> interfaceFilter, Action<Type, ExportConventionBuilder> exportConfiguration);
+        public PartConventionBuilder ExportProperties<T>(Predicate<PropertyInfo> propertyFilter);
+        public PartConventionBuilder ExportProperties<T>(Predicate<PropertyInfo> propertyFilter, Action<PropertyInfo, ExportConventionBuilder> exportConfiguration);
+        public PartConventionBuilder ExportProperties(Predicate<PropertyInfo> propertyFilter);
+        public PartConventionBuilder ExportProperties(Predicate<PropertyInfo> propertyFilter, Action<PropertyInfo, ExportConventionBuilder> exportConfiguration);
+        public PartConventionBuilder ImportProperties<T>(Predicate<PropertyInfo> propertyFilter);
+        public PartConventionBuilder ImportProperties<T>(Predicate<PropertyInfo> propertyFilter, Action<PropertyInfo, ImportConventionBuilder> importConfiguration);
+        public PartConventionBuilder ImportProperties(Predicate<PropertyInfo> propertyFilter);
+        public PartConventionBuilder ImportProperties(Predicate<PropertyInfo> propertyFilter, Action<PropertyInfo, ImportConventionBuilder> importConfiguration);
+        public PartConventionBuilder NotifyImportsSatisfied(Predicate<MethodInfo> methodFilter);
+        public PartConventionBuilder SelectConstructor(Func<IEnumerable<ConstructorInfo>, ConstructorInfo> constructorSelector);
+        public PartConventionBuilder SelectConstructor(Func<IEnumerable<ConstructorInfo>, ConstructorInfo> constructorSelector, Action<ParameterInfo, ImportConventionBuilder> importConfiguration);
+        public PartConventionBuilder Shared();
+        public PartConventionBuilder Shared(string sharingBoundary);
+    }
+    public class PartConventionBuilder<T> : PartConventionBuilder {
+        public PartConventionBuilder<T> ExportProperty<TContract>(Expression<Func<T, object>> propertySelector);
+        public PartConventionBuilder<T> ExportProperty<TContract>(Expression<Func<T, object>> propertySelector, Action<ExportConventionBuilder> exportConfiguration);
+        public PartConventionBuilder<T> ExportProperty(Expression<Func<T, object>> propertySelector);
+        public PartConventionBuilder<T> ExportProperty(Expression<Func<T, object>> propertySelector, Action<ExportConventionBuilder> exportConfiguration);
+        public PartConventionBuilder<T> ImportProperty<TContract>(Expression<Func<T, object>> propertySelector);
+        public PartConventionBuilder<T> ImportProperty<TContract>(Expression<Func<T, object>> propertySelector, Action<ImportConventionBuilder> importConfiguration);
+        public PartConventionBuilder<T> ImportProperty(Expression<Func<T, object>> propertySelector);
+        public PartConventionBuilder<T> ImportProperty(Expression<Func<T, object>> propertySelector, Action<ImportConventionBuilder> importConfiguration);
+        public PartConventionBuilder<T> NotifyImportsSatisfied(Expression<Action<T>> methodSelector);
+        public PartConventionBuilder<T> SelectConstructor(Expression<Func<ParameterImportConventionBuilder, T>> constructorSelector);
+    }
+}
+namespace System.Composition.Hosting {
+    public class CompositionFailedException : Exception {
+        public CompositionFailedException();
+        public CompositionFailedException(string message);
+        public CompositionFailedException(string message, Exception innerException);
+    }
+    public sealed class CompositionHost : CompositionContext, IDisposable {
+        public static CompositionHost CreateCompositionHost(params ExportDescriptorProvider[] providers);
+        public static CompositionHost CreateCompositionHost(IEnumerable<ExportDescriptorProvider> providers);
+        public void Dispose();
+        public override bool TryGetExport(CompositionContract contract, out object export);
+    }
+    public class ContainerConfiguration {
+        public ContainerConfiguration();
+        public CompositionHost CreateContainer();
+        public ContainerConfiguration WithAssemblies(IEnumerable<Assembly> assemblies);
+        public ContainerConfiguration WithAssemblies(IEnumerable<Assembly> assemblies, AttributedModelProvider conventions);
+        public ContainerConfiguration WithAssembly(Assembly assembly);
+        public ContainerConfiguration WithAssembly(Assembly assembly, AttributedModelProvider conventions);
+        public ContainerConfiguration WithDefaultConventions(AttributedModelProvider conventions);
+        public ContainerConfiguration WithPart<TPart>();
+        public ContainerConfiguration WithPart<TPart>(AttributedModelProvider conventions);
+        public ContainerConfiguration WithPart(Type partType);
+        public ContainerConfiguration WithPart(Type partType, AttributedModelProvider conventions);
+        public ContainerConfiguration WithParts(IEnumerable<Type> partTypes);
+        public ContainerConfiguration WithParts(IEnumerable<Type> partTypes, AttributedModelProvider conventions);
+        public ContainerConfiguration WithParts(params Type[] partTypes);
+        public ContainerConfiguration WithProvider(ExportDescriptorProvider exportDescriptorProvider);
+    }
+}
+namespace System.Composition.Hosting.Core {
+    public delegate object CompositeActivator(LifetimeContext context, CompositionOperation operation); {
+        public CompositeActivator(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(LifetimeContext context, CompositionOperation operation, AsyncCallback callback, object @object);
+        public virtual object EndInvoke(IAsyncResult result);
+        public virtual object Invoke(LifetimeContext context, CompositionOperation operation);
+    }
+    public sealed class CompositionContract {
+        public CompositionContract(Type contractType);
+        public CompositionContract(Type contractType, string contractName);
+        public CompositionContract(Type contractType, string contractName, IDictionary<string, object> metadataConstraints);
+        public string ContractName { get; }
+        public Type ContractType { get; }
+        public IEnumerable<KeyValuePair<string, object>> MetadataConstraints { get; }
+        public CompositionContract ChangeType(Type newContractType);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public override string ToString();
+        public bool TryUnwrapMetadataConstraint<T>(string constraintName, out T constraintValue, out CompositionContract remainingContract);
+    }
+    public class CompositionDependency {
+        public CompositionContract Contract { get; }
+        public bool IsPrerequisite { get; }
+        public object Site { get; }
+        public ExportDescriptorPromise Target { get; }
+        public static CompositionDependency Missing(CompositionContract contract, object site);
+        public static CompositionDependency Oversupplied(CompositionContract contract, IEnumerable<ExportDescriptorPromise> targets, object site);
+        public static CompositionDependency Satisfied(CompositionContract contract, ExportDescriptorPromise target, bool isPrerequisite, object site);
+        public override string ToString();
+    }
+    public sealed class CompositionOperation : IDisposable {
+        public void AddNonPrerequisiteAction(Action action);
+        public void AddPostCompositionAction(Action action);
+        public void Dispose();
+        public static object Run(LifetimeContext outermostLifetimeContext, CompositeActivator compositionRootActivator);
+    }
+    public abstract class DependencyAccessor {
+        protected DependencyAccessor();
+        protected abstract IEnumerable<ExportDescriptorPromise> GetPromises(CompositionContract exportKey);
+        public IEnumerable<CompositionDependency> ResolveDependencies(object site, CompositionContract contract, bool isPrerequisite);
+        public CompositionDependency ResolveRequiredDependency(object site, CompositionContract contract, bool isPrerequisite);
+        public bool TryResolveOptionalDependency(object site, CompositionContract contract, bool isPrerequisite, out CompositionDependency dependency);
+    }
+    public abstract class ExportDescriptor {
+        protected ExportDescriptor();
+        public abstract CompositeActivator Activator { get; }
+        public abstract IDictionary<string, object> Metadata { get; }
+        public static ExportDescriptor Create(CompositeActivator activator, IDictionary<string, object> metadata);
+    }
+    public class ExportDescriptorPromise {
+        public ExportDescriptorPromise(CompositionContract contract, string origin, bool isShared, Func<IEnumerable<CompositionDependency>> dependencies, Func<IEnumerable<CompositionDependency>, ExportDescriptor> getDescriptor);
+        public CompositionContract Contract { get; }
+        public ReadOnlyCollection<CompositionDependency> Dependencies { get; }
+        public bool IsShared { get; }
+        public string Origin { get; }
+        public ExportDescriptor GetDescriptor();
+        public override string ToString();
+    }
+    public abstract class ExportDescriptorProvider {
+        protected static readonly Func<IEnumerable<CompositionDependency>> NoDependencies;
+        protected static readonly IEnumerable<ExportDescriptorPromise> NoExportDescriptors;
+        protected static readonly IDictionary<string, object> NoMetadata;
+        protected ExportDescriptorProvider();
+        public abstract IEnumerable<ExportDescriptorPromise> GetExportDescriptors(CompositionContract contract, DependencyAccessor descriptorAccessor);
+    }
+    public sealed class LifetimeContext : CompositionContext, IDisposable {
+        public void AddBoundInstance(IDisposable instance);
+        public static int AllocateSharingId();
+        public void Dispose();
+        public LifetimeContext FindContextWithin(string sharingBoundary);
+        public object GetOrCreate(int sharingId, CompositionOperation operation, CompositeActivator creator);
+        public override string ToString();
+        public override bool TryGetExport(CompositionContract contract, out object export);
+    }
+}
+namespace System.Configuration {
+    public sealed class ApplicationScopedSettingAttribute : SettingAttribute {
+        public ApplicationScopedSettingAttribute();
+    }
+    public abstract class ApplicationSettingsBase : SettingsBase, INotifyPropertyChanged {
+        protected ApplicationSettingsBase();
+        protected ApplicationSettingsBase(IComponent owner);
+        protected ApplicationSettingsBase(IComponent owner, string settingsKey);
+        protected ApplicationSettingsBase(string settingsKey);
+        public override SettingsContext Context { get; }
+        public override object this[string propertyName] { get; set; }
+        public override SettingsPropertyCollection Properties { get; }
+        public override SettingsPropertyValueCollection PropertyValues { get; }
+        public override SettingsProviderCollection Providers { get; }
+        public string SettingsKey { get; set; }
+        public object GetPreviousVersion(string propertyName);
+        protected virtual void OnPropertyChanged(object sender, PropertyChangedEventArgs e);
+        protected virtual void OnSettingChanging(object sender, SettingChangingEventArgs e);
+        protected virtual void OnSettingsLoaded(object sender, SettingsLoadedEventArgs e);
+        protected virtual void OnSettingsSaving(object sender, CancelEventArgs e);
+        public void Reload();
+        public void Reset();
+        public override void Save();
+        public virtual void Upgrade();
+        public event PropertyChangedEventHandler PropertyChanged;
+        public event SettingChangingEventHandler SettingChanging;
+        public event SettingsLoadedEventHandler SettingsLoaded;
+        public event SettingsSavingEventHandler SettingsSaving;
+    }
+    public sealed class ApplicationSettingsGroup : ConfigurationSectionGroup {
+        public ApplicationSettingsGroup();
+    }
+    public class AppSettingsReader {
+        public AppSettingsReader();
+        public object GetValue(string key, Type type);
+    }
+    public sealed class AppSettingsSection : ConfigurationSection {
+        public AppSettingsSection();
+        public string File { get; set; }
+        public KeyValueConfigurationCollection Settings { get; }
+    }
+    public sealed class CallbackValidator : ConfigurationValidatorBase {
+        public CallbackValidator(Type type, ValidatorCallback callback);
+        public override bool CanValidate(Type type);
+        public override void Validate(object value);
+    }
+    public sealed class CallbackValidatorAttribute : ConfigurationValidatorAttribute {
+        public CallbackValidatorAttribute();
+        public string CallbackMethodName { get; set; }
+        public Type Type { get; set; }
+        public override ConfigurationValidatorBase ValidatorInstance { get; }
+    }
+    public sealed class ClientSettingsSection : ConfigurationSection {
+        public ClientSettingsSection();
+        public SettingElementCollection Settings { get; }
+    }
+    public sealed class CommaDelimitedStringCollection : StringCollection {
+        public CommaDelimitedStringCollection();
+        public bool IsModified { get; }
+        public bool IsReadOnly { get; }
+        public string this[int index] { get; set; }
+        public void Add(string value);
+        public void AddRange(string[] range);
+        public void Clear();
+        public CommaDelimitedStringCollection Clone();
+        public void Insert(int index, string value);
+        public void Remove(string value);
+        public void SetReadOnly();
+        public override string ToString();
+    }
+    public sealed class CommaDelimitedStringCollectionConverter : ConfigurationConverterBase {
+        public CommaDelimitedStringCollectionConverter();
+        public override object ConvertFrom(ITypeDescriptorContext ctx, CultureInfo ci, object data);
+        public override object ConvertTo(ITypeDescriptorContext ctx, CultureInfo ci, object value, Type type);
+    }
+    public sealed class Configuration {
+        public AppSettingsSection AppSettings { get; }
+        public Func<string, string> AssemblyStringTransformer { get; set; }
+        public ConnectionStringsSection ConnectionStrings { get; }
+        public ContextInformation EvaluationContext { get; }
+        public string FilePath { get; }
+        public bool HasFile { get; }
+        public ConfigurationLocationCollection Locations { get; }
+        public bool NamespaceDeclared { get; set; }
+        public ConfigurationSectionGroup RootSectionGroup { get; }
+        public ConfigurationSectionGroupCollection SectionGroups { get; }
+        public ConfigurationSectionCollection Sections { get; }
+        public FrameworkName TargetFramework { get; set; }
+        public Func<string, string> TypeStringTransformer { get; set; }
+        public ConfigurationSection GetSection(string sectionName);
+        public ConfigurationSectionGroup GetSectionGroup(string sectionGroupName);
+        public void Save();
+        public void Save(ConfigurationSaveMode saveMode);
+        public void Save(ConfigurationSaveMode saveMode, bool forceSaveAll);
+        public void SaveAs(string filename);
+        public void SaveAs(string filename, ConfigurationSaveMode saveMode);
+        public void SaveAs(string filename, ConfigurationSaveMode saveMode, bool forceSaveAll);
+    }
+    public enum ConfigurationAllowDefinition {
+        Everywhere = 300,
+        MachineOnly = 0,
+        MachineToApplication = 200,
+        MachineToWebRoot = 100,
+    }
+    public enum ConfigurationAllowExeDefinition {
+        MachineOnly = 0,
+        MachineToApplication = 100,
+        MachineToLocalUser = 300,
+        MachineToRoamingUser = 200,
+    }
+    public sealed class ConfigurationCollectionAttribute : Attribute {
+        public ConfigurationCollectionAttribute(Type itemType);
+        public string AddItemName { get; set; }
+        public string ClearItemsName { get; set; }
+        public ConfigurationElementCollectionType CollectionType { get; set; }
+        public Type ItemType { get; }
+        public string RemoveItemName { get; set; }
+    }
+    public abstract class ConfigurationConverterBase : TypeConverter {
+        protected ConfigurationConverterBase();
+        public override bool CanConvertFrom(ITypeDescriptorContext ctx, Type type);
+        public override bool CanConvertTo(ITypeDescriptorContext ctx, Type type);
+    }
+    public abstract class ConfigurationElement {
+        protected ConfigurationElement();
+        public Configuration CurrentConfiguration { get; }
+        public ElementInformation ElementInformation { get; }
+        protected virtual ConfigurationElementProperty ElementProperty { get; }
+        protected ContextInformation EvaluationContext { get; }
+        protected bool HasContext { get; }
+        protected object this[ConfigurationProperty prop] { get; set; }
+        protected object this[string propertyName] { get; set; }
+        public ConfigurationLockCollection LockAllAttributesExcept { get; }
+        public ConfigurationLockCollection LockAllElementsExcept { get; }
+        public ConfigurationLockCollection LockAttributes { get; }
+        public ConfigurationLockCollection LockElements { get; }
+        public bool LockItem { get; set; }
+        protected virtual ConfigurationPropertyCollection Properties { get; }
+        protected virtual void DeserializeElement(XmlReader reader, bool serializeCollectionKey);
+        public override bool Equals(object compareTo);
+        public override int GetHashCode();
+        protected virtual string GetTransformedAssemblyString(string assemblyName);
+        protected virtual string GetTransformedTypeString(string typeName);
+        protected virtual void Init();
+        protected virtual void InitializeDefault();
+        protected virtual bool IsModified();
+        public virtual bool IsReadOnly();
+        protected virtual void ListErrors(IList errorList);
+        protected virtual bool OnDeserializeUnrecognizedAttribute(string name, string value);
+        protected virtual bool OnDeserializeUnrecognizedElement(string elementName, XmlReader reader);
+        protected virtual object OnRequiredPropertyNotFound(string name);
+        protected virtual void PostDeserialize();
+        protected virtual void PreSerialize(XmlWriter writer);
+        protected virtual void Reset(ConfigurationElement parentElement);
+        protected virtual void ResetModified();
+        protected virtual bool SerializeElement(XmlWriter writer, bool serializeCollectionKey);
+        protected virtual bool SerializeToXmlElement(XmlWriter writer, string elementName);
+        protected void SetPropertyValue(ConfigurationProperty prop, object value, bool ignoreLocks);
+        protected virtual void SetReadOnly();
+        protected virtual void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode);
+    }
+    public abstract class ConfigurationElementCollection : ConfigurationElement, ICollection, IEnumerable {
+        protected ConfigurationElementCollection();
+        protected ConfigurationElementCollection(IComparer comparer);
+        protected string AddElementName { get; set; }
+        protected string ClearElementName { get; set; }
+        public virtual ConfigurationElementCollectionType CollectionType { get; }
+        public int Count { get; }
+        protected virtual string ElementName { get; }
+        public bool EmitClear { get; set; }
+        public bool IsSynchronized { get; }
+        protected string RemoveElementName { get; set; }
+        public object SyncRoot { get; }
+        protected virtual bool ThrowOnDuplicate { get; }
+        protected virtual void BaseAdd(ConfigurationElement element);
+        protected void BaseAdd(ConfigurationElement element, bool throwIfExists);
+        protected virtual void BaseAdd(int index, ConfigurationElement element);
+        protected void BaseClear();
+        protected ConfigurationElement BaseGet(int index);
+        protected ConfigurationElement BaseGet(object key);
+        protected object[] BaseGetAllKeys();
+        protected object BaseGetKey(int index);
+        protected int BaseIndexOf(ConfigurationElement element);
+        protected bool BaseIsRemoved(object key);
+        protected void BaseRemove(object key);
+        protected void BaseRemoveAt(int index);
+        public void CopyTo(ConfigurationElement[] array, int index);
+        protected abstract ConfigurationElement CreateNewElement();
+        protected virtual ConfigurationElement CreateNewElement(string elementName);
+        public override bool Equals(object compareTo);
+        protected abstract object GetElementKey(ConfigurationElement element);
+        public IEnumerator GetEnumerator();
+        public override int GetHashCode();
+        protected virtual bool IsElementName(string elementName);
+        protected virtual bool IsElementRemovable(ConfigurationElement element);
+        protected override bool IsModified();
+        public override bool IsReadOnly();
+        protected override bool OnDeserializeUnrecognizedElement(string elementName, XmlReader reader);
+        protected override void Reset(ConfigurationElement parentElement);
+        protected override void ResetModified();
+        protected override bool SerializeElement(XmlWriter writer, bool serializeCollectionKey);
+        protected override void SetReadOnly();
+        void System.Collections.ICollection.CopyTo(Array arr, int index);
+        protected override void Unmerge(ConfigurationElement sourceElement, ConfigurationElement parentElement, ConfigurationSaveMode saveMode);
+    }
+    public enum ConfigurationElementCollectionType {
+        AddRemoveClearMap = 1,
+        AddRemoveClearMapAlternate = 3,
+        BasicMap = 0,
+        BasicMapAlternate = 2,
+    }
+    public sealed class ConfigurationElementProperty {
+        public ConfigurationElementProperty(ConfigurationValidatorBase validator);
+        public ConfigurationValidatorBase Validator { get; }
+    }
+    public class ConfigurationErrorsException : ConfigurationException {
+        public ConfigurationErrorsException();
+        protected ConfigurationErrorsException(SerializationInfo info, StreamingContext context);
+        public ConfigurationErrorsException(string message);
+        public ConfigurationErrorsException(string message, Exception inner);
+        public ConfigurationErrorsException(string message, Exception inner, string filename, int line);
+        public ConfigurationErrorsException(string message, Exception inner, XmlNode node);
+        public ConfigurationErrorsException(string message, Exception inner, XmlReader reader);
+        public ConfigurationErrorsException(string message, string filename, int line);
+        public ConfigurationErrorsException(string message, XmlNode node);
+        public ConfigurationErrorsException(string message, XmlReader reader);
+        public override string BareMessage { get; }
+        public ICollection Errors { get; }
+        public override string Filename { get; }
+        public override int Line { get; }
+        public override string Message { get; }
+        public static string GetFilename(XmlNode node);
+        public static string GetFilename(XmlReader reader);
+        public static int GetLineNumber(XmlNode node);
+        public static int GetLineNumber(XmlReader reader);
+        public override void GetObjectData(SerializationInfo info, StreamingContext context);
+    }
+    public class ConfigurationException : SystemException {
+        public ConfigurationException();
+        protected ConfigurationException(SerializationInfo info, StreamingContext context);
+        public ConfigurationException(string message);
+        public ConfigurationException(string message, Exception inner);
+        public ConfigurationException(string message, Exception inner, string filename, int line);
+        public ConfigurationException(string message, Exception inner, XmlNode node);
+        public ConfigurationException(string message, string filename, int line);
+        public ConfigurationException(string message, XmlNode node);
+        public virtual string BareMessage { get; }
+        public virtual string Filename { get; }
+        public virtual int Line { get; }
+        public override string Message { get; }
+        public override void GetObjectData(SerializationInfo info, StreamingContext context);
+        public static string GetXmlNodeFilename(XmlNode node);
+        public static int GetXmlNodeLineNumber(XmlNode node);
+    }
+    public class ConfigurationFileMap : ICloneable {
+        public ConfigurationFileMap();
+        public ConfigurationFileMap(string machineConfigFilename);
+        public string MachineConfigFilename { get; set; }
+        public virtual object Clone();
+    }
+    public class ConfigurationLocation {
+        public string Path { get; }
+        public Configuration OpenConfiguration();
+    }
+    public class ConfigurationLocationCollection : ReadOnlyCollectionBase {
+        public ConfigurationLocation this[int index] { get; }
+    }
+    public sealed class ConfigurationLockCollection : ICollection, IEnumerable {
+        public string AttributeList { get; }
+        public int Count { get; }
+        public bool HasParentElements { get; }
+        public bool IsModified { get; }
+        public bool IsSynchronized { get; }
+        public object SyncRoot { get; }
+        public void Add(string name);
+        public void Clear();
+        public bool Contains(string name);
+        public void CopyTo(string[] array, int index);
+        public IEnumerator GetEnumerator();
+        public bool IsReadOnly(string name);
+        public void Remove(string name);
+        public void SetFromList(string attributeList);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+    }
+    public static class ConfigurationManager {
+        public static NameValueCollection AppSettings { get; }
+        public static ConnectionStringSettingsCollection ConnectionStrings { get; }
+        public static object GetSection(string sectionName);
+        public static Configuration OpenExeConfiguration(ConfigurationUserLevel userLevel);
+        public static Configuration OpenExeConfiguration(string exePath);
+        public static Configuration OpenMachineConfiguration();
+        public static Configuration OpenMappedExeConfiguration(ExeConfigurationFileMap fileMap, ConfigurationUserLevel userLevel);
+        public static Configuration OpenMappedExeConfiguration(ExeConfigurationFileMap fileMap, ConfigurationUserLevel userLevel, bool preLoad);
+        public static Configuration OpenMappedMachineConfiguration(ConfigurationFileMap fileMap);
+        public static void RefreshSection(string sectionName);
+    }
+    public sealed class ConfigurationProperty {
+        public ConfigurationProperty(string name, Type type);
+        public ConfigurationProperty(string name, Type type, object defaultValue);
+        public ConfigurationProperty(string name, Type type, object defaultValue, ConfigurationPropertyOptions options);
+        public ConfigurationProperty(string name, Type type, object defaultValue, TypeConverter typeConverter, ConfigurationValidatorBase validator, ConfigurationPropertyOptions options);
+        public ConfigurationProperty(string name, Type type, object defaultValue, TypeConverter typeConverter, ConfigurationValidatorBase validator, ConfigurationPropertyOptions options, string description);
+        public TypeConverter Converter { get; }
+        public object DefaultValue { get; }
+        public string Description { get; }
+        public bool IsAssemblyStringTransformationRequired { get; }
+        public bool IsDefaultCollection { get; }
+        public bool IsKey { get; }
+        public bool IsRequired { get; }
+        public bool IsTypeStringTransformationRequired { get; }
+        public bool IsVersionCheckRequired { get; }
+        public string Name { get; }
+        public Type Type { get; }
+        public ConfigurationValidatorBase Validator { get; }
+    }
+    public sealed class ConfigurationPropertyAttribute : Attribute {
+        public ConfigurationPropertyAttribute(string name);
+        public object DefaultValue { get; set; }
+        public bool IsDefaultCollection { get; set; }
+        public bool IsKey { get; set; }
+        public bool IsRequired { get; set; }
+        public string Name { get; }
+        public ConfigurationPropertyOptions Options { get; set; }
+    }
+    public class ConfigurationPropertyCollection : ICollection, IEnumerable {
+        public ConfigurationPropertyCollection();
+        public int Count { get; }
+        public bool IsSynchronized { get; }
+        public ConfigurationProperty this[string name] { get; }
+        public object SyncRoot { get; }
+        public void Add(ConfigurationProperty property);
+        public void Clear();
+        public bool Contains(string name);
+        public void CopyTo(ConfigurationProperty[] array, int index);
+        public IEnumerator GetEnumerator();
+        public bool Remove(string name);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+    }
+    public enum ConfigurationPropertyOptions {
+        IsAssemblyStringTransformationRequired = 16,
+        IsDefaultCollection = 1,
+        IsKey = 4,
+        IsRequired = 2,
+        IsTypeStringTransformationRequired = 8,
+        IsVersionCheckRequired = 32,
+        None = 0,
+    }
+    public enum ConfigurationSaveMode {
+        Full = 2,
+        Minimal = 1,
+        Modified = 0,
+    }
+    public abstract class ConfigurationSection : ConfigurationElement {
+        protected ConfigurationSection();
+        public SectionInformation SectionInformation { get; }
+        protected virtual void DeserializeSection(XmlReader reader);
+        protected virtual object GetRuntimeObject();
+        protected override bool IsModified();
+        protected override void ResetModified();
+        protected virtual string SerializeSection(ConfigurationElement parentElement, string name, ConfigurationSaveMode saveMode);
+        protected virtual bool ShouldSerializeElementInTargetVersion(ConfigurationElement element, string elementName, FrameworkName targetFramework);
+        protected virtual bool ShouldSerializePropertyInTargetVersion(ConfigurationProperty property, string propertyName, FrameworkName targetFramework, ConfigurationElement parentConfigurationElement);
+        protected virtual bool ShouldSerializeSectionInTargetVersion(FrameworkName targetFramework);
+    }
+    public sealed class ConfigurationSectionCollection : NameObjectCollectionBase {
+        public override int Count { get; }
+        public ConfigurationSection this[int index] { get; }
+        public ConfigurationSection this[string name] { get; }
+        public override NameObjectCollectionBase.KeysCollection Keys { get; }
+        public void Add(string name, ConfigurationSection section);
+        public void Clear();
+        public void CopyTo(ConfigurationSection[] array, int index);
+        public ConfigurationSection Get(int index);
+        public ConfigurationSection Get(string name);
+        public override IEnumerator GetEnumerator();
+        public string GetKey(int index);
+        public override void GetObjectData(SerializationInfo info, StreamingContext context);
+        public void Remove(string name);
+        public void RemoveAt(int index);
+    }
+    public class ConfigurationSectionGroup {
+        public ConfigurationSectionGroup();
+        public bool IsDeclarationRequired { get; }
+        public bool IsDeclared { get; }
+        public string Name { get; }
+        public string SectionGroupName { get; }
+        public ConfigurationSectionGroupCollection SectionGroups { get; }
+        public ConfigurationSectionCollection Sections { get; }
+        public string Type { get; set; }
+        public void ForceDeclaration();
+        public void ForceDeclaration(bool force);
+        protected virtual bool ShouldSerializeSectionGroupInTargetVersion(FrameworkName targetFramework);
+    }
+    public sealed class ConfigurationSectionGroupCollection : NameObjectCollectionBase {
+        public override int Count { get; }
+        public ConfigurationSectionGroup this[int index] { get; }
+        public ConfigurationSectionGroup this[string name] { get; }
+        public override NameObjectCollectionBase.KeysCollection Keys { get; }
+        public void Add(string name, ConfigurationSectionGroup sectionGroup);
+        public void Clear();
+        public void CopyTo(ConfigurationSectionGroup[] array, int index);
+        public ConfigurationSectionGroup Get(int index);
+        public ConfigurationSectionGroup Get(string name);
+        public override IEnumerator GetEnumerator();
+        public string GetKey(int index);
+        public override void GetObjectData(SerializationInfo info, StreamingContext context);
+        public void Remove(string name);
+        public void RemoveAt(int index);
+    }
+    public sealed class ConfigurationSettings {
+        public static NameValueCollection AppSettings { get; }
+        public static object GetConfig(string sectionName);
+    }
+    public enum ConfigurationUserLevel {
+        None = 0,
+        PerUserRoaming = 10,
+        PerUserRoamingAndLocal = 20,
+    }
+    public class ConfigurationValidatorAttribute : Attribute {
+        protected ConfigurationValidatorAttribute();
+        public ConfigurationValidatorAttribute(Type validator);
+        public virtual ConfigurationValidatorBase ValidatorInstance { get; }
+        public Type ValidatorType { get; }
+    }
+    public abstract class ConfigurationValidatorBase {
+        protected ConfigurationValidatorBase();
+        public virtual bool CanValidate(Type type);
+        public abstract void Validate(object value);
+    }
+    public sealed class ConfigXmlDocument : XmlDocument, IConfigErrorInfo {
+        public ConfigXmlDocument();
+        public string Filename { get; }
+        public int LineNumber { get; }
+        string System.Configuration.Internal.IConfigErrorInfo.Filename { get; }
+        int System.Configuration.Internal.IConfigErrorInfo.LineNumber { get; }
+        public override XmlAttribute CreateAttribute(string prefix, string localName, string namespaceUri);
+        public override XmlCDataSection CreateCDataSection(string data);
+        public override XmlComment CreateComment(string data);
+        public override XmlElement CreateElement(string prefix, string localName, string namespaceUri);
+        public override XmlSignificantWhitespace CreateSignificantWhitespace(string data);
+        public override XmlText CreateTextNode(string text);
+        public override XmlWhitespace CreateWhitespace(string data);
+        public override void Load(string filename);
+        public void LoadSingleElement(string filename, XmlTextReader sourceReader);
+    }
+    public sealed class ConnectionStringSettings : ConfigurationElement {
+        public ConnectionStringSettings();
+        public ConnectionStringSettings(string name, string connectionString);
+        public ConnectionStringSettings(string name, string connectionString, string providerName);
+        public string ConnectionString { get; set; }
+        public string Name { get; set; }
+        public string ProviderName { get; set; }
+        public override string ToString();
+    }
+    public sealed class ConnectionStringSettingsCollection : ConfigurationElementCollection {
+        public ConnectionStringSettingsCollection();
+        public ConnectionStringSettings this[int index] { get; set; }
+        public new ConnectionStringSettings this[string name] { get; }
+        public void Add(ConnectionStringSettings settings);
+        public void Clear();
+        public int IndexOf(ConnectionStringSettings settings);
+        public void Remove(ConnectionStringSettings settings);
+        public void Remove(string name);
+        public void RemoveAt(int index);
+    }
+    public sealed class ConnectionStringsSection : ConfigurationSection {
+        public ConnectionStringsSection();
+        public ConnectionStringSettingsCollection ConnectionStrings { get; }
+    }
+    public sealed class ContextInformation {
+        public object HostingContext { get; }
+        public bool IsMachineLevel { get; }
+        public object GetSection(string sectionName);
+    }
+    public sealed class DefaultSection : ConfigurationSection {
+        public DefaultSection();
+    }
+    public sealed class DefaultSettingValueAttribute : Attribute {
+        public DefaultSettingValueAttribute(string value);
+        public string Value { get; }
+    }
+    public sealed class DefaultValidator : ConfigurationValidatorBase {
+        public DefaultValidator();
+        public override bool CanValidate(Type type);
+        public override void Validate(object value);
+    }
+    public class DictionarySectionHandler : IConfigurationSectionHandler {
+        public DictionarySectionHandler();
+        protected virtual string KeyAttributeName { get; }
+        protected virtual string ValueAttributeName { get; }
+        public virtual object Create(object parent, object context, XmlNode section);
+    }
+    public sealed class DpapiProtectedConfigurationProvider : ProtectedConfigurationProvider {
+        public DpapiProtectedConfigurationProvider();
+        public bool UseMachineProtection { get; }
+        public override XmlNode Decrypt(XmlNode encryptedNode);
+        public override XmlNode Encrypt(XmlNode node);
+        public override void Initialize(string name, NameValueCollection configurationValues);
+    }
+    public sealed class ElementInformation {
+        public ICollection Errors { get; }
+        public bool IsCollection { get; }
+        public bool IsLocked { get; }
+        public bool IsPresent { get; }
+        public int LineNumber { get; }
+        public PropertyInformationCollection Properties { get; }
+        public string Source { get; }
+        public Type Type { get; }
+        public ConfigurationValidatorBase Validator { get; }
+    }
+    public sealed class ExeConfigurationFileMap : ConfigurationFileMap {
+        public ExeConfigurationFileMap();
+        public ExeConfigurationFileMap(string machineConfigFileName);
+        public string ExeConfigFilename { get; set; }
+        public string LocalUserConfigFilename { get; set; }
+        public string RoamingUserConfigFilename { get; set; }
+        public override object Clone();
+    }
+    public sealed class ExeContext {
+        public string ExePath { get; }
+        public ConfigurationUserLevel UserLevel { get; }
+    }
+    public sealed class GenericEnumConverter : ConfigurationConverterBase {
+        public GenericEnumConverter(Type typeEnum);
+        public override object ConvertFrom(ITypeDescriptorContext ctx, CultureInfo ci, object data);
+        public override object ConvertTo(ITypeDescriptorContext ctx, CultureInfo ci, object value, Type type);
+    }
+    public interface IApplicationSettingsProvider {
+        SettingsPropertyValue GetPreviousVersion(SettingsContext context, SettingsProperty property);
+        void Reset(SettingsContext context);
+        void Upgrade(SettingsContext context, SettingsPropertyCollection properties);
+    }
+    public interface IConfigurationSectionHandler {
+        object Create(object parent, object configContext, XmlNode section);
+    }
+    public interface IConfigurationSystem {
+        object GetConfig(string configKey);
+        void Init();
+    }
+    public sealed class IdnElement : ConfigurationElement {
+        public IdnElement();
+        public UriIdnScope Enabled { get; set; }
+    }
+    public sealed class IgnoreSection : ConfigurationSection {
+        public IgnoreSection();
+    }
+    public class IgnoreSectionHandler : IConfigurationSectionHandler {
+        public IgnoreSectionHandler();
+        public virtual object Create(object parent, object configContext, XmlNode section);
+    }
+    public sealed class InfiniteIntConverter : ConfigurationConverterBase {
+        public InfiniteIntConverter();
+        public override object ConvertFrom(ITypeDescriptorContext ctx, CultureInfo ci, object data);
+        public override object ConvertTo(ITypeDescriptorContext ctx, CultureInfo ci, object value, Type type);
+    }
+    public sealed class InfiniteTimeSpanConverter : ConfigurationConverterBase {
+        public InfiniteTimeSpanConverter();
+        public override object ConvertFrom(ITypeDescriptorContext ctx, CultureInfo ci, object data);
+        public override object ConvertTo(ITypeDescriptorContext ctx, CultureInfo ci, object value, Type type);
+    }
+    public class IntegerValidator : ConfigurationValidatorBase {
+        public IntegerValidator(int minValue, int maxValue);
+        public IntegerValidator(int minValue, int maxValue, bool rangeIsExclusive);
+        public IntegerValidator(int minValue, int maxValue, bool rangeIsExclusive, int resolution);
+        public override bool CanValidate(Type type);
+        public override void Validate(object value);
+    }
+    public sealed class IntegerValidatorAttribute : ConfigurationValidatorAttribute {
+        public IntegerValidatorAttribute();
+        public bool ExcludeRange { get; set; }
+        public int MaxValue { get; set; }
+        public int MinValue { get; set; }
+        public override ConfigurationValidatorBase ValidatorInstance { get; }
+    }
+    public interface IPersistComponentSettings {
+        bool SaveSettings { get; set; }
+        string SettingsKey { get; set; }
+        void LoadComponentSettings();
+        void ResetComponentSettings();
+        void SaveComponentSettings();
+    }
+    public sealed class IriParsingElement : ConfigurationElement {
+        public IriParsingElement();
+        public bool Enabled { get; set; }
+    }
+    public interface ISettingsProviderService {
+        SettingsProvider GetSettingsProvider(SettingsProperty property);
+    }
+    public class KeyValueConfigurationCollection : ConfigurationElementCollection {
+        public KeyValueConfigurationCollection();
+        public string[] AllKeys { get; }
+        public new KeyValueConfigurationElement this[string key] { get; }
+        protected override ConfigurationPropertyCollection Properties { get; }
+        protected override bool ThrowOnDuplicate { get; }
+        public void Add(KeyValueConfigurationElement keyValue);
+        public void Add(string key, string value);
+        public void Clear();
+        protected override ConfigurationElement CreateNewElement();
+        protected override object GetElementKey(ConfigurationElement element);
+        public void Remove(string key);
+    }
+    public class KeyValueConfigurationElement : ConfigurationElement {
+        public KeyValueConfigurationElement(string key, string value);
+        public string Key { get; }
+        protected override ConfigurationPropertyCollection Properties { get; }
+        public string Value { get; set; }
+        protected override void Init();
+    }
+    public class LocalFileSettingsProvider : SettingsProvider, IApplicationSettingsProvider {
+        public LocalFileSettingsProvider();
+        public override string ApplicationName { get; set; }
+        public SettingsPropertyValue GetPreviousVersion(SettingsContext context, SettingsProperty property);
+        public override SettingsPropertyValueCollection GetPropertyValues(SettingsContext context, SettingsPropertyCollection properties);
+        public override void Initialize(string name, NameValueCollection values);
+        public void Reset(SettingsContext context);
+        public override void SetPropertyValues(SettingsContext context, SettingsPropertyValueCollection values);
+        public void Upgrade(SettingsContext context, SettingsPropertyCollection properties);
+    }
+    public class LongValidator : ConfigurationValidatorBase {
+        public LongValidator(long minValue, long maxValue);
+        public LongValidator(long minValue, long maxValue, bool rangeIsExclusive);
+        public LongValidator(long minValue, long maxValue, bool rangeIsExclusive, long resolution);
+        public override bool CanValidate(Type type);
+        public override void Validate(object value);
+    }
+    public sealed class LongValidatorAttribute : ConfigurationValidatorAttribute {
+        public LongValidatorAttribute();
+        public bool ExcludeRange { get; set; }
+        public long MaxValue { get; set; }
+        public long MinValue { get; set; }
+        public override ConfigurationValidatorBase ValidatorInstance { get; }
+    }
+    public sealed class NameValueConfigurationCollection : ConfigurationElementCollection {
+        public NameValueConfigurationCollection();
+        public string[] AllKeys { get; }
+        public new NameValueConfigurationElement this[string name] { get; set; }
+        public void Add(NameValueConfigurationElement nameValue);
+        public void Clear();
+        public void Remove(NameValueConfigurationElement nameValue);
+        public void Remove(string name);
+    }
+    public sealed class NameValueConfigurationElement : ConfigurationElement {
+        public NameValueConfigurationElement(string name, string value);
+        public string Name { get; }
+        public string Value { get; set; }
+    }
+    public class NameValueFileSectionHandler : IConfigurationSectionHandler {
+        public NameValueFileSectionHandler();
+        public object Create(object parent, object configContext, XmlNode section);
+    }
+    public class NameValueSectionHandler : IConfigurationSectionHandler {
+        public NameValueSectionHandler();
+        protected virtual string KeyAttributeName { get; }
+        protected virtual string ValueAttributeName { get; }
+        public object Create(object parent, object context, XmlNode section);
+    }
+    public sealed class NoSettingsVersionUpgradeAttribute : Attribute {
+        public NoSettingsVersionUpgradeAttribute();
+    }
+    public enum OverrideMode {
+        Allow = 1,
+        Deny = 2,
+        Inherit = 0,
+    }
+    public class PositiveTimeSpanValidator : ConfigurationValidatorBase {
+        public PositiveTimeSpanValidator();
+        public override bool CanValidate(Type type);
+        public override void Validate(object value);
+    }
+    public sealed class PositiveTimeSpanValidatorAttribute : ConfigurationValidatorAttribute {
+        public PositiveTimeSpanValidatorAttribute();
+        public override ConfigurationValidatorBase ValidatorInstance { get; }
+    }
+    public sealed class PropertyInformation {
+        public TypeConverter Converter { get; }
+        public object DefaultValue { get; }
+        public string Description { get; }
+        public bool IsKey { get; }
+        public bool IsLocked { get; }
+        public bool IsModified { get; }
+        public bool IsRequired { get; }
+        public int LineNumber { get; }
+        public string Name { get; }
+        public string Source { get; }
+        public Type Type { get; }
+        public ConfigurationValidatorBase Validator { get; }
+        public object Value { get; set; }
+        public PropertyValueOrigin ValueOrigin { get; }
+    }
+    public sealed class PropertyInformationCollection : NameObjectCollectionBase {
+        public PropertyInformation this[string propertyName] { get; }
+        public void CopyTo(PropertyInformation[] array, int index);
+        public override IEnumerator GetEnumerator();
+        public override void GetObjectData(SerializationInfo info, StreamingContext context);
+    }
+    public enum PropertyValueOrigin {
+        Default = 0,
+        Inherited = 1,
+        SetHere = 2,
+    }
+    public static class ProtectedConfiguration {
+        public const string DataProtectionProviderName = "DataProtectionConfigurationProvider";
+        public const string ProtectedDataSectionName = "configProtectedData";
+        public const string RsaProviderName = "RsaProtectedConfigurationProvider";
+        public static string DefaultProvider { get; }
+        public static ProtectedConfigurationProviderCollection Providers { get; }
+    }
+    public abstract class ProtectedConfigurationProvider : ProviderBase {
+        protected ProtectedConfigurationProvider();
+        public abstract XmlNode Decrypt(XmlNode encryptedNode);
+        public abstract XmlNode Encrypt(XmlNode node);
+    }
+    public class ProtectedConfigurationProviderCollection : ProviderCollection {
+        public ProtectedConfigurationProviderCollection();
+        public new ProtectedConfigurationProvider this[string name] { get; }
+        public override void Add(ProviderBase provider);
+    }
+    public sealed class ProtectedConfigurationSection : ConfigurationSection {
+        public ProtectedConfigurationSection();
+        public string DefaultProvider { get; set; }
+        public ProviderSettingsCollection Providers { get; }
+    }
+    public class ProtectedProviderSettings : ConfigurationElement {
+        public ProtectedProviderSettings();
+        protected override ConfigurationPropertyCollection Properties { get; }
+        public ProviderSettingsCollection Providers { get; }
+    }
+    public sealed class ProviderSettings : ConfigurationElement {
+        public ProviderSettings();
+        public ProviderSettings(string name, string type);
+        public string Name { get; set; }
+        public NameValueCollection Parameters { get; }
+        public string Type { get; set; }
+    }
+    public sealed class ProviderSettingsCollection : ConfigurationElementCollection {
+        public ProviderSettingsCollection();
+        public ProviderSettings this[int index] { get; set; }
+        public new ProviderSettings this[string key] { get; }
+        public void Add(ProviderSettings provider);
+        public void Clear();
+        public void Remove(string name);
+    }
+    public class RegexStringValidator : ConfigurationValidatorBase {
+        public RegexStringValidator(string regex);
+        public override bool CanValidate(Type type);
+        public override void Validate(object value);
+    }
+    public sealed class RegexStringValidatorAttribute : ConfigurationValidatorAttribute {
+        public RegexStringValidatorAttribute(string regex);
+        public string Regex { get; }
+        public override ConfigurationValidatorBase ValidatorInstance { get; }
+    }
+    public sealed class RsaProtectedConfigurationProvider : ProtectedConfigurationProvider {
+        public RsaProtectedConfigurationProvider();
+        public string CspProviderName { get; }
+        public string KeyContainerName { get; }
+        public RSAParameters RsaPublicKey { get; }
+        public bool UseFIPS { get; }
+        public bool UseMachineContainer { get; }
+        public bool UseOAEP { get; }
+        public void AddKey(int keySize, bool exportable);
+        public override XmlNode Decrypt(XmlNode encryptedNode);
+        public void DeleteKey();
+        public override XmlNode Encrypt(XmlNode node);
+        public void ExportKey(string xmlFileName, bool includePrivateParameters);
+        public void ImportKey(string xmlFileName, bool exportable);
+        public override void Initialize(string name, NameValueCollection configurationValues);
+    }
+    public sealed class SchemeSettingElement : ConfigurationElement {
+        public SchemeSettingElement();
+        public GenericUriParserOptions GenericUriParserOptions { get; }
+        public string Name { get; }
+    }
+    public sealed class SchemeSettingElementCollection : ConfigurationElementCollection {
+        public SchemeSettingElementCollection();
+        public override ConfigurationElementCollectionType CollectionType { get; }
+        public SchemeSettingElement this[int index] { get; }
+        public new SchemeSettingElement this[string name] { get; }
+        public int IndexOf(SchemeSettingElement element);
+    }
+    public sealed class SectionInformation {
+        public ConfigurationAllowDefinition AllowDefinition { get; set; }
+        public ConfigurationAllowExeDefinition AllowExeDefinition { get; set; }
+        public bool AllowLocation { get; set; }
+        public bool AllowOverride { get; set; }
+        public string ConfigSource { get; set; }
+        public bool ForceSave { get; set; }
+        public bool InheritInChildApplications { get; set; }
+        public bool IsDeclarationRequired { get; }
+        public bool IsDeclared { get; }
+        public bool IsLocked { get; }
+        public bool IsProtected { get; }
+        public string Name { get; }
+        public OverrideMode OverrideMode { get; set; }
+        public OverrideMode OverrideModeDefault { get; set; }
+        public OverrideMode OverrideModeEffective { get; }
+        public ProtectedConfigurationProvider ProtectionProvider { get; }
+        public bool RequirePermission { get; set; }
+        public bool RestartOnExternalChanges { get; set; }
+        public string SectionName { get; }
+        public string Type { get; set; }
+        public void ForceDeclaration();
+        public void ForceDeclaration(bool force);
+        public ConfigurationSection GetParentSection();
+        public string GetRawXml();
+        public void ProtectSection(string protectionProvider);
+        public void RevertToParent();
+        public void SetRawXml(string rawXml);
+        public void UnprotectSection();
+    }
+    public class SettingAttribute : Attribute {
+        public SettingAttribute();
+    }
+    public class SettingChangingEventArgs : CancelEventArgs {
+        public SettingChangingEventArgs(string settingName, string settingClass, string settingKey, object newValue, bool cancel);
+        public object NewValue { get; }
+        public string SettingClass { get; }
+        public string SettingKey { get; }
+        public string SettingName { get; }
+    }
+    public delegate void SettingChangingEventHandler(object sender, SettingChangingEventArgs e); {
+        public SettingChangingEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, SettingChangingEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, SettingChangingEventArgs e);
+    }
+    public sealed class SettingElement : ConfigurationElement {
+        public SettingElement();
+        public SettingElement(string name, SettingsSerializeAs serializeAs);
+        public string Name { get; set; }
+        public SettingsSerializeAs SerializeAs { get; set; }
+        public SettingValueElement Value { get; set; }
+        public override bool Equals(object settings);
+        public override int GetHashCode();
+    }
+    public sealed class SettingElementCollection : ConfigurationElementCollection {
+        public SettingElementCollection();
+        public override ConfigurationElementCollectionType CollectionType { get; }
+        public void Add(SettingElement element);
+        public void Clear();
+        public SettingElement Get(string elementKey);
+        public void Remove(SettingElement element);
+    }
+    public class SettingsAttributeDictionary : Hashtable {
+        public SettingsAttributeDictionary();
+        public SettingsAttributeDictionary(SettingsAttributeDictionary attributes);
+    }
+    public abstract class SettingsBase {
+        protected SettingsBase();
+        public virtual SettingsContext Context { get; }
+        public bool IsSynchronized { get; }
+        public virtual object this[string propertyName] { get; set; }
+        public virtual SettingsPropertyCollection Properties { get; }
+        public virtual SettingsPropertyValueCollection PropertyValues { get; }
+        public virtual SettingsProviderCollection Providers { get; }
+        public void Initialize(SettingsContext context, SettingsPropertyCollection properties, SettingsProviderCollection providers);
+        public virtual void Save();
+        public static SettingsBase Synchronized(SettingsBase settingsBase);
+    }
+    public class SettingsContext : Hashtable {
+        public SettingsContext();
+    }
+    public sealed class SettingsDescriptionAttribute : Attribute {
+        public SettingsDescriptionAttribute(string description);
+        public string Description { get; }
+    }
+    public sealed class SettingsGroupDescriptionAttribute : Attribute {
+        public SettingsGroupDescriptionAttribute(string description);
+        public string Description { get; }
+    }
+    public sealed class SettingsGroupNameAttribute : Attribute {
+        public SettingsGroupNameAttribute(string groupName);
+        public string GroupName { get; }
+    }
+    public class SettingsLoadedEventArgs : EventArgs {
+        public SettingsLoadedEventArgs(SettingsProvider provider);
+        public SettingsProvider Provider { get; }
+    }
+    public delegate void SettingsLoadedEventHandler(object sender, SettingsLoadedEventArgs e); {
+        public SettingsLoadedEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, SettingsLoadedEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, SettingsLoadedEventArgs e);
+    }
+    public enum SettingsManageability {
+        Roaming = 0,
+    }
+    public sealed class SettingsManageabilityAttribute : Attribute {
+        public SettingsManageabilityAttribute(SettingsManageability manageability);
+        public SettingsManageability Manageability { get; }
+    }
+    public class SettingsProperty {
+        public SettingsProperty(SettingsProperty propertyToCopy);
+        public SettingsProperty(string name);
+        public SettingsProperty(string name, Type propertyType, SettingsProvider provider, bool isReadOnly, object defaultValue, SettingsSerializeAs serializeAs, SettingsAttributeDictionary attributes, bool throwOnErrorDeserializing, bool throwOnErrorSerializing);
+        public virtual SettingsAttributeDictionary Attributes { get; }
+        public virtual object DefaultValue { get; set; }
+        public virtual bool IsReadOnly { get; set; }
+        public virtual string Name { get; set; }
+        public virtual Type PropertyType { get; set; }
+        public virtual SettingsProvider Provider { get; set; }
+        public virtual SettingsSerializeAs SerializeAs { get; set; }
+        public bool ThrowOnErrorDeserializing { get; set; }
+        public bool ThrowOnErrorSerializing { get; set; }
+    }
+    public class SettingsPropertyCollection : ICloneable, ICollection, IEnumerable {
+        public SettingsPropertyCollection();
+        public int Count { get; }
+        public bool IsSynchronized { get; }
+        public SettingsProperty this[string name] { get; }
+        public object SyncRoot { get; }
+        public void Add(SettingsProperty property);
+        public void Clear();
+        public object Clone();
+        public void CopyTo(Array array, int index);
+        public IEnumerator GetEnumerator();
+        protected virtual void OnAdd(SettingsProperty property);
+        protected virtual void OnAddComplete(SettingsProperty property);
+        protected virtual void OnClear();
+        protected virtual void OnClearComplete();
+        protected virtual void OnRemove(SettingsProperty property);
+        protected virtual void OnRemoveComplete(SettingsProperty property);
+        public void Remove(string name);
+        public void SetReadOnly();
+    }
+    public class SettingsPropertyIsReadOnlyException : Exception {
+        public SettingsPropertyIsReadOnlyException();
+        protected SettingsPropertyIsReadOnlyException(SerializationInfo info, StreamingContext context);
+        public SettingsPropertyIsReadOnlyException(string message);
+        public SettingsPropertyIsReadOnlyException(string message, Exception innerException);
+    }
+    public class SettingsPropertyNotFoundException : Exception {
+        public SettingsPropertyNotFoundException();
+        protected SettingsPropertyNotFoundException(SerializationInfo info, StreamingContext context);
+        public SettingsPropertyNotFoundException(string message);
+        public SettingsPropertyNotFoundException(string message, Exception innerException);
+    }
+    public class SettingsPropertyValue {
+        public SettingsPropertyValue(SettingsProperty property);
+        public bool Deserialized { get; set; }
+        public bool IsDirty { get; set; }
+        public string Name { get; }
+        public SettingsProperty Property { get; }
+        public object PropertyValue { get; set; }
+        public object SerializedValue { get; set; }
+        public bool UsingDefaultValue { get; }
+    }
+    public class SettingsPropertyValueCollection : ICloneable, ICollection, IEnumerable {
+        public SettingsPropertyValueCollection();
+        public int Count { get; }
+        public bool IsSynchronized { get; }
+        public SettingsPropertyValue this[string name] { get; }
+        public object SyncRoot { get; }
+        public void Add(SettingsPropertyValue property);
+        public void Clear();
+        public object Clone();
+        public void CopyTo(Array array, int index);
+        public IEnumerator GetEnumerator();
+        public void Remove(string name);
+        public void SetReadOnly();
+    }
+    public class SettingsPropertyWrongTypeException : Exception {
+        public SettingsPropertyWrongTypeException();
+        protected SettingsPropertyWrongTypeException(SerializationInfo info, StreamingContext context);
+        public SettingsPropertyWrongTypeException(string message);
+        public SettingsPropertyWrongTypeException(string message, Exception innerException);
+    }
+    public abstract class SettingsProvider : ProviderBase {
+        protected SettingsProvider();
+        public abstract string ApplicationName { get; set; }
+        public abstract SettingsPropertyValueCollection GetPropertyValues(SettingsContext context, SettingsPropertyCollection collection);
+        public abstract void SetPropertyValues(SettingsContext context, SettingsPropertyValueCollection collection);
+    }
+    public sealed class SettingsProviderAttribute : Attribute {
+        public SettingsProviderAttribute(string providerTypeName);
+        public SettingsProviderAttribute(Type providerType);
+        public string ProviderTypeName { get; }
+    }
+    public class SettingsProviderCollection : ProviderCollection {
+        public SettingsProviderCollection();
+        public new SettingsProvider this[string name] { get; }
+        public override void Add(ProviderBase provider);
+    }
+    public delegate void SettingsSavingEventHandler(object sender, CancelEventArgs e); {
+        public SettingsSavingEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, CancelEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, CancelEventArgs e);
+    }
+    public enum SettingsSerializeAs {
+        Binary = 2,
+        ProviderSpecific = 3,
+        String = 0,
+        Xml = 1,
+    }
+    public sealed class SettingsSerializeAsAttribute : Attribute {
+        public SettingsSerializeAsAttribute(SettingsSerializeAs serializeAs);
+        public SettingsSerializeAs SerializeAs { get; }
+    }
+    public sealed class SettingValueElement : ConfigurationElement {
+        public SettingValueElement();
+        public XmlNode ValueXml { get; set; }
+        public override bool Equals(object settingValue);
+        public override int GetHashCode();
+    }
+    public class SingleTagSectionHandler : IConfigurationSectionHandler {
+        public SingleTagSectionHandler();
+        public virtual object Create(object parent, object context, XmlNode section);
+    }
+    public enum SpecialSetting {
+        ConnectionString = 0,
+        WebServiceUrl = 1,
+    }
+    public sealed class SpecialSettingAttribute : Attribute {
+        public SpecialSettingAttribute(SpecialSetting specialSetting);
+        public SpecialSetting SpecialSetting { get; }
+    }
+    public class StringValidator : ConfigurationValidatorBase {
+        public StringValidator(int minLength);
+        public StringValidator(int minLength, int maxLength);
+        public StringValidator(int minLength, int maxLength, string invalidCharacters);
+        public override bool CanValidate(Type type);
+        public override void Validate(object value);
+    }
+    public sealed class StringValidatorAttribute : ConfigurationValidatorAttribute {
+        public StringValidatorAttribute();
+        public string InvalidCharacters { get; set; }
+        public int MaxLength { get; set; }
+        public int MinLength { get; set; }
+        public override ConfigurationValidatorBase ValidatorInstance { get; }
+    }
+    public sealed class SubclassTypeValidator : ConfigurationValidatorBase {
+        public SubclassTypeValidator(Type baseClass);
+        public override bool CanValidate(Type type);
+        public override void Validate(object value);
+    }
+    public sealed class SubclassTypeValidatorAttribute : ConfigurationValidatorAttribute {
+        public SubclassTypeValidatorAttribute(Type baseClass);
+        public Type BaseClass { get; }
+        public override ConfigurationValidatorBase ValidatorInstance { get; }
+    }
+    public class TimeSpanMinutesConverter : ConfigurationConverterBase {
+        public TimeSpanMinutesConverter();
+        public override object ConvertFrom(ITypeDescriptorContext ctx, CultureInfo ci, object data);
+        public override object ConvertTo(ITypeDescriptorContext ctx, CultureInfo ci, object value, Type type);
+    }
+    public sealed class TimeSpanMinutesOrInfiniteConverter : TimeSpanMinutesConverter {
+        public TimeSpanMinutesOrInfiniteConverter();
+        public override object ConvertFrom(ITypeDescriptorContext ctx, CultureInfo ci, object data);
+        public override object ConvertTo(ITypeDescriptorContext ctx, CultureInfo ci, object value, Type type);
+    }
+    public class TimeSpanSecondsConverter : ConfigurationConverterBase {
+        public TimeSpanSecondsConverter();
+        public override object ConvertFrom(ITypeDescriptorContext ctx, CultureInfo ci, object data);
+        public override object ConvertTo(ITypeDescriptorContext ctx, CultureInfo ci, object value, Type type);
+    }
+    public sealed class TimeSpanSecondsOrInfiniteConverter : TimeSpanSecondsConverter {
+        public TimeSpanSecondsOrInfiniteConverter();
+        public override object ConvertFrom(ITypeDescriptorContext ctx, CultureInfo ci, object data);
+        public override object ConvertTo(ITypeDescriptorContext ctx, CultureInfo ci, object value, Type type);
+    }
+    public class TimeSpanValidator : ConfigurationValidatorBase {
+        public TimeSpanValidator(TimeSpan minValue, TimeSpan maxValue);
+        public TimeSpanValidator(TimeSpan minValue, TimeSpan maxValue, bool rangeIsExclusive);
+        public TimeSpanValidator(TimeSpan minValue, TimeSpan maxValue, bool rangeIsExclusive, long resolutionInSeconds);
+        public override bool CanValidate(Type type);
+        public override void Validate(object value);
+    }
+    public sealed class TimeSpanValidatorAttribute : ConfigurationValidatorAttribute {
+        public const string TimeSpanMaxValue = "10675199.02:48:05.4775807";
+        public const string TimeSpanMinValue = "-10675199.02:48:05.4775808";
+        public TimeSpanValidatorAttribute();
+        public bool ExcludeRange { get; set; }
+        public TimeSpan MaxValue { get; }
+        public string MaxValueString { get; set; }
+        public TimeSpan MinValue { get; }
+        public string MinValueString { get; set; }
+        public override ConfigurationValidatorBase ValidatorInstance { get; }
+    }
+    public sealed class TypeNameConverter : ConfigurationConverterBase {
+        public TypeNameConverter();
+        public override object ConvertFrom(ITypeDescriptorContext ctx, CultureInfo ci, object data);
+        public override object ConvertTo(ITypeDescriptorContext ctx, CultureInfo ci, object value, Type type);
+    }
+    public sealed class UriSection : ConfigurationSection {
+        public UriSection();
+        public IdnElement Idn { get; }
+        public IriParsingElement IriParsing { get; }
+        public SchemeSettingElementCollection SchemeSettings { get; }
+    }
+    public sealed class UserScopedSettingAttribute : SettingAttribute {
+        public UserScopedSettingAttribute();
+    }
+    public sealed class UserSettingsGroup : ConfigurationSectionGroup {
+        public UserSettingsGroup();
+    }
+    public delegate void ValidatorCallback(object value); {
+        public ValidatorCallback(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object value, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object value);
+    }
+    public sealed class WhiteSpaceTrimStringConverter : ConfigurationConverterBase {
+        public WhiteSpaceTrimStringConverter();
+        public override object ConvertFrom(ITypeDescriptorContext ctx, CultureInfo ci, object data);
+        public override object ConvertTo(ITypeDescriptorContext ctx, CultureInfo ci, object value, Type type);
+    }
+}
+namespace System.Configuration.Internal {
+    public class DelegatingConfigHost : IInternalConfigHost {
+        protected DelegatingConfigHost();
+        protected IInternalConfigHost Host { get; set; }
+        public virtual bool IsRemote { get; }
+        public virtual bool SupportsChangeNotifications { get; }
+        public virtual bool SupportsLocation { get; }
+        public virtual bool SupportsPath { get; }
+        public virtual bool SupportsRefresh { get; }
+        public virtual object CreateConfigurationContext(string configPath, string locationSubPath);
+        public virtual object CreateDeprecatedConfigContext(string configPath);
+        public virtual string DecryptSection(string encryptedXml, ProtectedConfigurationProvider protectionProvider, ProtectedConfigurationSection protectedConfigSection);
+        public virtual void DeleteStream(string streamName);
+        public virtual string EncryptSection(string clearTextXml, ProtectedConfigurationProvider protectionProvider, ProtectedConfigurationSection protectedConfigSection);
+        public virtual string GetConfigPathFromLocationSubPath(string configPath, string locationSubPath);
+        public virtual Type GetConfigType(string typeName, bool throwOnError);
+        public virtual string GetConfigTypeName(Type t);
+        public virtual string GetStreamName(string configPath);
+        public virtual string GetStreamNameForConfigSource(string streamName, string configSource);
+        public virtual object GetStreamVersion(string streamName);
+        public virtual IDisposable Impersonate();
+        public virtual void Init(IInternalConfigRoot configRoot, params object[] hostInitParams);
+        public virtual void InitForConfiguration(ref string locationSubPath, out string configPath, out string locationConfigPath, IInternalConfigRoot configRoot, params object[] hostInitConfigurationParams);
+        public virtual bool IsAboveApplication(string configPath);
+        public virtual bool IsConfigRecordRequired(string configPath);
+        public virtual bool IsDefinitionAllowed(string configPath, ConfigurationAllowDefinition allowDefinition, ConfigurationAllowExeDefinition allowExeDefinition);
+        public virtual bool IsFile(string streamName);
+        public virtual bool IsFullTrustSectionWithoutAptcaAllowed(IInternalConfigRecord configRecord);
+        public virtual bool IsInitDelayed(IInternalConfigRecord configRecord);
+        public virtual bool IsLocationApplicable(string configPath);
+        public virtual bool IsSecondaryRoot(string configPath);
+        public virtual bool IsTrustedConfigPath(string configPath);
+        public virtual Stream OpenStreamForRead(string streamName);
+        public virtual Stream OpenStreamForRead(string streamName, bool assertPermissions);
+        public virtual Stream OpenStreamForWrite(string streamName, string templateStreamName, ref object writeContext);
+        public virtual Stream OpenStreamForWrite(string streamName, string templateStreamName, ref object writeContext, bool assertPermissions);
+        public virtual bool PrefetchAll(string configPath, string streamName);
+        public virtual bool PrefetchSection(string sectionGroupName, string sectionName);
+        public virtual void RequireCompleteInit(IInternalConfigRecord configRecord);
+        public virtual object StartMonitoringStreamForChanges(string streamName, StreamChangeCallback callback);
+        public virtual void StopMonitoringStreamForChanges(string streamName, StreamChangeCallback callback);
+        public virtual void VerifyDefinitionAllowed(string configPath, ConfigurationAllowDefinition allowDefinition, ConfigurationAllowExeDefinition allowExeDefinition, IConfigErrorInfo errorInfo);
+        public virtual void WriteCompleted(string streamName, bool success, object writeContext);
+        public virtual void WriteCompleted(string streamName, bool success, object writeContext, bool assertPermissions);
+    }
+    public interface IConfigErrorInfo {
+        string Filename { get; }
+        int LineNumber { get; }
+    }
+    public interface IConfigSystem {
+        IInternalConfigHost Host { get; }
+        IInternalConfigRoot Root { get; }
+        void Init(Type typeConfigHost, params object[] hostInitParams);
+    }
+    public interface IConfigurationManagerHelper {
+        void EnsureNetConfigLoaded();
+    }
+    public interface IConfigurationManagerInternal {
+        string ApplicationConfigUri { get; }
+        string ExeLocalConfigDirectory { get; }
+        string ExeLocalConfigPath { get; }
+        string ExeProductName { get; }
+        string ExeProductVersion { get; }
+        string ExeRoamingConfigDirectory { get; }
+        string ExeRoamingConfigPath { get; }
+        string MachineConfigPath { get; }
+        bool SetConfigurationSystemInProgress { get; }
+        bool SupportsUserConfig { get; }
+        string UserConfigFilename { get; }
+    }
+    public interface IInternalConfigClientHost {
+        string GetExeConfigPath();
+        string GetLocalUserConfigPath();
+        string GetRoamingUserConfigPath();
+        bool IsExeConfig(string configPath);
+        bool IsLocalUserConfig(string configPath);
+        bool IsRoamingUserConfig(string configPath);
+    }
+    public interface IInternalConfigConfigurationFactory {
+        Configuration Create(Type typeConfigHost, params object[] hostInitConfigurationParams);
+        string NormalizeLocationSubPath(string subPath, IConfigErrorInfo errorInfo);
+    }
+    public interface IInternalConfigHost {
+        bool IsRemote { get; }
+        bool SupportsChangeNotifications { get; }
+        bool SupportsLocation { get; }
+        bool SupportsPath { get; }
+        bool SupportsRefresh { get; }
+        object CreateConfigurationContext(string configPath, string locationSubPath);
+        object CreateDeprecatedConfigContext(string configPath);
+        string DecryptSection(string encryptedXml, ProtectedConfigurationProvider protectionProvider, ProtectedConfigurationSection protectedConfigSection);
+        void DeleteStream(string streamName);
+        string EncryptSection(string clearTextXml, ProtectedConfigurationProvider protectionProvider, ProtectedConfigurationSection protectedConfigSection);
+        string GetConfigPathFromLocationSubPath(string configPath, string locationSubPath);
+        Type GetConfigType(string typeName, bool throwOnError);
+        string GetConfigTypeName(Type t);
+        string GetStreamName(string configPath);
+        string GetStreamNameForConfigSource(string streamName, string configSource);
+        object GetStreamVersion(string streamName);
+        IDisposable Impersonate();
+        void Init(IInternalConfigRoot configRoot, params object[] hostInitParams);
+        void InitForConfiguration(ref string locationSubPath, out string configPath, out string locationConfigPath, IInternalConfigRoot configRoot, params object[] hostInitConfigurationParams);
+        bool IsAboveApplication(string configPath);
+        bool IsConfigRecordRequired(string configPath);
+        bool IsDefinitionAllowed(string configPath, ConfigurationAllowDefinition allowDefinition, ConfigurationAllowExeDefinition allowExeDefinition);
+        bool IsFile(string streamName);
+        bool IsFullTrustSectionWithoutAptcaAllowed(IInternalConfigRecord configRecord);
+        bool IsInitDelayed(IInternalConfigRecord configRecord);
+        bool IsLocationApplicable(string configPath);
+        bool IsSecondaryRoot(string configPath);
+        bool IsTrustedConfigPath(string configPath);
+        Stream OpenStreamForRead(string streamName);
+        Stream OpenStreamForRead(string streamName, bool assertPermissions);
+        Stream OpenStreamForWrite(string streamName, string templateStreamName, ref object writeContext);
+        Stream OpenStreamForWrite(string streamName, string templateStreamName, ref object writeContext, bool assertPermissions);
+        bool PrefetchAll(string configPath, string streamName);
+        bool PrefetchSection(string sectionGroupName, string sectionName);
+        void RequireCompleteInit(IInternalConfigRecord configRecord);
+        object StartMonitoringStreamForChanges(string streamName, StreamChangeCallback callback);
+        void StopMonitoringStreamForChanges(string streamName, StreamChangeCallback callback);
+        void VerifyDefinitionAllowed(string configPath, ConfigurationAllowDefinition allowDefinition, ConfigurationAllowExeDefinition allowExeDefinition, IConfigErrorInfo errorInfo);
+        void WriteCompleted(string streamName, bool success, object writeContext);
+        void WriteCompleted(string streamName, bool success, object writeContext, bool assertPermissions);
+    }
+    public interface IInternalConfigRecord {
+        string ConfigPath { get; }
+        bool HasInitErrors { get; }
+        string StreamName { get; }
+        object GetLkgSection(string configKey);
+        object GetSection(string configKey);
+        void RefreshSection(string configKey);
+        void Remove();
+        void ThrowIfInitErrors();
+    }
+    public interface IInternalConfigRoot {
+        bool IsDesignTime { get; }
+        IInternalConfigRecord GetConfigRecord(string configPath);
+        object GetSection(string section, string configPath);
+        string GetUniqueConfigPath(string configPath);
+        IInternalConfigRecord GetUniqueConfigRecord(string configPath);
+        void Init(IInternalConfigHost host, bool isDesignTime);
+        void RemoveConfig(string configPath);
+        event InternalConfigEventHandler ConfigChanged;
+        event InternalConfigEventHandler ConfigRemoved;
+    }
+    public interface IInternalConfigSettingsFactory {
+        void CompleteInit();
+        void SetConfigurationSystem(IInternalConfigSystem internalConfigSystem, bool initComplete);
+    }
+    public interface IInternalConfigSystem {
+        bool SupportsUserConfig { get; }
+        object GetSection(string configKey);
+        void RefreshConfig(string sectionName);
+    }
+    public sealed class InternalConfigEventArgs : EventArgs {
+        public InternalConfigEventArgs(string configPath);
+        public string ConfigPath { get; set; }
+    }
+    public delegate void InternalConfigEventHandler(object sender, InternalConfigEventArgs e); {
+        public InternalConfigEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, InternalConfigEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, InternalConfigEventArgs e);
+    }
+    public delegate void StreamChangeCallback(string streamName); {
+        public StreamChangeCallback(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(string streamName, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(string streamName);
+    }
+}
+namespace System.Configuration.Provider {
+    public abstract class ProviderBase {
+        protected ProviderBase();
+        public virtual string Description { get; }
+        public virtual string Name { get; }
+        public virtual void Initialize(string name, NameValueCollection config);
+    }
+    public class ProviderCollection : ICollection, IEnumerable {
+        public ProviderCollection();
+        public int Count { get; }
+        public bool IsSynchronized { get; }
+        public ProviderBase this[string name] { get; }
+        public object SyncRoot { get; }
+        public virtual void Add(ProviderBase provider);
+        public void Clear();
+        public void CopyTo(ProviderBase[] array, int index);
+        public IEnumerator GetEnumerator();
+        public void Remove(string name);
+        public void SetReadOnly();
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+    }
+    public class ProviderException : Exception {
+        public ProviderException();
+        protected ProviderException(SerializationInfo info, StreamingContext context);
+        public ProviderException(string message);
+        public ProviderException(string message, Exception innerException);
+    }
+}
 namespace System.Data {
+    public static class DataRowComparer {
+        public static DataRowComparer<DataRow> Default { get; }
+    }
+    public sealed class DataRowComparer<TRow> : IEqualityComparer<TRow> where TRow : DataRow {
+        public static DataRowComparer<TRow> Default { get; }
+        public bool Equals(TRow leftRow, TRow rightRow);
+        public int GetHashCode(TRow row);
+    }
+    public static class DataRowExtensions {
+        public static T Field<T>(this DataRow row, int columnIndex);
+        public static T Field<T>(this DataRow row, string columnName);
+        public static T Field<T>(this DataRow row, DataColumn column);
+        public static T Field<T>(this DataRow row, int columnIndex, DataRowVersion version);
+        public static T Field<T>(this DataRow row, string columnName, DataRowVersion version);
+        public static T Field<T>(this DataRow row, DataColumn column, DataRowVersion version);
+        public static void SetField<T>(this DataRow row, int columnIndex, T value);
+        public static void SetField<T>(this DataRow row, string columnName, T value);
+        public static void SetField<T>(this DataRow row, DataColumn column, T value);
+    }
+    public static class DataTableExtensions {
+        public static EnumerableRowCollection<DataRow> AsEnumerable(this DataTable source);
+        public static DataTable CopyToDataTable<T>(this IEnumerable<T> source) where T : DataRow;
+        public static void CopyToDataTable<T>(this IEnumerable<T> source, DataTable table, LoadOption options) where T : DataRow;
+        public static void CopyToDataTable<T>(this IEnumerable<T> source, DataTable table, LoadOption options, FillErrorEventHandler errorHandler) where T : DataRow;
+    }
     public sealed class DBConcurrencyException : SystemException {
-        public override void GetObjectData(SerializationInfo si, StreamingContext context);
+        public override void GetObjectData(SerializationInfo info, StreamingContext context);
     }
+    public abstract class EnumerableRowCollection : IEnumerable {
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public class EnumerableRowCollection<TRow> : EnumerableRowCollection, IEnumerable, IEnumerable<TRow> {
+        public IEnumerator<TRow> GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public static class EnumerableRowCollectionExtensions {
+        public static EnumerableRowCollection<TResult> Cast<TResult>(this EnumerableRowCollection source);
+        public static OrderedEnumerableRowCollection<TRow> OrderBy<TRow, TKey>(this EnumerableRowCollection<TRow> source, Func<TRow, TKey> keySelector);
+        public static OrderedEnumerableRowCollection<TRow> OrderBy<TRow, TKey>(this EnumerableRowCollection<TRow> source, Func<TRow, TKey> keySelector, IComparer<TKey> comparer);
+        public static OrderedEnumerableRowCollection<TRow> OrderByDescending<TRow, TKey>(this EnumerableRowCollection<TRow> source, Func<TRow, TKey> keySelector);
+        public static OrderedEnumerableRowCollection<TRow> OrderByDescending<TRow, TKey>(this EnumerableRowCollection<TRow> source, Func<TRow, TKey> keySelector, IComparer<TKey> comparer);
+        public static EnumerableRowCollection<S> Select<TRow, S>(this EnumerableRowCollection<TRow> source, Func<TRow, S> selector);
+        public static OrderedEnumerableRowCollection<TRow> ThenBy<TRow, TKey>(this OrderedEnumerableRowCollection<TRow> source, Func<TRow, TKey> keySelector);
+        public static OrderedEnumerableRowCollection<TRow> ThenBy<TRow, TKey>(this OrderedEnumerableRowCollection<TRow> source, Func<TRow, TKey> keySelector, IComparer<TKey> comparer);
+        public static OrderedEnumerableRowCollection<TRow> ThenByDescending<TRow, TKey>(this OrderedEnumerableRowCollection<TRow> source, Func<TRow, TKey> keySelector);
+        public static OrderedEnumerableRowCollection<TRow> ThenByDescending<TRow, TKey>(this OrderedEnumerableRowCollection<TRow> source, Func<TRow, TKey> keySelector, IComparer<TKey> comparer);
+        public static EnumerableRowCollection<TRow> Where<TRow>(this EnumerableRowCollection<TRow> source, Func<TRow, bool> predicate);
+    }
+    public sealed class OperationAbortedException : SystemException
+    public sealed class OrderedEnumerableRowCollection<TRow> : EnumerableRowCollection<TRow>
-    public class PropertyCollection : Hashtable {
+    public class PropertyCollection : Hashtable, ICloneable {
     }
+    public abstract class TypedTableBase<T> : DataTable, IEnumerable, IEnumerable<T> where T : DataRow {
+        protected TypedTableBase();
+        protected TypedTableBase(SerializationInfo info, StreamingContext context);
+        public EnumerableRowCollection<TResult> Cast<TResult>();
+        public IEnumerator<T> GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public static class TypedTableBaseExtensions {
+        public static EnumerableRowCollection<TRow> AsEnumerable<TRow>(this TypedTableBase<TRow> source) where TRow : DataRow;
+        public static TRow ElementAtOrDefault<TRow>(this TypedTableBase<TRow> source, int index) where TRow : DataRow;
+        public static OrderedEnumerableRowCollection<TRow> OrderBy<TRow, TKey>(this TypedTableBase<TRow> source, Func<TRow, TKey> keySelector) where TRow : DataRow;
+        public static OrderedEnumerableRowCollection<TRow> OrderBy<TRow, TKey>(this TypedTableBase<TRow> source, Func<TRow, TKey> keySelector, IComparer<TKey> comparer) where TRow : DataRow;
+        public static OrderedEnumerableRowCollection<TRow> OrderByDescending<TRow, TKey>(this TypedTableBase<TRow> source, Func<TRow, TKey> keySelector) where TRow : DataRow;
+        public static OrderedEnumerableRowCollection<TRow> OrderByDescending<TRow, TKey>(this TypedTableBase<TRow> source, Func<TRow, TKey> keySelector, IComparer<TKey> comparer) where TRow : DataRow;
+        public static EnumerableRowCollection<S> Select<TRow, S>(this TypedTableBase<TRow> source, Func<TRow, S> selector) where TRow : DataRow;
+        public static EnumerableRowCollection<TRow> Where<TRow>(this TypedTableBase<TRow> source, Func<TRow, bool> predicate) where TRow : DataRow;
+    }
 }
 namespace System.Data.Common {
+    public abstract class DBDataPermission : CodeAccessPermission, IUnrestrictedPermission {
+        protected DBDataPermission();
+        protected DBDataPermission(DBDataPermission permission);
+        protected DBDataPermission(DBDataPermissionAttribute permissionAttribute);
+        protected DBDataPermission(PermissionState state);
+        protected DBDataPermission(PermissionState state, bool allowBlankPassword);
+        public bool AllowBlankPassword { get; set; }
+        public virtual void Add(string connectionString, string restrictions, KeyRestrictionBehavior behavior);
+        protected void Clear();
+        public override IPermission Copy();
+        protected virtual DBDataPermission CreateInstance();
+        public override void FromXml(SecurityElement securityElement);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public abstract class DBDataPermissionAttribute : CodeAccessSecurityAttribute {
+        protected DBDataPermissionAttribute(SecurityAction action);
+        public bool AllowBlankPassword { get; set; }
+        public string ConnectionString { get; set; }
+        public KeyRestrictionBehavior KeyRestrictionBehavior { get; set; }
+        public string KeyRestrictions { get; set; }
+        public bool ShouldSerializeConnectionString();
+        public bool ShouldSerializeKeyRestrictions();
+    }
+    public static class DbProviderFactories {
+        public static DbProviderFactory GetFactory(DataRow providerRow);
+        public static DbProviderFactory GetFactory(DbConnection connection);
+        public static DbProviderFactory GetFactory(string providerInvariantName);
+        public static DataTable GetFactoryClasses();
+        public static IEnumerable<string> GetProviderInvariantNames();
+        public static void RegisterFactory(string providerInvariantName, DbProviderFactory factory);
+        public static void RegisterFactory(string providerInvariantName, string factoryTypeAssemblyQualifiedName);
+        public static void RegisterFactory(string providerInvariantName, Type factoryType);
+        public static bool TryGetFactory(string providerInvariantName, out DbProviderFactory factory);
+        public static bool UnregisterFactory(string providerInvariantName);
+    }
 }
+namespace System.Data.Odbc {
+    public sealed class OdbcCommand : DbCommand, ICloneable {
+        public OdbcCommand();
+        public OdbcCommand(string cmdText);
+        public OdbcCommand(string cmdText, OdbcConnection connection);
+        public OdbcCommand(string cmdText, OdbcConnection connection, OdbcTransaction transaction);
+        public override string CommandText { get; set; }
+        public override int CommandTimeout { get; set; }
+        public override CommandType CommandType { get; set; }
+        public OdbcConnection Connection { get; set; }
+        public override bool DesignTimeVisible { get; set; }
+        public OdbcParameterCollection Parameters { get; }
+        public OdbcTransaction Transaction { get; set; }
+        public override UpdateRowSource UpdatedRowSource { get; set; }
+        public override void Cancel();
+        public OdbcParameter CreateParameter();
+        public override int ExecuteNonQuery();
+        public OdbcDataReader ExecuteReader();
+        public OdbcDataReader ExecuteReader(CommandBehavior behavior);
+        public override object ExecuteScalar();
+        public override void Prepare();
+        public void ResetCommandTimeout();
+        object System.ICloneable.Clone();
+    }
+    public sealed class OdbcCommandBuilder : DbCommandBuilder {
+        public OdbcCommandBuilder();
+        public OdbcCommandBuilder(OdbcDataAdapter adapter);
+        public OdbcDataAdapter DataAdapter { get; set; }
+        public static void DeriveParameters(OdbcCommand command);
+        public OdbcCommand GetDeleteCommand();
+        public OdbcCommand GetDeleteCommand(bool useColumnsForParameterNames);
+        public OdbcCommand GetInsertCommand();
+        public OdbcCommand GetInsertCommand(bool useColumnsForParameterNames);
+        public OdbcCommand GetUpdateCommand();
+        public OdbcCommand GetUpdateCommand(bool useColumnsForParameterNames);
+        public override string QuoteIdentifier(string unquotedIdentifier);
+        public string QuoteIdentifier(string unquotedIdentifier, OdbcConnection connection);
+        public override string UnquoteIdentifier(string quotedIdentifier);
+        public string UnquoteIdentifier(string quotedIdentifier, OdbcConnection connection);
+    }
+    public sealed class OdbcConnection : DbConnection, ICloneable {
+        public OdbcConnection();
+        public OdbcConnection(string connectionString);
+        public override string ConnectionString { get; set; }
+        public int ConnectionTimeout { get; set; }
+        public override string Database { get; }
+        public override string DataSource { get; }
+        public string Driver { get; }
+        public override string ServerVersion { get; }
+        public override ConnectionState State { get; }
+        public OdbcTransaction BeginTransaction();
+        public OdbcTransaction BeginTransaction(IsolationLevel isolevel);
+        public override void ChangeDatabase(string value);
+        public override void Close();
+        public OdbcCommand CreateCommand();
+        public override void Open();
+        public static void ReleaseObjectPool();
+        object System.ICloneable.Clone();
+        public event OdbcInfoMessageEventHandler InfoMessage;
+    }
+    public sealed class OdbcConnectionStringBuilder : DbConnectionStringBuilder {
+        public OdbcConnectionStringBuilder();
+        public OdbcConnectionStringBuilder(string connectionString);
+        public string Driver { get; set; }
+        public string Dsn { get; set; }
+        public override object this[string keyword] { get; set; }
+        public override ICollection Keys { get; }
+        public override void Clear();
+        public override bool ContainsKey(string keyword);
+        public override bool Remove(string keyword);
+        public override bool TryGetValue(string keyword, out object value);
+    }
+    public sealed class OdbcDataAdapter : DbDataAdapter, ICloneable, IDataAdapter, IDbDataAdapter {
+        public OdbcDataAdapter();
+        public OdbcDataAdapter(OdbcCommand selectCommand);
+        public OdbcDataAdapter(string selectCommandText, OdbcConnection selectConnection);
+        public OdbcDataAdapter(string selectCommandText, string selectConnectionString);
+        public OdbcCommand DeleteCommand { get; set; }
+        public OdbcCommand InsertCommand { get; set; }
+        public OdbcCommand SelectCommand { get; set; }
+        IDbCommand System.Data.IDbDataAdapter.DeleteCommand { get; set; }
+        IDbCommand System.Data.IDbDataAdapter.InsertCommand { get; set; }
+        IDbCommand System.Data.IDbDataAdapter.SelectCommand { get; set; }
+        IDbCommand System.Data.IDbDataAdapter.UpdateCommand { get; set; }
+        public OdbcCommand UpdateCommand { get; set; }
+        get;
+        get;
+        get;
+        get;
+        set;
+        set;
+        set;
+        set;
+        object System.ICloneable.Clone();
+        public event OdbcRowUpdatedEventHandler RowUpdated;
+        public event OdbcRowUpdatingEventHandler RowUpdating;
+    }
+    public sealed class OdbcDataReader : DbDataReader {
+        public override int Depth { get; }
+        public override int FieldCount { get; }
+        public override bool HasRows { get; }
+        public override bool IsClosed { get; }
+        public override object this[int i] { get; }
+        public override object this[string value] { get; }
+        public override int RecordsAffected { get; }
+        public override void Close();
+        public override bool GetBoolean(int i);
+        public override byte GetByte(int i);
+        public override long GetBytes(int i, long dataIndex, byte[] buffer, int bufferIndex, int length);
+        public override char GetChar(int i);
+        public override long GetChars(int i, long dataIndex, char[] buffer, int bufferIndex, int length);
+        public override string GetDataTypeName(int i);
+        public DateTime GetDate(int i);
+        public override DateTime GetDateTime(int i);
+        public override decimal GetDecimal(int i);
+        public override double GetDouble(int i);
+        public override IEnumerator GetEnumerator();
+        public override Type GetFieldType(int i);
+        public override float GetFloat(int i);
+        public override Guid GetGuid(int i);
+        public override short GetInt16(int i);
+        public override int GetInt32(int i);
+        public override long GetInt64(int i);
+        public override string GetName(int i);
+        public override int GetOrdinal(string value);
+        public override DataTable GetSchemaTable();
+        public override string GetString(int i);
+        public TimeSpan GetTime(int i);
+        public override object GetValue(int i);
+        public override int GetValues(object[] values);
+        public override bool IsDBNull(int i);
+        public override bool NextResult();
+        public override bool Read();
+    }
+    public sealed class OdbcError {
+        public string Message { get; }
+        public int NativeError { get; }
+        public string Source { get; }
+        public string SQLState { get; }
+        public override string ToString();
+    }
+    public sealed class OdbcErrorCollection : ICollection, IEnumerable {
+        public int Count { get; }
+        public OdbcError this[int i] { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public void CopyTo(Array array, int i);
+        public void CopyTo(OdbcError[] array, int i);
+        public IEnumerator GetEnumerator();
+        get;
+        get;
+    }
+    public sealed class OdbcException : DbException {
+        public OdbcErrorCollection Errors { get; }
+        public override string Source { get; }
+        public override void GetObjectData(SerializationInfo si, StreamingContext context);
+    }
+    public sealed class OdbcFactory : DbProviderFactory {
+        public static readonly OdbcFactory Instance;
+        public override DbCommand CreateCommand();
+        public override DbCommandBuilder CreateCommandBuilder();
+        public override DbConnection CreateConnection();
+        public override DbConnectionStringBuilder CreateConnectionStringBuilder();
+        public override DbDataAdapter CreateDataAdapter();
+        public override DbParameter CreateParameter();
+    }
+    public sealed class OdbcInfoMessageEventArgs : EventArgs {
+        public OdbcErrorCollection Errors { get; }
+        public string Message { get; }
+        public override string ToString();
+    }
+    public delegate void OdbcInfoMessageEventHandler(object sender, OdbcInfoMessageEventArgs e); {
+        public OdbcInfoMessageEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, OdbcInfoMessageEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, OdbcInfoMessageEventArgs e);
+    }
+    public static class OdbcMetaDataCollectionNames {
+        public static readonly string Columns;
+        public static readonly string Indexes;
+        public static readonly string ProcedureColumns;
+        public static readonly string ProcedureParameters;
+        public static readonly string Procedures;
+        public static readonly string Tables;
+        public static readonly string Views;
+    }
+    public static class OdbcMetaDataColumnNames {
+        public static readonly string BooleanFalseLiteral;
+        public static readonly string BooleanTrueLiteral;
+        public static readonly string SQLType;
+    }
+    public sealed class OdbcParameter : DbParameter, ICloneable, IDataParameter, IDbDataParameter {
+        public OdbcParameter();
+        public OdbcParameter(string name, object value);
+        public OdbcParameter(string name, OdbcType type);
+        public OdbcParameter(string name, OdbcType type, int size);
+        public OdbcParameter(string parameterName, OdbcType odbcType, int size, ParameterDirection parameterDirection, bool isNullable, byte precision, byte scale, string srcColumn, DataRowVersion srcVersion, object value);
+        public OdbcParameter(string parameterName, OdbcType odbcType, int size, ParameterDirection parameterDirection, byte precision, byte scale, string sourceColumn, DataRowVersion sourceVersion, bool sourceColumnNullMapping, object value);
+        public OdbcParameter(string name, OdbcType type, int size, string sourcecolumn);
+        public override DbType DbType { get; set; }
+        public override ParameterDirection Direction { get; set; }
+        public override bool IsNullable { get; set; }
+        public OdbcType OdbcType { get; set; }
+        public override string ParameterName { get; set; }
+        public byte Precision { get; set; }
+        public byte Scale { get; set; }
+        public override int Size { get; set; }
+        public override string SourceColumn { get; set; }
+        public override bool SourceColumnNullMapping { get; set; }
+        public override DataRowVersion SourceVersion { get; set; }
+        public override object Value { get; set; }
+        public override void ResetDbType();
+        public void ResetOdbcType();
+        object System.ICloneable.Clone();
+        public override string ToString();
+    }
+    public sealed class OdbcParameterCollection : DbParameterCollection {
+        public override int Count { get; }
+        public override bool IsFixedSize { get; }
+        public override bool IsReadOnly { get; }
+        public override bool IsSynchronized { get; }
+        public OdbcParameter this[int index] { get; set; }
+        public OdbcParameter this[string parameterName] { get; set; }
+        public override object SyncRoot { get; }
+        public override int Add(object value);
+        public OdbcParameter Add(OdbcParameter value);
+        public OdbcParameter Add(string parameterName, object value);
+        public OdbcParameter Add(string parameterName, OdbcType odbcType);
+        public OdbcParameter Add(string parameterName, OdbcType odbcType, int size);
+        public OdbcParameter Add(string parameterName, OdbcType odbcType, int size, string sourceColumn);
+        public override void AddRange(Array values);
+        public void AddRange(OdbcParameter[] values);
+        public OdbcParameter AddWithValue(string parameterName, object value);
+        public override void Clear();
+        public override bool Contains(object value);
+        public bool Contains(OdbcParameter value);
+        public override bool Contains(string value);
+        public override void CopyTo(Array array, int index);
+        public void CopyTo(OdbcParameter[] array, int index);
+        public override IEnumerator GetEnumerator();
+        public override int IndexOf(object value);
+        public int IndexOf(OdbcParameter value);
+        public override int IndexOf(string parameterName);
+        public override void Insert(int index, object value);
+        public void Insert(int index, OdbcParameter value);
+        public override void Remove(object value);
+        public void Remove(OdbcParameter value);
+        public override void RemoveAt(int index);
+        public override void RemoveAt(string parameterName);
+    }
+    public sealed class OdbcPermission : DBDataPermission {
+        public OdbcPermission();
+        public OdbcPermission(PermissionState state);
+        public OdbcPermission(PermissionState state, bool allowBlankPassword);
+        public override void Add(string connectionString, string restrictions, KeyRestrictionBehavior behavior);
+        public override IPermission Copy();
+    }
+    public sealed class OdbcPermissionAttribute : DBDataPermissionAttribute {
+        public OdbcPermissionAttribute(SecurityAction action);
+        public override IPermission CreatePermission();
+    }
+    public sealed class OdbcRowUpdatedEventArgs : RowUpdatedEventArgs {
+        public OdbcRowUpdatedEventArgs(DataRow row, IDbCommand command, StatementType statementType, DataTableMapping tableMapping);
+        public OdbcCommand Command { get; }
+    }
+    public delegate void OdbcRowUpdatedEventHandler(object sender, OdbcRowUpdatedEventArgs e); {
+        public OdbcRowUpdatedEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, OdbcRowUpdatedEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, OdbcRowUpdatedEventArgs e);
+    }
+    public sealed class OdbcRowUpdatingEventArgs : RowUpdatingEventArgs {
+        public OdbcRowUpdatingEventArgs(DataRow row, IDbCommand command, StatementType statementType, DataTableMapping tableMapping);
+        public OdbcCommand Command { get; set; }
+    }
+    public delegate void OdbcRowUpdatingEventHandler(object sender, OdbcRowUpdatingEventArgs e); {
+        public OdbcRowUpdatingEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, OdbcRowUpdatingEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, OdbcRowUpdatingEventArgs e);
+    }
+    public sealed class OdbcTransaction : DbTransaction {
+        public OdbcConnection Connection { get; }
+        public override IsolationLevel IsolationLevel { get; }
+        public override void Commit();
+        public override void Rollback();
+    }
+    public enum OdbcType {
+        BigInt = 1,
+        Binary = 2,
+        Bit = 3,
+        Char = 4,
+        Date = 23,
+        DateTime = 5,
+        Decimal = 6,
+        Double = 8,
+        Image = 9,
+        Int = 10,
+        NChar = 11,
+        NText = 12,
+        Numeric = 7,
+        NVarChar = 13,
+        Real = 14,
+        SmallDateTime = 16,
+        SmallInt = 17,
+        Text = 18,
+        Time = 24,
+        Timestamp = 19,
+        TinyInt = 20,
+        UniqueIdentifier = 15,
+        VarBinary = 21,
+        VarChar = 22,
+    }
+}
+namespace System.Data.OleDb {
+    public sealed class OleDbPermission : DBDataPermission {
+        public OleDbPermission();
+        public OleDbPermission(PermissionState state);
+        public OleDbPermission(PermissionState state, bool allowBlankPassword);
+        public string Provider { get; set; }
+        public override IPermission Copy();
+    }
+    public sealed class OleDbPermissionAttribute : DBDataPermissionAttribute {
+        public OleDbPermissionAttribute(SecurityAction action);
+        public string Provider { get; set; }
+        public override IPermission CreatePermission();
+    }
+}
+namespace System.Data.OracleClient {
+    public sealed class OraclePermission : CodeAccessPermission, IUnrestrictedPermission {
+        public OraclePermission(PermissionState state);
+        public bool AllowBlankPassword { get; set; }
+        public void Add(string connectionString, string restrictions, KeyRestrictionBehavior behavior);
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement securityElement);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class OraclePermissionAttribute : CodeAccessSecurityAttribute {
+        public OraclePermissionAttribute(SecurityAction action);
+        public bool AllowBlankPassword { get; set; }
+        public string ConnectionString { get; set; }
+        public KeyRestrictionBehavior KeyRestrictionBehavior { get; set; }
+        public string KeyRestrictions { get; set; }
+        public override IPermission CreatePermission();
+        public bool ShouldSerializeConnectionString();
+        public bool ShouldSerializeKeyRestrictions();
+    }
+}
+namespace System.Data.Sql {
+    public sealed class SqlNotificationRequest {
+        public SqlNotificationRequest();
+        public SqlNotificationRequest(string userData, string options, int timeout);
+        public string Options { get; set; }
+        public int Timeout { get; set; }
+        public string UserData { get; set; }
+    }
+}
+namespace System.Data.SqlClient {
+    public enum ApplicationIntent {
+        ReadOnly = 1,
+        ReadWrite = 0,
+    }
+    public delegate void OnChangeEventHandler(object sender, SqlNotificationEventArgs e); {
+        public OnChangeEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, SqlNotificationEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, SqlNotificationEventArgs e);
+    }
+    public enum SortOrder {
+        Ascending = 0,
+        Descending = 1,
+        Unspecified = -1,
+    }
+    public sealed class SqlBulkCopy : IDisposable {
+        public SqlBulkCopy(SqlConnection connection);
+        public SqlBulkCopy(SqlConnection connection, SqlBulkCopyOptions copyOptions, SqlTransaction externalTransaction);
+        public SqlBulkCopy(string connectionString);
+        public SqlBulkCopy(string connectionString, SqlBulkCopyOptions copyOptions);
+        public int BatchSize { get; set; }
+        public int BulkCopyTimeout { get; set; }
+        public SqlBulkCopyColumnMappingCollection ColumnMappings { get; }
+        public string DestinationTableName { get; set; }
+        public bool EnableStreaming { get; set; }
+        public int NotifyAfter { get; set; }
+        public void Close();
+        void System.IDisposable.Dispose();
+        public void WriteToServer(DataRow[] rows);
+        public void WriteToServer(DataTable table);
+        public void WriteToServer(DataTable table, DataRowState rowState);
+        public void WriteToServer(DbDataReader reader);
+        public void WriteToServer(IDataReader reader);
+        public Task WriteToServerAsync(DataRow[] rows);
+        public Task WriteToServerAsync(DataRow[] rows, CancellationToken cancellationToken);
+        public Task WriteToServerAsync(DataTable table);
+        public Task WriteToServerAsync(DataTable table, CancellationToken cancellationToken);
+        public Task WriteToServerAsync(DataTable table, DataRowState rowState);
+        public Task WriteToServerAsync(DataTable table, DataRowState rowState, CancellationToken cancellationToken);
+        public Task WriteToServerAsync(DbDataReader reader);
+        public Task WriteToServerAsync(DbDataReader reader, CancellationToken cancellationToken);
+        public Task WriteToServerAsync(IDataReader reader);
+        public Task WriteToServerAsync(IDataReader reader, CancellationToken cancellationToken);
+        public event SqlRowsCopiedEventHandler SqlRowsCopied;
+    }
+    public sealed class SqlBulkCopyColumnMapping {
+        public SqlBulkCopyColumnMapping();
+        public SqlBulkCopyColumnMapping(int sourceColumnOrdinal, int destinationOrdinal);
+        public SqlBulkCopyColumnMapping(int sourceColumnOrdinal, string destinationColumn);
+        public SqlBulkCopyColumnMapping(string sourceColumn, int destinationOrdinal);
+        public SqlBulkCopyColumnMapping(string sourceColumn, string destinationColumn);
+        public string DestinationColumn { get; set; }
+        public int DestinationOrdinal { get; set; }
+        public string SourceColumn { get; set; }
+        public int SourceOrdinal { get; set; }
+    }
+    public sealed class SqlBulkCopyColumnMappingCollection : CollectionBase {
+        public SqlBulkCopyColumnMapping this[int index] { get; }
+        public SqlBulkCopyColumnMapping Add(int sourceColumnIndex, int destinationColumnIndex);
+        public SqlBulkCopyColumnMapping Add(int sourceColumnIndex, string destinationColumn);
+        public SqlBulkCopyColumnMapping Add(SqlBulkCopyColumnMapping bulkCopyColumnMapping);
+        public SqlBulkCopyColumnMapping Add(string sourceColumn, int destinationColumnIndex);
+        public SqlBulkCopyColumnMapping Add(string sourceColumn, string destinationColumn);
+        public void Clear();
+        public bool Contains(SqlBulkCopyColumnMapping value);
+        public void CopyTo(SqlBulkCopyColumnMapping[] array, int index);
+        public int IndexOf(SqlBulkCopyColumnMapping value);
+        public void Insert(int index, SqlBulkCopyColumnMapping value);
+        public void Remove(SqlBulkCopyColumnMapping value);
+        public void RemoveAt(int index);
+    }
+    public enum SqlBulkCopyOptions {
+        CheckConstraints = 2,
+        Default = 0,
+        FireTriggers = 16,
+        KeepIdentity = 1,
+        KeepNulls = 8,
+        TableLock = 4,
+        UseInternalTransaction = 32,
+    }
+    public sealed class SqlClientFactory : DbProviderFactory {
+        public static readonly SqlClientFactory Instance;
+        public override DbCommand CreateCommand();
+        public override DbCommandBuilder CreateCommandBuilder();
+        public override DbConnection CreateConnection();
+        public override DbConnectionStringBuilder CreateConnectionStringBuilder();
+        public override DbDataAdapter CreateDataAdapter();
+        public override DbParameter CreateParameter();
+    }
+    public static class SqlClientMetaDataCollectionNames {
+        public static readonly string Columns;
+        public static readonly string Databases;
+        public static readonly string ForeignKeys;
+        public static readonly string IndexColumns;
+        public static readonly string Indexes;
+        public static readonly string Parameters;
+        public static readonly string ProcedureColumns;
+        public static readonly string Procedures;
+        public static readonly string Tables;
+        public static readonly string UserDefinedTypes;
+        public static readonly string Users;
+        public static readonly string ViewColumns;
+        public static readonly string Views;
+    }
+    public sealed class SqlClientPermission : DBDataPermission {
+        public SqlClientPermission();
+        public SqlClientPermission(PermissionState state);
+        public SqlClientPermission(PermissionState state, bool allowBlankPassword);
+        public override void Add(string connectionString, string restrictions, KeyRestrictionBehavior behavior);
+        public override IPermission Copy();
+    }
+    public sealed class SqlClientPermissionAttribute : DBDataPermissionAttribute {
+        public SqlClientPermissionAttribute(SecurityAction action);
+        public override IPermission CreatePermission();
+    }
+    public sealed class SqlCommand : DbCommand, ICloneable {
+        public SqlCommand();
+        public SqlCommand(string cmdText);
+        public SqlCommand(string cmdText, SqlConnection connection);
+        public SqlCommand(string cmdText, SqlConnection connection, SqlTransaction transaction);
+        public override string CommandText { get; set; }
+        public override int CommandTimeout { get; set; }
+        public override CommandType CommandType { get; set; }
+        public SqlConnection Connection { get; set; }
+        public override bool DesignTimeVisible { get; set; }
+        public SqlNotificationRequest Notification { get; set; }
+        public SqlParameterCollection Parameters { get; }
+        public SqlTransaction Transaction { get; set; }
+        public override UpdateRowSource UpdatedRowSource { get; set; }
+        public IAsyncResult BeginExecuteNonQuery();
+        public IAsyncResult BeginExecuteNonQuery(AsyncCallback callback, object stateObject);
+        public IAsyncResult BeginExecuteXmlReader();
+        public IAsyncResult BeginExecuteXmlReader(AsyncCallback callback, object stateObject);
+        public override void Cancel();
+        public SqlCommand Clone();
+        public SqlParameter CreateParameter();
+        public int EndExecuteNonQuery(IAsyncResult asyncResult);
+        public XmlReader EndExecuteXmlReader(IAsyncResult asyncResult);
+        public override int ExecuteNonQuery();
+        public override Task<int> ExecuteNonQueryAsync(CancellationToken cancellationToken);
+        public SqlDataReader ExecuteReader();
+        public SqlDataReader ExecuteReader(CommandBehavior behavior);
+        public Task<SqlDataReader> ExecuteReaderAsync();
+        public Task<SqlDataReader> ExecuteReaderAsync(CancellationToken cancellationToken);
+        public Task<SqlDataReader> ExecuteReaderAsync(CommandBehavior behavior);
+        public Task<SqlDataReader> ExecuteReaderAsync(CommandBehavior behavior, CancellationToken cancellationToken);
+        public override object ExecuteScalar();
+        public override Task<object> ExecuteScalarAsync(CancellationToken cancellationToken);
+        public XmlReader ExecuteXmlReader();
+        public Task<XmlReader> ExecuteXmlReaderAsync();
+        public Task<XmlReader> ExecuteXmlReaderAsync(CancellationToken cancellationToken);
+        public override void Prepare();
+        public void ResetCommandTimeout();
+        object System.ICloneable.Clone();
+        public event StatementCompletedEventHandler StatementCompleted;
+    }
+    public sealed class SqlCommandBuilder : DbCommandBuilder {
+        public SqlCommandBuilder();
+        public SqlCommandBuilder(SqlDataAdapter adapter);
+        public override CatalogLocation CatalogLocation { get; set; }
+        public override string CatalogSeparator { get; set; }
+        public SqlDataAdapter DataAdapter { get; set; }
+        public override string QuotePrefix { get; set; }
+        public override string QuoteSuffix { get; set; }
+        public override string SchemaSeparator { get; set; }
+        public static void DeriveParameters(SqlCommand command);
+        public SqlCommand GetDeleteCommand();
+        public SqlCommand GetDeleteCommand(bool useColumnsForParameterNames);
+        public SqlCommand GetInsertCommand();
+        public SqlCommand GetInsertCommand(bool useColumnsForParameterNames);
+        public SqlCommand GetUpdateCommand();
+        public SqlCommand GetUpdateCommand(bool useColumnsForParameterNames);
+        public override string QuoteIdentifier(string unquotedIdentifier);
+        public override string UnquoteIdentifier(string quotedIdentifier);
+    }
+    public sealed class SqlConnection : DbConnection, ICloneable {
+        public SqlConnection();
+        public SqlConnection(string connectionString);
+        public Guid ClientConnectionId { get; }
+        public override string ConnectionString { get; set; }
+        public override int ConnectionTimeout { get; }
+        public override string Database { get; }
+        public override string DataSource { get; }
+        public bool FireInfoMessageEventOnUserErrors { get; set; }
+        public int PacketSize { get; }
+        public override string ServerVersion { get; }
+        public override ConnectionState State { get; }
+        public bool StatisticsEnabled { get; set; }
+        public string WorkstationId { get; }
+        public SqlTransaction BeginTransaction();
+        public SqlTransaction BeginTransaction(IsolationLevel iso);
+        public SqlTransaction BeginTransaction(IsolationLevel iso, string transactionName);
+        public SqlTransaction BeginTransaction(string transactionName);
+        public override void ChangeDatabase(string database);
+        public static void ClearAllPools();
+        public static void ClearPool(SqlConnection connection);
+        public override void Close();
+        public SqlCommand CreateCommand();
+        public override DataTable GetSchema();
+        public override DataTable GetSchema(string collectionName);
+        public override DataTable GetSchema(string collectionName, string[] restrictionValues);
+        public override void Open();
+        public override Task OpenAsync(CancellationToken cancellationToken);
+        public void ResetStatistics();
+        public IDictionary RetrieveStatistics();
+        object System.ICloneable.Clone();
+        public event SqlInfoMessageEventHandler InfoMessage;
+    }
+    public sealed class SqlConnectionStringBuilder : DbConnectionStringBuilder {
+        public SqlConnectionStringBuilder();
+        public SqlConnectionStringBuilder(string connectionString);
+        public ApplicationIntent ApplicationIntent { get; set; }
+        public string ApplicationName { get; set; }
+        public string AttachDBFilename { get; set; }
+        public int ConnectRetryCount { get; set; }
+        public int ConnectRetryInterval { get; set; }
+        public int ConnectTimeout { get; set; }
+        public string CurrentLanguage { get; set; }
+        public string DataSource { get; set; }
+        public bool Encrypt { get; set; }
+        public bool Enlist { get; set; }
+        public string FailoverPartner { get; set; }
+        public string InitialCatalog { get; set; }
+        public bool IntegratedSecurity { get; set; }
+        public override object this[string keyword] { get; set; }
+        public override ICollection Keys { get; }
+        public int LoadBalanceTimeout { get; set; }
+        public int MaxPoolSize { get; set; }
+        public int MinPoolSize { get; set; }
+        public bool MultipleActiveResultSets { get; set; }
+        public bool MultiSubnetFailover { get; set; }
+        public int PacketSize { get; set; }
+        public string Password { get; set; }
+        public bool PersistSecurityInfo { get; set; }
+        public bool Pooling { get; set; }
+        public bool Replication { get; set; }
+        public string TransactionBinding { get; set; }
+        public bool TrustServerCertificate { get; set; }
+        public string TypeSystemVersion { get; set; }
+        public string UserID { get; set; }
+        public bool UserInstance { get; set; }
+        public override ICollection Values { get; }
+        public string WorkstationID { get; set; }
+        public override void Clear();
+        public override bool ContainsKey(string keyword);
+        public override bool Remove(string keyword);
+        public override bool ShouldSerialize(string keyword);
+        public override bool TryGetValue(string keyword, out object value);
+    }
+    public sealed class SqlCredential {
+        public SqlCredential(string userId, SecureString password);
+        public SecureString Password { get; }
+        public string UserId { get; }
+    }
+    public sealed class SqlDataAdapter : DbDataAdapter, ICloneable, IDataAdapter, IDbDataAdapter {
+        public SqlDataAdapter();
+        public SqlDataAdapter(SqlCommand selectCommand);
+        public SqlDataAdapter(string selectCommandText, SqlConnection selectConnection);
+        public SqlDataAdapter(string selectCommandText, string selectConnectionString);
+        public SqlCommand DeleteCommand { get; set; }
+        public SqlCommand InsertCommand { get; set; }
+        public SqlCommand SelectCommand { get; set; }
+        IDbCommand System.Data.IDbDataAdapter.DeleteCommand { get; set; }
+        IDbCommand System.Data.IDbDataAdapter.InsertCommand { get; set; }
+        IDbCommand System.Data.IDbDataAdapter.SelectCommand { get; set; }
+        IDbCommand System.Data.IDbDataAdapter.UpdateCommand { get; set; }
+        public override int UpdateBatchSize { get; set; }
+        public SqlCommand UpdateCommand { get; set; }
+        get;
+        get;
+        get;
+        get;
+        set;
+        set;
+        set;
+        set;
+        object System.ICloneable.Clone();
+        public event SqlRowUpdatedEventHandler RowUpdated;
+        public event SqlRowUpdatingEventHandler RowUpdating;
+    }
+    public class SqlDataReader : DbDataReader, IDisposable {
+        protected SqlConnection Connection { get; }
+        public override int Depth { get; }
+        public override int FieldCount { get; }
+        public override bool HasRows { get; }
+        public override bool IsClosed { get; }
+        public override object this[int i] { get; }
+        public override object this[string name] { get; }
+        public override int RecordsAffected { get; }
+        public override int VisibleFieldCount { get; }
+        public override bool GetBoolean(int i);
+        public override byte GetByte(int i);
+        public override long GetBytes(int i, long dataIndex, byte[] buffer, int bufferIndex, int length);
+        public override char GetChar(int i);
+        public override long GetChars(int i, long dataIndex, char[] buffer, int bufferIndex, int length);
+        public override string GetDataTypeName(int i);
+        public override DateTime GetDateTime(int i);
+        public virtual DateTimeOffset GetDateTimeOffset(int i);
+        public override decimal GetDecimal(int i);
+        public override double GetDouble(int i);
+        public override IEnumerator GetEnumerator();
+        public override Type GetFieldType(int i);
+        public override T GetFieldValue<T>(int i);
+        public override Task<T> GetFieldValueAsync<T>(int i, CancellationToken cancellationToken);
+        public override float GetFloat(int i);
+        public override Guid GetGuid(int i);
+        public override short GetInt16(int i);
+        public override int GetInt32(int i);
+        public override long GetInt64(int i);
+        public override string GetName(int i);
+        public override int GetOrdinal(string name);
+        public override Type GetProviderSpecificFieldType(int i);
+        public override object GetProviderSpecificValue(int i);
+        public override int GetProviderSpecificValues(object[] values);
+        public override DataTable GetSchemaTable();
+        public virtual SqlBinary GetSqlBinary(int i);
+        public virtual SqlBoolean GetSqlBoolean(int i);
+        public virtual SqlByte GetSqlByte(int i);
+        public virtual SqlBytes GetSqlBytes(int i);
+        public virtual SqlChars GetSqlChars(int i);
+        public virtual SqlDateTime GetSqlDateTime(int i);
+        public virtual SqlDecimal GetSqlDecimal(int i);
+        public virtual SqlDouble GetSqlDouble(int i);
+        public virtual SqlGuid GetSqlGuid(int i);
+        public virtual SqlInt16 GetSqlInt16(int i);
+        public virtual SqlInt32 GetSqlInt32(int i);
+        public virtual SqlInt64 GetSqlInt64(int i);
+        public virtual SqlMoney GetSqlMoney(int i);
+        public virtual SqlSingle GetSqlSingle(int i);
+        public virtual SqlString GetSqlString(int i);
+        public virtual object GetSqlValue(int i);
+        public virtual int GetSqlValues(object[] values);
+        public virtual SqlXml GetSqlXml(int i);
+        public override Stream GetStream(int i);
+        public override string GetString(int i);
+        public override TextReader GetTextReader(int i);
+        public virtual TimeSpan GetTimeSpan(int i);
+        public override object GetValue(int i);
+        public override int GetValues(object[] values);
+        public virtual XmlReader GetXmlReader(int i);
+        protected internal bool IsCommandBehavior(CommandBehavior condition);
+        public override bool IsDBNull(int i);
+        public override Task<bool> IsDBNullAsync(int i, CancellationToken cancellationToken);
+        public override bool NextResult();
+        public override Task<bool> NextResultAsync(CancellationToken cancellationToken);
+        public override bool Read();
+        public override Task<bool> ReadAsync(CancellationToken cancellationToken);
+    }
+    public sealed class SqlDependency {
+        public SqlDependency();
+        public SqlDependency(SqlCommand command);
+        public SqlDependency(SqlCommand command, string options, int timeout);
+        public bool HasChanges { get; }
+        public string Id { get; }
+        public void AddCommandDependency(SqlCommand command);
+        public static bool Start(string connectionString);
+        public static bool Start(string connectionString, string queue);
+        public static bool Stop(string connectionString);
+        public static bool Stop(string connectionString, string queue);
+        public event OnChangeEventHandler OnChange;
+    }
+    public sealed class SqlError {
+        public byte Class { get; }
+        public int LineNumber { get; }
+        public string Message { get; }
+        public int Number { get; }
+        public string Procedure { get; }
+        public string Server { get; }
+        public string Source { get; }
+        public byte State { get; }
+        public override string ToString();
+    }
+    public sealed class SqlErrorCollection : ICollection, IEnumerable {
+        public int Count { get; }
+        public SqlError this[int index] { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public void CopyTo(Array array, int index);
+        public void CopyTo(SqlError[] array, int index);
+        public IEnumerator GetEnumerator();
+        get;
+        get;
+    }
+    public sealed class SqlException : DbException {
+        public byte Class { get; }
+        public Guid ClientConnectionId { get; }
+        public SqlErrorCollection Errors { get; }
+        public int LineNumber { get; }
+        public int Number { get; }
+        public string Procedure { get; }
+        public string Server { get; }
+        public override string Source { get; }
+        public byte State { get; }
+        public override void GetObjectData(SerializationInfo si, StreamingContext context);
+        public override string ToString();
+    }
+    public sealed class SqlInfoMessageEventArgs : EventArgs {
+        public SqlErrorCollection Errors { get; }
+        public string Message { get; }
+        public string Source { get; }
+        public override string ToString();
+    }
+    public delegate void SqlInfoMessageEventHandler(object sender, SqlInfoMessageEventArgs e); {
+        public SqlInfoMessageEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, SqlInfoMessageEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, SqlInfoMessageEventArgs e);
+    }
+    public class SqlNotificationEventArgs : EventArgs {
+        public SqlNotificationEventArgs(SqlNotificationType type, SqlNotificationInfo info, SqlNotificationSource source);
+        public SqlNotificationInfo Info { get; }
+        public SqlNotificationSource Source { get; }
+        public SqlNotificationType Type { get; }
+    }
+    public enum SqlNotificationInfo {
+        AlreadyChanged = -2,
+        Alter = 5,
+        Delete = 3,
+        Drop = 4,
+        Error = 7,
+        Expired = 12,
+        Insert = 1,
+        Invalid = 9,
+        Isolation = 11,
+        Merge = 16,
+        Options = 10,
+        PreviousFire = 14,
+        Query = 8,
+        Resource = 13,
+        Restart = 6,
+        TemplateLimit = 15,
+        Truncate = 0,
+        Unknown = -1,
+        Update = 2,
+    }
+    public enum SqlNotificationSource {
+        Client = -2,
+        Data = 0,
+        Database = 3,
+        Environment = 6,
+        Execution = 7,
+        Object = 2,
+        Owner = 8,
+        Statement = 5,
+        System = 4,
+        Timeout = 1,
+        Unknown = -1,
+    }
+    public enum SqlNotificationType {
+        Change = 0,
+        Subscribe = 1,
+        Unknown = -1,
+    }
+    public sealed class SqlParameter : DbParameter, ICloneable {
+        public SqlParameter();
+        public SqlParameter(string parameterName, object value);
+        public SqlParameter(string parameterName, SqlDbType dbType);
+        public SqlParameter(string parameterName, SqlDbType dbType, int size);
+        public SqlParameter(string parameterName, SqlDbType dbType, int size, ParameterDirection direction, bool isNullable, byte precision, byte scale, string sourceColumn, DataRowVersion sourceVersion, object value);
+        public SqlParameter(string parameterName, SqlDbType dbType, int size, ParameterDirection direction, byte precision, byte scale, string sourceColumn, DataRowVersion sourceVersion, bool sourceColumnNullMapping, object value, string xmlSchemaCollectionDatabase, string xmlSchemaCollectionOwningSchema, string xmlSchemaCollectionName);
+        public SqlParameter(string parameterName, SqlDbType dbType, int size, string sourceColumn);
+        public SqlCompareOptions CompareInfo { get; set; }
+        public override DbType DbType { get; set; }
+        public override ParameterDirection Direction { get; set; }
+        public override bool IsNullable { get; set; }
+        public int LocaleId { get; set; }
+        public int Offset { get; set; }
+        public override string ParameterName { get; set; }
+        public byte Precision { get; set; }
+        public byte Scale { get; set; }
+        public override int Size { get; set; }
+        public override string SourceColumn { get; set; }
+        public override bool SourceColumnNullMapping { get; set; }
+        public override DataRowVersion SourceVersion { get; set; }
+        public SqlDbType SqlDbType { get; set; }
+        public object SqlValue { get; set; }
+        public string TypeName { get; set; }
+        public string UdtTypeName { get; set; }
+        public override object Value { get; set; }
+        public string XmlSchemaCollectionDatabase { get; set; }
+        public string XmlSchemaCollectionName { get; set; }
+        public string XmlSchemaCollectionOwningSchema { get; set; }
+        public override void ResetDbType();
+        public void ResetSqlDbType();
+        object System.ICloneable.Clone();
+        public override string ToString();
+    }
+    public sealed class SqlParameterCollection : DbParameterCollection {
+        public override int Count { get; }
+        public override bool IsFixedSize { get; }
+        public override bool IsReadOnly { get; }
+        public SqlParameter this[int index] { get; set; }
+        public SqlParameter this[string parameterName] { get; set; }
+        public override object SyncRoot { get; }
+        public override int Add(object value);
+        public SqlParameter Add(SqlParameter value);
+        public SqlParameter Add(string parameterName, SqlDbType sqlDbType);
+        public SqlParameter Add(string parameterName, SqlDbType sqlDbType, int size);
+        public SqlParameter Add(string parameterName, SqlDbType sqlDbType, int size, string sourceColumn);
+        public override void AddRange(Array values);
+        public void AddRange(SqlParameter[] values);
+        public SqlParameter AddWithValue(string parameterName, object value);
+        public override void Clear();
+        public override bool Contains(object value);
+        public bool Contains(SqlParameter value);
+        public override bool Contains(string value);
+        public override void CopyTo(Array array, int index);
+        public void CopyTo(SqlParameter[] array, int index);
+        public override IEnumerator GetEnumerator();
+        public override int IndexOf(object value);
+        public int IndexOf(SqlParameter value);
+        public override int IndexOf(string parameterName);
+        public override void Insert(int index, object value);
+        public void Insert(int index, SqlParameter value);
+        public override void Remove(object value);
+        public void Remove(SqlParameter value);
+        public override void RemoveAt(int index);
+        public override void RemoveAt(string parameterName);
+    }
+    public class SqlRowsCopiedEventArgs : EventArgs {
+        public SqlRowsCopiedEventArgs(long rowsCopied);
+        public bool Abort { get; set; }
+        public long RowsCopied { get; }
+    }
+    public delegate void SqlRowsCopiedEventHandler(object sender, SqlRowsCopiedEventArgs e); {
+        public SqlRowsCopiedEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, SqlRowsCopiedEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, SqlRowsCopiedEventArgs e);
+    }
+    public sealed class SqlRowUpdatedEventArgs : RowUpdatedEventArgs {
+        public SqlRowUpdatedEventArgs(DataRow row, IDbCommand command, StatementType statementType, DataTableMapping tableMapping);
+        public SqlCommand Command { get; }
+    }
+    public delegate void SqlRowUpdatedEventHandler(object sender, SqlRowUpdatedEventArgs e); {
+        public SqlRowUpdatedEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, SqlRowUpdatedEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, SqlRowUpdatedEventArgs e);
+    }
+    public sealed class SqlRowUpdatingEventArgs : RowUpdatingEventArgs {
+        public SqlRowUpdatingEventArgs(DataRow row, IDbCommand command, StatementType statementType, DataTableMapping tableMapping);
+        public SqlCommand Command { get; set; }
+    }
+    public delegate void SqlRowUpdatingEventHandler(object sender, SqlRowUpdatingEventArgs e); {
+        public SqlRowUpdatingEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, SqlRowUpdatingEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, SqlRowUpdatingEventArgs e);
+    }
+    public sealed class SqlTransaction : DbTransaction {
+        public SqlConnection Connection { get; }
+        public override IsolationLevel IsolationLevel { get; }
+        public override void Commit();
+        public override void Rollback();
+        public void Rollback(string transactionName);
+        public void Save(string savePointName);
+    }
+}
 namespace System.Diagnostics {
+    public class CounterCreationData {
+        public CounterCreationData();
+        public CounterCreationData(string counterName, string counterHelp, PerformanceCounterType counterType);
+        public string CounterHelp { get; set; }
+        public string CounterName { get; set; }
+        public PerformanceCounterType CounterType { get; set; }
+    }
+    public class CounterCreationDataCollection : CollectionBase {
+        public CounterCreationDataCollection();
+        public CounterCreationDataCollection(CounterCreationDataCollection value);
+        public CounterCreationDataCollection(CounterCreationData[] value);
+        public CounterCreationData this[int index] { get; set; }
+        public int Add(CounterCreationData value);
+        public void AddRange(CounterCreationDataCollection value);
+        public void AddRange(CounterCreationData[] value);
+        public bool Contains(CounterCreationData value);
+        public void CopyTo(CounterCreationData[] array, int index);
+        public int IndexOf(CounterCreationData value);
+        public void Insert(int index, CounterCreationData value);
+        protected override void OnValidate(object value);
+        public virtual void Remove(CounterCreationData value);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct CounterSample {
+        public static CounterSample Empty;
+        public CounterSample(long rawValue, long baseValue, long counterFrequency, long systemFrequency, long timeStamp, long timeStamp100nSec, PerformanceCounterType counterType);
+        public CounterSample(long rawValue, long baseValue, long counterFrequency, long systemFrequency, long timeStamp, long timeStamp100nSec, PerformanceCounterType counterType, long counterTimeStamp);
+        public long BaseValue { get; }
+        public long CounterFrequency { get; }
+        public long CounterTimeStamp { get; }
+        public PerformanceCounterType CounterType { get; }
+        public long RawValue { get; }
+        public long SystemFrequency { get; }
+        public long TimeStamp { get; }
+        public long TimeStamp100nSec { get; }
+        public static float Calculate(CounterSample counterSample);
+        public static float Calculate(CounterSample counterSample, CounterSample nextCounterSample);
+        public bool Equals(CounterSample sample);
+        public override bool Equals(object o);
+        public override int GetHashCode();
+        public static bool operator ==(CounterSample a, CounterSample b);
+        public static bool operator !=(CounterSample a, CounterSample b);
+    }
+    public static class CounterSampleCalculator {
+        public static float ComputeCounterValue(CounterSample newSample);
+        public static float ComputeCounterValue(CounterSample oldSample, CounterSample newSample);
+    }
+    public class EntryWrittenEventArgs : EventArgs {
+        public EntryWrittenEventArgs();
+        public EntryWrittenEventArgs(EventLogEntry entry);
+        public EventLogEntry Entry { get; }
+    }
+    public delegate void EntryWrittenEventHandler(object sender, EntryWrittenEventArgs e); {
+        public EntryWrittenEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, EntryWrittenEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, EntryWrittenEventArgs e);
+    }
+    public class EventInstance {
+        public EventInstance(long instanceId, int categoryId);
+        public EventInstance(long instanceId, int categoryId, EventLogEntryType entryType);
+        public int CategoryId { get; set; }
+        public EventLogEntryType EntryType { get; set; }
+        public long InstanceId { get; set; }
+    }
+    public class EventLog : Component, ISupportInitialize {
+        public EventLog();
+        public EventLog(string logName);
+        public EventLog(string logName, string machineName);
+        public EventLog(string logName, string machineName, string source);
+        public bool EnableRaisingEvents { get; set; }
+        public EventLogEntryCollection Entries { get; }
+        public string Log { get; set; }
+        public string LogDisplayName { get; }
+        public string MachineName { get; set; }
+        public long MaximumKilobytes { get; set; }
+        public int MinimumRetentionDays { get; }
+        public OverflowAction OverflowAction { get; }
+        public string Source { get; set; }
+        public ISynchronizeInvoke SynchronizingObject { get; set; }
+        public void BeginInit();
+        public void Clear();
+        public void Close();
+        public static void CreateEventSource(EventSourceCreationData sourceData);
+        public static void CreateEventSource(string source, string logName);
+        public static void CreateEventSource(string source, string logName, string machineName);
+        public static void Delete(string logName);
+        public static void Delete(string logName, string machineName);
+        public static void DeleteEventSource(string source);
+        public static void DeleteEventSource(string source, string machineName);
+        protected override void Dispose(bool disposing);
+        public void EndInit();
+        public static bool Exists(string logName);
+        public static bool Exists(string logName, string machineName);
+        public static EventLog[] GetEventLogs();
+        public static EventLog[] GetEventLogs(string machineName);
+        public static string LogNameFromSourceName(string source, string machineName);
+        public void ModifyOverflowPolicy(OverflowAction action, int retentionDays);
+        public void RegisterDisplayName(string resourceFile, long resourceId);
+        public static bool SourceExists(string source);
+        public static bool SourceExists(string source, string machineName);
+        public void WriteEntry(string message);
+        public void WriteEntry(string message, EventLogEntryType type);
+        public void WriteEntry(string message, EventLogEntryType type, int eventID);
+        public void WriteEntry(string message, EventLogEntryType type, int eventID, short category);
+        public void WriteEntry(string message, EventLogEntryType type, int eventID, short category, byte[] rawData);
+        public static void WriteEntry(string source, string message);
+        public static void WriteEntry(string source, string message, EventLogEntryType type);
+        public static void WriteEntry(string source, string message, EventLogEntryType type, int eventID);
+        public static void WriteEntry(string source, string message, EventLogEntryType type, int eventID, short category);
+        public static void WriteEntry(string source, string message, EventLogEntryType type, int eventID, short category, byte[] rawData);
+        public void WriteEvent(EventInstance instance, byte[] data, params object[] values);
+        public void WriteEvent(EventInstance instance, params object[] values);
+        public static void WriteEvent(string source, EventInstance instance, byte[] data, params object[] values);
+        public static void WriteEvent(string source, EventInstance instance, params object[] values);
+        public event EntryWrittenEventHandler EntryWritten;
+    }
+    public sealed class EventLogEntry : Component, ISerializable {
+        public string Category { get; }
+        public short CategoryNumber { get; }
+        public byte[] Data { get; }
+        public EventLogEntryType EntryType { get; }
+        public int EventID { get; }
+        public int Index { get; }
+        public long InstanceId { get; }
+        public string MachineName { get; }
+        public string Message { get; }
+        public string[] ReplacementStrings { get; }
+        public string Source { get; }
+        public DateTime TimeGenerated { get; }
+        public DateTime TimeWritten { get; }
+        public string UserName { get; }
+        public bool Equals(EventLogEntry otherEntry);
+        void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
+    }
+    public class EventLogEntryCollection : ICollection, IEnumerable {
+        public int Count { get; }
+        public virtual EventLogEntry this[int index] { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public void CopyTo(EventLogEntry[] entries, int index);
+        public IEnumerator GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        get;
+        get;
+    }
+    public enum EventLogEntryType {
+        Error = 1,
+        FailureAudit = 16,
+        Information = 4,
+        SuccessAudit = 8,
+        Warning = 2,
+    }
+    public sealed class EventLogPermission : ResourcePermissionBase {
+        public EventLogPermission();
+        public EventLogPermission(EventLogPermissionAccess permissionAccess, string machineName);
+        public EventLogPermission(EventLogPermissionEntry[] permissionAccessEntries);
+        public EventLogPermission(PermissionState state);
+        public EventLogPermissionEntryCollection PermissionEntries { get; }
+    }
+    public enum EventLogPermissionAccess {
+        Administer = 48,
+        Audit = 10,
+        Browse = 2,
+        Instrument = 6,
+        None = 0,
+        Write = 16,
+    }
+    public class EventLogPermissionAttribute : CodeAccessSecurityAttribute {
+        public EventLogPermissionAttribute(SecurityAction action);
+        public string MachineName { get; set; }
+        public EventLogPermissionAccess PermissionAccess { get; set; }
+        public override IPermission CreatePermission();
+    }
+    public class EventLogPermissionEntry {
+        public EventLogPermissionEntry(EventLogPermissionAccess permissionAccess, string machineName);
+        public string MachineName { get; }
+        public EventLogPermissionAccess PermissionAccess { get; }
+    }
+    public class EventLogPermissionEntryCollection : CollectionBase {
+        public EventLogPermissionEntry this[int index] { get; set; }
+        public int Add(EventLogPermissionEntry value);
+        public void AddRange(EventLogPermissionEntryCollection value);
+        public void AddRange(EventLogPermissionEntry[] value);
+        public bool Contains(EventLogPermissionEntry value);
+        public void CopyTo(EventLogPermissionEntry[] array, int index);
+        public int IndexOf(EventLogPermissionEntry value);
+        public void Insert(int index, EventLogPermissionEntry value);
+        protected override void OnClear();
+        protected override void OnInsert(int index, object value);
+        protected override void OnRemove(int index, object value);
+        protected override void OnSet(int index, object oldValue, object newValue);
+        public void Remove(EventLogPermissionEntry value);
+    }
+    public class EventSourceCreationData {
+        public EventSourceCreationData(string source, string logName);
+        public int CategoryCount { get; set; }
+        public string CategoryResourceFile { get; set; }
+        public string LogName { get; set; }
+        public string MachineName { get; set; }
+        public string MessageResourceFile { get; set; }
+        public string ParameterResourceFile { get; set; }
+        public string Source { get; set; }
+    }
+    public interface ICollectData {
+        void CloseData();
+        void CollectData(int id, IntPtr valueName, IntPtr data, int totalBytes, out IntPtr res);
+    }
+    public class InstanceData {
+        public InstanceData(string instanceName, CounterSample sample);
+        public string InstanceName { get; }
+        public long RawValue { get; }
+        public CounterSample Sample { get; }
+    }
+    public class InstanceDataCollection : DictionaryBase {
+        public InstanceDataCollection(string counterName);
+        public string CounterName { get; }
+        public InstanceData this[string instanceName] { get; }
+        public ICollection Keys { get; }
+        public ICollection Values { get; }
+        public bool Contains(string instanceName);
+        public void CopyTo(InstanceData[] instances, int index);
+    }
+    public class InstanceDataCollectionCollection : DictionaryBase {
+        public InstanceDataCollectionCollection();
+        public InstanceDataCollection this[string counterName] { get; }
+        public ICollection Keys { get; }
+        public ICollection Values { get; }
+        public bool Contains(string counterName);
+        public void CopyTo(InstanceDataCollection[] counters, int index);
+    }
+    public enum OverflowAction {
+        DoNotOverwrite = -1,
+        OverwriteAsNeeded = 0,
+        OverwriteOlder = 1,
+    }
+    public sealed class PerformanceCounter : Component, ISupportInitialize {
+        public static int DefaultFileMappingSize;
+        public PerformanceCounter();
+        public PerformanceCounter(string categoryName, string counterName);
+        public PerformanceCounter(string categoryName, string counterName, bool readOnly);
+        public PerformanceCounter(string categoryName, string counterName, string instanceName);
+        public PerformanceCounter(string categoryName, string counterName, string instanceName, bool readOnly);
+        public PerformanceCounter(string categoryName, string counterName, string instanceName, string machineName);
+        public string CategoryName { get; set; }
+        public string CounterHelp { get; }
+        public string CounterName { get; set; }
+        public PerformanceCounterType CounterType { get; }
+        public PerformanceCounterInstanceLifetime InstanceLifetime { get; set; }
+        public string InstanceName { get; set; }
+        public string MachineName { get; set; }
+        public long RawValue { get; set; }
+        public bool ReadOnly { get; set; }
+        public void BeginInit();
+        public void Close();
+        public static void CloseSharedResources();
+        public long Decrement();
+        public void EndInit();
+        public long Increment();
+        public long IncrementBy(long value);
+        public CounterSample NextSample();
+        public float NextValue();
+        public void RemoveInstance();
+    }
+    public sealed class PerformanceCounterCategory {
+        public PerformanceCounterCategory();
+        public PerformanceCounterCategory(string categoryName);
+        public PerformanceCounterCategory(string categoryName, string machineName);
+        public string CategoryHelp { get; }
+        public string CategoryName { get; set; }
+        public PerformanceCounterCategoryType CategoryType { get; }
+        public string MachineName { get; set; }
+        public bool CounterExists(string counterName);
+        public static bool CounterExists(string counterName, string categoryName);
+        public static bool CounterExists(string counterName, string categoryName, string machineName);
+        public static PerformanceCounterCategory Create(string categoryName, string categoryHelp, CounterCreationDataCollection counterData);
+        public static PerformanceCounterCategory Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, CounterCreationDataCollection counterData);
+        public static PerformanceCounterCategory Create(string categoryName, string categoryHelp, PerformanceCounterCategoryType categoryType, string counterName, string counterHelp);
+        public static PerformanceCounterCategory Create(string categoryName, string categoryHelp, string counterName, string counterHelp);
+        public static void Delete(string categoryName);
+        public static bool Exists(string categoryName);
+        public static bool Exists(string categoryName, string machineName);
+        public static PerformanceCounterCategory[] GetCategories();
+        public static PerformanceCounterCategory[] GetCategories(string machineName);
+        public PerformanceCounter[] GetCounters();
+        public PerformanceCounter[] GetCounters(string instanceName);
+        public string[] GetInstanceNames();
+        public bool InstanceExists(string instanceName);
+        public static bool InstanceExists(string instanceName, string categoryName);
+        public static bool InstanceExists(string instanceName, string categoryName, string machineName);
+        public InstanceDataCollectionCollection ReadCategory();
+    }
+    public enum PerformanceCounterCategoryType {
+        MultiInstance = 1,
+        SingleInstance = 0,
+        Unknown = -1,
+    }
+    public enum PerformanceCounterInstanceLifetime {
+        Global = 0,
+        Process = 1,
+    }
+    public sealed class PerformanceCounterManager : ICollectData {
+        public PerformanceCounterManager();
+        void System.Diagnostics.ICollectData.CloseData();
+        void System.Diagnostics.ICollectData.CollectData(int callIdx, IntPtr valueNamePtr, IntPtr dataPtr, int totalBytes, out IntPtr res);
+    }
+    public sealed class PerformanceCounterPermission : ResourcePermissionBase {
+        public PerformanceCounterPermission();
+        public PerformanceCounterPermission(PerformanceCounterPermissionAccess permissionAccess, string machineName, string categoryName);
+        public PerformanceCounterPermission(PerformanceCounterPermissionEntry[] permissionAccessEntries);
+        public PerformanceCounterPermission(PermissionState state);
+        public PerformanceCounterPermissionEntryCollection PermissionEntries { get; }
+    }
+    public enum PerformanceCounterPermissionAccess {
+        Administer = 7,
+        Browse = 1,
+        Instrument = 3,
+        None = 0,
+        Read = 1,
+        Write = 2,
+    }
+    public class PerformanceCounterPermissionAttribute : CodeAccessSecurityAttribute {
+        public PerformanceCounterPermissionAttribute(SecurityAction action);
+        public string CategoryName { get; set; }
+        public string MachineName { get; set; }
+        public PerformanceCounterPermissionAccess PermissionAccess { get; set; }
+        public override IPermission CreatePermission();
+    }
+    public class PerformanceCounterPermissionEntry {
+        public PerformanceCounterPermissionEntry(PerformanceCounterPermissionAccess permissionAccess, string machineName, string categoryName);
+        public string CategoryName { get; }
+        public string MachineName { get; }
+        public PerformanceCounterPermissionAccess PermissionAccess { get; }
+    }
+    public class PerformanceCounterPermissionEntryCollection : CollectionBase {
+        public PerformanceCounterPermissionEntry this[int index] { get; set; }
+        public int Add(PerformanceCounterPermissionEntry value);
+        public void AddRange(PerformanceCounterPermissionEntryCollection value);
+        public void AddRange(PerformanceCounterPermissionEntry[] value);
+        public bool Contains(PerformanceCounterPermissionEntry value);
+        public void CopyTo(PerformanceCounterPermissionEntry[] array, int index);
+        public int IndexOf(PerformanceCounterPermissionEntry value);
+        public void Insert(int index, PerformanceCounterPermissionEntry value);
+        protected override void OnClear();
+        protected override void OnInsert(int index, object value);
+        protected override void OnRemove(int index, object value);
+        protected override void OnSet(int index, object oldValue, object newValue);
+        public void Remove(PerformanceCounterPermissionEntry value);
+    }
+    public enum PerformanceCounterType {
+        AverageBase = 1073939458,
+        AverageCount64 = 1073874176,
+        AverageTimer32 = 805438464,
+        CounterDelta32 = 4195328,
+        CounterDelta64 = 4195584,
+        CounterMultiBase = 1107494144,
+        CounterMultiTimer = 574686464,
+        CounterMultiTimer100Ns = 575735040,
+        CounterMultiTimer100NsInverse = 592512256,
+        CounterMultiTimerInverse = 591463680,
+        CounterTimer = 541132032,
+        CounterTimerInverse = 557909248,
+        CountPerTimeInterval32 = 4523008,
+        CountPerTimeInterval64 = 4523264,
+        ElapsedTime = 807666944,
+        NumberOfItems32 = 65536,
+        NumberOfItems64 = 65792,
+        NumberOfItemsHEX32 = 0,
+        NumberOfItemsHEX64 = 256,
+        RateOfCountsPerSecond32 = 272696320,
+        RateOfCountsPerSecond64 = 272696576,
+        RawBase = 1073939459,
+        RawFraction = 537003008,
+        SampleBase = 1073939457,
+        SampleCounter = 4260864,
+        SampleFraction = 549585920,
+        Timer100Ns = 542180608,
+        Timer100NsInverse = 558957824,
+    }
     public sealed class ProcessStartInfo {
+        public Encoding StandardInputEncoding { get; set; }
     }
+    public abstract class RemoteExecutorTestBase : FileCleanupTestBase {
+        public sealed class RemoteInvokeHandle : IDisposable {
+            public RemoteInvokeHandle(Process process, RemoteInvokeOptions options, string assemblyName, string className, string methodName);
+            public RemoteInvokeOptions Options { get; }
+            public Process Process { get; set; }
+            public void Dispose();
+        }
+        public const int FailWaitTimeoutMilliseconds = 60000;
+        protected static readonly string HostRunner;
+        protected static readonly string HostRunnerName;
+        public const int SuccessExitCode = 42;
+        protected static readonly string TestConsoleApp;
+        protected RemoteExecutorTestBase();
+        public static RemoteExecutorTestBase.RemoteInvokeHandle RemoteInvoke(Action method, RemoteInvokeOptions options=null);
+        public static RemoteExecutorTestBase.RemoteInvokeHandle RemoteInvoke(Func<int> method, RemoteInvokeOptions options=null);
+        public static RemoteExecutorTestBase.RemoteInvokeHandle RemoteInvoke(Func<Task<int>> method, RemoteInvokeOptions options=null);
+        public static RemoteExecutorTestBase.RemoteInvokeHandle RemoteInvoke(Func<string, int> method, string arg, RemoteInvokeOptions options=null);
+        public static RemoteExecutorTestBase.RemoteInvokeHandle RemoteInvoke(Func<string, Task<int>> method, string arg, RemoteInvokeOptions options=null);
+        public static RemoteExecutorTestBase.RemoteInvokeHandle RemoteInvoke(Func<string, string, int> method, string arg1, string arg2, RemoteInvokeOptions options=null);
+        public static RemoteExecutorTestBase.RemoteInvokeHandle RemoteInvoke(Func<string, string, Task<int>> method, string arg1, string arg2, RemoteInvokeOptions options=null);
+        public static RemoteExecutorTestBase.RemoteInvokeHandle RemoteInvoke(Func<string, string, string, int> method, string arg1, string arg2, string arg3, RemoteInvokeOptions options=null);
+        public static RemoteExecutorTestBase.RemoteInvokeHandle RemoteInvoke(Func<string, string, string, string, int> method, string arg1, string arg2, string arg3, string arg4, RemoteInvokeOptions options=null);
+        public static RemoteExecutorTestBase.RemoteInvokeHandle RemoteInvoke(Func<string, string, string, string, string, int> method, string arg1, string arg2, string arg3, string arg4, string arg5, RemoteInvokeOptions options=null);
+        public static RemoteExecutorTestBase.RemoteInvokeHandle RemoteInvokeRaw(Delegate method, string unparsedArg, RemoteInvokeOptions options=null);
+    }
+    public sealed class RemoteInvokeOptions {
+        public RemoteInvokeOptions();
+        public bool CheckExitCode { get; set; }
+        public bool EnableProfiling { get; set; }
+        public string ExceptionFile { get; }
+        public int ExpectedExitCode { get; set; }
+        public bool RunAsSudo { get; set; }
+        public bool Start { get; set; }
+        public ProcessStartInfo StartInfo { get; set; }
+        public int TimeOut { get; set; }
+    }
 }
 namespace System.Diagnostics.Tracing {
-    public class EventCounter {
+    public class EventCounter : IDisposable {
+        public void Dispose();
     }
 }
+namespace System.DirectoryServices {
+    public class ActiveDirectoryAccessRule : ObjectAccessRule {
+        public ActiveDirectoryAccessRule(IdentityReference identity, ActiveDirectoryRights adRights, AccessControlType type);
+        public ActiveDirectoryAccessRule(IdentityReference identity, ActiveDirectoryRights adRights, AccessControlType type, ActiveDirectorySecurityInheritance inheritanceType);
+        public ActiveDirectoryAccessRule(IdentityReference identity, ActiveDirectoryRights adRights, AccessControlType type, ActiveDirectorySecurityInheritance inheritanceType, Guid inheritedObjectType);
+        public ActiveDirectoryAccessRule(IdentityReference identity, ActiveDirectoryRights adRights, AccessControlType type, Guid objectType);
+        public ActiveDirectoryAccessRule(IdentityReference identity, ActiveDirectoryRights adRights, AccessControlType type, Guid objectType, ActiveDirectorySecurityInheritance inheritanceType);
+        public ActiveDirectoryAccessRule(IdentityReference identity, ActiveDirectoryRights adRights, AccessControlType type, Guid objectType, ActiveDirectorySecurityInheritance inheritanceType, Guid inheritedObjectType);
+        public ActiveDirectoryRights ActiveDirectoryRights { get; }
+        public ActiveDirectorySecurityInheritance InheritanceType { get; }
+    }
+    public class ActiveDirectoryAuditRule : ObjectAuditRule {
+        public ActiveDirectoryAuditRule(IdentityReference identity, ActiveDirectoryRights adRights, AuditFlags auditFlags);
+        public ActiveDirectoryAuditRule(IdentityReference identity, ActiveDirectoryRights adRights, AuditFlags auditFlags, ActiveDirectorySecurityInheritance inheritanceType);
+        public ActiveDirectoryAuditRule(IdentityReference identity, ActiveDirectoryRights adRights, AuditFlags auditFlags, ActiveDirectorySecurityInheritance inheritanceType, Guid inheritedObjectType);
+        public ActiveDirectoryAuditRule(IdentityReference identity, ActiveDirectoryRights adRights, AuditFlags auditFlags, Guid objectType);
+        public ActiveDirectoryAuditRule(IdentityReference identity, ActiveDirectoryRights adRights, AuditFlags auditFlags, Guid objectType, ActiveDirectorySecurityInheritance inheritanceType);
+        public ActiveDirectoryAuditRule(IdentityReference identity, ActiveDirectoryRights adRights, AuditFlags auditFlags, Guid objectType, ActiveDirectorySecurityInheritance inheritanceType, Guid inheritedObjectType);
+        public ActiveDirectoryRights ActiveDirectoryRights { get; }
+        public ActiveDirectorySecurityInheritance InheritanceType { get; }
+    }
+    public enum ActiveDirectoryRights {
+        AccessSystemSecurity = 16777216,
+        CreateChild = 1,
+        Delete = 65536,
+        DeleteChild = 2,
+        DeleteTree = 64,
+        ExtendedRight = 256,
+        GenericAll = 983551,
+        GenericExecute = 131076,
+        GenericRead = 131220,
+        GenericWrite = 131112,
+        ListChildren = 4,
+        ListObject = 128,
+        ReadControl = 131072,
+        ReadProperty = 16,
+        Self = 8,
+        Synchronize = 1048576,
+        WriteDacl = 262144,
+        WriteOwner = 524288,
+        WriteProperty = 32,
+    }
+    public class ActiveDirectorySecurity : DirectoryObjectSecurity {
+        public ActiveDirectorySecurity();
+        public override Type AccessRightType { get; }
+        public override Type AccessRuleType { get; }
+        public override Type AuditRuleType { get; }
+        public sealed override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public sealed override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type, Guid objectGuid, Guid inheritedObjectGuid);
+        public void AddAccessRule(ActiveDirectoryAccessRule rule);
+        public void AddAuditRule(ActiveDirectoryAuditRule rule);
+        public sealed override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public sealed override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags, Guid objectGuid, Guid inheritedObjectGuid);
+        public override bool ModifyAccessRule(AccessControlModification modification, AccessRule rule, out bool modified);
+        public override bool ModifyAuditRule(AccessControlModification modification, AuditRule rule, out bool modified);
+        public override void PurgeAccessRules(IdentityReference identity);
+        public override void PurgeAuditRules(IdentityReference identity);
+        public void RemoveAccess(IdentityReference identity, AccessControlType type);
+        public bool RemoveAccessRule(ActiveDirectoryAccessRule rule);
+        public void RemoveAccessRuleSpecific(ActiveDirectoryAccessRule rule);
+        public void RemoveAudit(IdentityReference identity);
+        public bool RemoveAuditRule(ActiveDirectoryAuditRule rule);
+        public void RemoveAuditRuleSpecific(ActiveDirectoryAuditRule rule);
+        public void ResetAccessRule(ActiveDirectoryAccessRule rule);
+        public void SetAccessRule(ActiveDirectoryAccessRule rule);
+        public void SetAuditRule(ActiveDirectoryAuditRule rule);
+    }
+    public enum ActiveDirectorySecurityInheritance {
+        All = 1,
+        Children = 4,
+        Descendents = 2,
+        None = 0,
+        SelfAndChildren = 3,
+    }
+    public enum AuthenticationTypes {
+        Anonymous = 16,
+        Delegation = 256,
+        Encryption = 2,
+        FastBind = 32,
+        None = 0,
+        ReadonlyServer = 4,
+        Sealing = 128,
+        Secure = 1,
+        SecureSocketsLayer = 2,
+        ServerBind = 512,
+        Signing = 64,
+    }
+    public sealed class CreateChildAccessRule : ActiveDirectoryAccessRule {
+        public CreateChildAccessRule(IdentityReference identity, AccessControlType type);
+        public CreateChildAccessRule(IdentityReference identity, AccessControlType type, ActiveDirectorySecurityInheritance inheritanceType);
+        public CreateChildAccessRule(IdentityReference identity, AccessControlType type, ActiveDirectorySecurityInheritance inheritanceType, Guid inheritedObjectType);
+        public CreateChildAccessRule(IdentityReference identity, AccessControlType type, Guid childType);
+        public CreateChildAccessRule(IdentityReference identity, AccessControlType type, Guid childType, ActiveDirectorySecurityInheritance inheritanceType);
+        public CreateChildAccessRule(IdentityReference identity, AccessControlType type, Guid childType, ActiveDirectorySecurityInheritance inheritanceType, Guid inheritedObjectType);
+    }
+    public sealed class DeleteChildAccessRule : ActiveDirectoryAccessRule {
+        public DeleteChildAccessRule(IdentityReference identity, AccessControlType type);
+        public DeleteChildAccessRule(IdentityReference identity, AccessControlType type, ActiveDirectorySecurityInheritance inheritanceType);
+        public DeleteChildAccessRule(IdentityReference identity, AccessControlType type, ActiveDirectorySecurityInheritance inheritanceType, Guid inheritedObjectType);
+        public DeleteChildAccessRule(IdentityReference identity, AccessControlType type, Guid childType);
+        public DeleteChildAccessRule(IdentityReference identity, AccessControlType type, Guid childType, ActiveDirectorySecurityInheritance inheritanceType);
+        public DeleteChildAccessRule(IdentityReference identity, AccessControlType type, Guid childType, ActiveDirectorySecurityInheritance inheritanceType, Guid inheritedObjectType);
+    }
+    public sealed class DeleteTreeAccessRule : ActiveDirectoryAccessRule {
+        public DeleteTreeAccessRule(IdentityReference identity, AccessControlType type);
+        public DeleteTreeAccessRule(IdentityReference identity, AccessControlType type, ActiveDirectorySecurityInheritance inheritanceType);
+        public DeleteTreeAccessRule(IdentityReference identity, AccessControlType type, ActiveDirectorySecurityInheritance inheritanceType, Guid inheritedObjectType);
+    }
+    public enum DereferenceAlias {
+        Always = 3,
+        FindingBaseObject = 2,
+        InSearching = 1,
+        Never = 0,
+    }
+    public class DirectoryEntries : IEnumerable {
+        public SchemaNameCollection SchemaFilter { get; }
+        public DirectoryEntry Add(string name, string schemaClassName);
+        public DirectoryEntry Find(string name);
+        public DirectoryEntry Find(string name, string schemaClassName);
+        public IEnumerator GetEnumerator();
+        public void Remove(DirectoryEntry entry);
+    }
+    public class DirectoryEntry : Component {
+        public DirectoryEntry();
+        public DirectoryEntry(object adsObject);
+        public DirectoryEntry(string path);
+        public DirectoryEntry(string path, string username, string password);
+        public DirectoryEntry(string path, string username, string password, AuthenticationTypes authenticationType);
+        public AuthenticationTypes AuthenticationType { get; set; }
+        public DirectoryEntries Children { get; }
+        public Guid Guid { get; }
+        public string Name { get; }
+        public string NativeGuid { get; }
+        public object NativeObject { get; }
+        public ActiveDirectorySecurity ObjectSecurity { get; set; }
+        public DirectoryEntryConfiguration Options { get; }
+        public DirectoryEntry Parent { get; }
+        public string Password { set; }
+        public string Path { get; set; }
+        public PropertyCollection Properties { get; }
+        public string SchemaClassName { get; }
+        public DirectoryEntry SchemaEntry { get; }
+        public bool UsePropertyCache { get; set; }
+        public string Username { get; set; }
+        public void Close();
+        public void CommitChanges();
+        public DirectoryEntry CopyTo(DirectoryEntry newParent);
+        public DirectoryEntry CopyTo(DirectoryEntry newParent, string newName);
+        public void DeleteTree();
+        protected override void Dispose(bool disposing);
+        public static bool Exists(string path);
+        public object Invoke(string methodName, params object[] args);
+        public object InvokeGet(string propertyName);
+        public void InvokeSet(string propertyName, params object[] args);
+        public void MoveTo(DirectoryEntry newParent);
+        public void MoveTo(DirectoryEntry newParent, string newName);
+        public void RefreshCache();
+        public void RefreshCache(string[] propertyNames);
+        public void Rename(string newName);
+    }
+    public class DirectoryEntryConfiguration {
+        public int PageSize { get; set; }
+        public PasswordEncodingMethod PasswordEncoding { get; set; }
+        public int PasswordPort { get; set; }
+        public ReferralChasingOption Referral { get; set; }
+        public SecurityMasks SecurityMasks { get; set; }
+        public string GetCurrentServerName();
+        public bool IsMutuallyAuthenticated();
+        public void SetUserNameQueryQuota(string accountName);
+    }
+    public class DirectorySearcher : Component {
+        public DirectorySearcher();
+        public DirectorySearcher(DirectoryEntry searchRoot);
+        public DirectorySearcher(DirectoryEntry searchRoot, string filter);
+        public DirectorySearcher(DirectoryEntry searchRoot, string filter, string[] propertiesToLoad);
+        public DirectorySearcher(DirectoryEntry searchRoot, string filter, string[] propertiesToLoad, SearchScope scope);
+        public DirectorySearcher(string filter);
+        public DirectorySearcher(string filter, string[] propertiesToLoad);
+        public DirectorySearcher(string filter, string[] propertiesToLoad, SearchScope scope);
+        public bool Asynchronous { get; set; }
+        public string AttributeScopeQuery { get; set; }
+        public bool CacheResults { get; set; }
+        public TimeSpan ClientTimeout { get; set; }
+        public DereferenceAlias DerefAlias { get; set; }
+        public DirectorySynchronization DirectorySynchronization { get; set; }
+        public ExtendedDN ExtendedDN { get; set; }
+        public string Filter { get; set; }
+        public int PageSize { get; set; }
+        public StringCollection PropertiesToLoad { get; }
+        public bool PropertyNamesOnly { get; set; }
+        public ReferralChasingOption ReferralChasing { get; set; }
+        public DirectoryEntry SearchRoot { get; set; }
+        public SearchScope SearchScope { get; set; }
+        public SecurityMasks SecurityMasks { get; set; }
+        public TimeSpan ServerPageTimeLimit { get; set; }
+        public TimeSpan ServerTimeLimit { get; set; }
+        public int SizeLimit { get; set; }
+        public SortOption Sort { get; set; }
+        public bool Tombstone { get; set; }
+        public DirectoryVirtualListView VirtualListView { get; set; }
+        protected override void Dispose(bool disposing);
+        public SearchResultCollection FindAll();
+        public SearchResult FindOne();
+    }
+    public class DirectoryServicesCOMException : COMException, ISerializable {
+        public DirectoryServicesCOMException();
+        protected DirectoryServicesCOMException(SerializationInfo info, StreamingContext context);
+        public DirectoryServicesCOMException(string message);
+        public DirectoryServicesCOMException(string message, Exception inner);
+        public int ExtendedError { get; }
+        public string ExtendedErrorMessage { get; }
+        public override void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
+    }
+    public class DirectorySynchronization {
+        public DirectorySynchronization();
+        public DirectorySynchronization(byte[] cookie);
+        public DirectorySynchronization(DirectorySynchronization sync);
+        public DirectorySynchronization(DirectorySynchronizationOptions option);
+        public DirectorySynchronization(DirectorySynchronizationOptions option, byte[] cookie);
+        public DirectorySynchronizationOptions Option { get; set; }
+        public DirectorySynchronization Copy();
+        public byte[] GetDirectorySynchronizationCookie();
+        public void ResetDirectorySynchronizationCookie();
+        public void ResetDirectorySynchronizationCookie(byte[] cookie);
+    }
+    public enum DirectorySynchronizationOptions : long {
+        IncrementalValues = (long)2147483648,
+        None = (long)0,
+        ObjectSecurity = (long)1,
+        ParentsFirst = (long)2048,
+        PublicDataOnly = (long)8192,
+    }
+    public class DirectoryVirtualListView {
+        public DirectoryVirtualListView();
+        public DirectoryVirtualListView(int afterCount);
+        public DirectoryVirtualListView(int beforeCount, int afterCount, int offset);
+        public DirectoryVirtualListView(int beforeCount, int afterCount, int offset, DirectoryVirtualListViewContext context);
+        public DirectoryVirtualListView(int beforeCount, int afterCount, string target);
+        public DirectoryVirtualListView(int beforeCount, int afterCount, string target, DirectoryVirtualListViewContext context);
+        public int AfterCount { get; set; }
+        public int ApproximateTotal { get; set; }
+        public int BeforeCount { get; set; }
+        public DirectoryVirtualListViewContext DirectoryVirtualListViewContext { get; set; }
+        public int Offset { get; set; }
+        public string Target { get; set; }
+        public int TargetPercentage { get; set; }
+    }
+    public class DirectoryVirtualListViewContext {
+        public DirectoryVirtualListViewContext();
+        public DirectoryVirtualListViewContext Copy();
+    }
+    public enum ExtendedDN {
+        HexString = 0,
+        None = -1,
+        Standard = 1,
+    }
+    public sealed class ExtendedRightAccessRule : ActiveDirectoryAccessRule {
+        public ExtendedRightAccessRule(IdentityReference identity, AccessControlType type);
+        public ExtendedRightAccessRule(IdentityReference identity, AccessControlType type, ActiveDirectorySecurityInheritance inheritanceType);
+        public ExtendedRightAccessRule(IdentityReference identity, AccessControlType type, ActiveDirectorySecurityInheritance inheritanceType, Guid inheritedObjectType);
+        public ExtendedRightAccessRule(IdentityReference identity, AccessControlType type, Guid extendedRightType);
+        public ExtendedRightAccessRule(IdentityReference identity, AccessControlType type, Guid extendedRightType, ActiveDirectorySecurityInheritance inheritanceType);
+        public ExtendedRightAccessRule(IdentityReference identity, AccessControlType type, Guid extendedRightType, ActiveDirectorySecurityInheritance inheritanceType, Guid inheritedObjectType);
+    }
+    public sealed class ListChildrenAccessRule : ActiveDirectoryAccessRule {
+        public ListChildrenAccessRule(IdentityReference identity, AccessControlType type);
+        public ListChildrenAccessRule(IdentityReference identity, AccessControlType type, ActiveDirectorySecurityInheritance inheritanceType);
+        public ListChildrenAccessRule(IdentityReference identity, AccessControlType type, ActiveDirectorySecurityInheritance inheritanceType, Guid inheritedObjectType);
+    }
+    public enum PasswordEncodingMethod {
+        PasswordEncodingClear = 1,
+        PasswordEncodingSsl = 0,
+    }
+    public enum PropertyAccess {
+        Read = 0,
+        Write = 1,
+    }
+    public sealed class PropertyAccessRule : ActiveDirectoryAccessRule {
+        public PropertyAccessRule(IdentityReference identity, AccessControlType type, PropertyAccess access);
+        public PropertyAccessRule(IdentityReference identity, AccessControlType type, PropertyAccess access, ActiveDirectorySecurityInheritance inheritanceType);
+        public PropertyAccessRule(IdentityReference identity, AccessControlType type, PropertyAccess access, ActiveDirectorySecurityInheritance inheritanceType, Guid inheritedObjectType);
+        public PropertyAccessRule(IdentityReference identity, AccessControlType type, PropertyAccess access, Guid propertyType);
+        public PropertyAccessRule(IdentityReference identity, AccessControlType type, PropertyAccess access, Guid propertyType, ActiveDirectorySecurityInheritance inheritanceType);
+        public PropertyAccessRule(IdentityReference identity, AccessControlType type, PropertyAccess access, Guid propertyType, ActiveDirectorySecurityInheritance inheritanceType, Guid inheritedObjectType);
+    }
+    public class PropertyCollection : ICollection, IDictionary, IEnumerable {
+        public int Count { get; }
+        public PropertyValueCollection this[string propertyName] { get; }
+        public ICollection PropertyNames { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IDictionary.IsFixedSize { get; }
+        bool System.Collections.IDictionary.IsReadOnly { get; }
+        object System.Collections.IDictionary.this[object key] { get; set; }
+        ICollection System.Collections.IDictionary.Keys { get; }
+        public ICollection Values { get; }
+        public bool Contains(string propertyName);
+        public void CopyTo(PropertyValueCollection[] array, int index);
+        public IDictionaryEnumerator GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        get;
+        get;
+        void System.Collections.IDictionary.Add(object key, object value);
+        void System.Collections.IDictionary.Clear();
+        bool System.Collections.IDictionary.Contains(object value);
+        get;
+        get;
+        get;
+        get;
+        void System.Collections.IDictionary.Remove(object key);
+        set;
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public sealed class PropertySetAccessRule : ActiveDirectoryAccessRule {
+        public PropertySetAccessRule(IdentityReference identity, AccessControlType type, PropertyAccess access, Guid propertySetType);
+        public PropertySetAccessRule(IdentityReference identity, AccessControlType type, PropertyAccess access, Guid propertySetType, ActiveDirectorySecurityInheritance inheritanceType);
+        public PropertySetAccessRule(IdentityReference identity, AccessControlType type, PropertyAccess access, Guid propertySetType, ActiveDirectorySecurityInheritance inheritanceType, Guid inheritedObjectType);
+    }
+    public class PropertyValueCollection : CollectionBase {
+        public object this[int index] { get; set; }
+        public string PropertyName { get; }
+        public object Value { get; set; }
+        public int Add(object value);
+        public void AddRange(object[] value);
+        public void AddRange(PropertyValueCollection value);
+        public bool Contains(object value);
+        public void CopyTo(object[] array, int index);
+        public int IndexOf(object value);
+        public void Insert(int index, object value);
+        protected override void OnClearComplete();
+        protected override void OnInsertComplete(int index, object value);
+        protected override void OnRemoveComplete(int index, object value);
+        protected override void OnSetComplete(int index, object oldValue, object newValue);
+        public void Remove(object value);
+    }
+    public enum ReferralChasingOption {
+        All = 96,
+        External = 64,
+        None = 0,
+        Subordinate = 32,
+    }
+    public class ResultPropertyCollection : DictionaryBase {
+        public ResultPropertyValueCollection this[string name] { get; }
+        public ICollection PropertyNames { get; }
+        public ICollection Values { get; }
+        public bool Contains(string propertyName);
+        public void CopyTo(ResultPropertyValueCollection[] array, int index);
+    }
+    public class ResultPropertyValueCollection : ReadOnlyCollectionBase {
+        public object this[int index] { get; }
+        public bool Contains(object value);
+        public void CopyTo(object[] values, int index);
+        public int IndexOf(object value);
+    }
+    public class SchemaNameCollection : ICollection, IEnumerable, IList {
+        public int Count { get; }
+        public string this[int index] { get; set; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public int Add(string value);
+        public void AddRange(SchemaNameCollection value);
+        public void AddRange(string[] value);
+        public void Clear();
+        public bool Contains(string value);
+        public void CopyTo(string[] stringArray, int index);
+        public IEnumerator GetEnumerator();
+        public int IndexOf(string value);
+        public void Insert(int index, string value);
+        public void Remove(string value);
+        public void RemoveAt(int index);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        get;
+        get;
+        int System.Collections.IList.Add(object value);
+        bool System.Collections.IList.Contains(object value);
+        get;
+        get;
+        get;
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+        set;
+    }
+    public class SearchResult {
+        public string Path { get; }
+        public ResultPropertyCollection Properties { get; }
+        public DirectoryEntry GetDirectoryEntry();
+    }
+    public class SearchResultCollection : MarshalByRefObject, ICollection, IDisposable, IEnumerable {
+        public int Count { get; }
+        public IntPtr Handle { get; }
+        public SearchResult this[int index] { get; }
+        public string[] PropertiesLoaded { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public bool Contains(SearchResult result);
+        public void CopyTo(SearchResult[] results, int index);
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        ~SearchResultCollection();
+        public IEnumerator GetEnumerator();
+        public int IndexOf(SearchResult result);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        get;
+        get;
+    }
+    public enum SearchScope {
+        Base = 0,
+        OneLevel = 1,
+        Subtree = 2,
+    }
+    public enum SecurityMasks {
+        Dacl = 4,
+        Group = 2,
+        None = 0,
+        Owner = 1,
+        Sacl = 8,
+    }
+    public enum SortDirection {
+        Ascending = 0,
+        Descending = 1,
+    }
+    public class SortOption {
+        public SortOption();
+        public SortOption(string propertyName, SortDirection direction);
+        public SortDirection Direction { get; set; }
+        public string PropertyName { get; set; }
+    }
+}
+namespace System.DirectoryServices.AccountManagement {
+    public class AdvancedFilters {
+        protected internal AdvancedFilters(Principal p);
+        public void AccountExpirationDate(DateTime expirationTime, MatchType match);
+        public void AccountLockoutTime(DateTime lockoutTime, MatchType match);
+        protected void AdvancedFilterSet(string attribute, object value, Type objectType, MatchType mt);
+        public void BadLogonCount(int badLogonCount, MatchType match);
+        public void LastBadPasswordAttempt(DateTime lastAttempt, MatchType match);
+        public void LastLogonTime(DateTime logonTime, MatchType match);
+        public void LastPasswordSetTime(DateTime passwordSetTime, MatchType match);
+    }
+    public class AuthenticablePrincipal : Principal {
+        protected internal AuthenticablePrincipal(PrincipalContext context);
+        protected internal AuthenticablePrincipal(PrincipalContext context, string samAccountName, string password, bool enabled);
+        public Nullable<DateTime> AccountExpirationDate { get; set; }
+        public Nullable<DateTime> AccountLockoutTime { get; }
+        public virtual AdvancedFilters AdvancedSearchFilter { get; }
+        public bool AllowReversiblePasswordEncryption { get; set; }
+        public int BadLogonCount { get; }
+        public X509Certificate2Collection Certificates { get; }
+        public bool DelegationPermitted { get; set; }
+        public Nullable<bool> Enabled { get; set; }
+        public string HomeDirectory { get; set; }
+        public string HomeDrive { get; set; }
+        public Nullable<DateTime> LastBadPasswordAttempt { get; }
+        public Nullable<DateTime> LastLogon { get; }
+        public Nullable<DateTime> LastPasswordSet { get; }
+        public bool PasswordNeverExpires { get; set; }
+        public bool PasswordNotRequired { get; set; }
+        public byte[] PermittedLogonTimes { get; set; }
+        public PrincipalValueCollection<string> PermittedWorkstations { get; }
+        public string ScriptPath { get; set; }
+        public bool SmartcardLogonRequired { get; set; }
+        public bool UserCannotChangePassword { get; set; }
+        public void ChangePassword(string oldPassword, string newPassword);
+        public void ExpirePasswordNow();
+        protected static PrincipalSearchResult<T> FindByBadPasswordAttempt<T>(PrincipalContext context, DateTime time, MatchType type);
+        public static PrincipalSearchResult<AuthenticablePrincipal> FindByBadPasswordAttempt(PrincipalContext context, DateTime time, MatchType type);
+        protected static PrincipalSearchResult<T> FindByExpirationTime<T>(PrincipalContext context, DateTime time, MatchType type);
+        public static PrincipalSearchResult<AuthenticablePrincipal> FindByExpirationTime(PrincipalContext context, DateTime time, MatchType type);
+        protected static PrincipalSearchResult<T> FindByLockoutTime<T>(PrincipalContext context, DateTime time, MatchType type);
+        public static PrincipalSearchResult<AuthenticablePrincipal> FindByLockoutTime(PrincipalContext context, DateTime time, MatchType type);
+        protected static PrincipalSearchResult<T> FindByLogonTime<T>(PrincipalContext context, DateTime time, MatchType type);
+        public static PrincipalSearchResult<AuthenticablePrincipal> FindByLogonTime(PrincipalContext context, DateTime time, MatchType type);
+        protected static PrincipalSearchResult<T> FindByPasswordSetTime<T>(PrincipalContext context, DateTime time, MatchType type);
+        public static PrincipalSearchResult<AuthenticablePrincipal> FindByPasswordSetTime(PrincipalContext context, DateTime time, MatchType type);
+        public bool IsAccountLockedOut();
+        public void RefreshExpiredPassword();
+        public void SetPassword(string newPassword);
+        public void UnlockAccount();
+    }
+    public class ComputerPrincipal : AuthenticablePrincipal {
+        public ComputerPrincipal(PrincipalContext context);
+        public ComputerPrincipal(PrincipalContext context, string samAccountName, string password, bool enabled);
+        public PrincipalValueCollection<string> ServicePrincipalNames { get; }
+        public static new PrincipalSearchResult<ComputerPrincipal> FindByBadPasswordAttempt(PrincipalContext context, DateTime time, MatchType type);
+        public static new PrincipalSearchResult<ComputerPrincipal> FindByExpirationTime(PrincipalContext context, DateTime time, MatchType type);
+        public static new ComputerPrincipal FindByIdentity(PrincipalContext context, IdentityType identityType, string identityValue);
+        public static new ComputerPrincipal FindByIdentity(PrincipalContext context, string identityValue);
+        public static new PrincipalSearchResult<ComputerPrincipal> FindByLockoutTime(PrincipalContext context, DateTime time, MatchType type);
+        public static new PrincipalSearchResult<ComputerPrincipal> FindByLogonTime(PrincipalContext context, DateTime time, MatchType type);
+        public static new PrincipalSearchResult<ComputerPrincipal> FindByPasswordSetTime(PrincipalContext context, DateTime time, MatchType type);
+    }
+    public enum ContextOptions {
+        Negotiate = 1,
+        Sealing = 16,
+        SecureSocketLayer = 4,
+        ServerBind = 32,
+        Signing = 8,
+        SimpleBind = 2,
+    }
+    public enum ContextType {
+        ApplicationDirectory = 2,
+        Domain = 1,
+        Machine = 0,
+    }
+    public sealed class DirectoryObjectClassAttribute : Attribute {
+        public DirectoryObjectClassAttribute(string objectClass);
+        public Nullable<ContextType> Context { get; }
+        public string ObjectClass { get; }
+    }
+    public sealed class DirectoryPropertyAttribute : Attribute {
+        public DirectoryPropertyAttribute(string schemaAttributeName);
+        public Nullable<ContextType> Context { get; set; }
+        public string SchemaAttributeName { get; }
+    }
+    public sealed class DirectoryRdnPrefixAttribute : Attribute {
+        public DirectoryRdnPrefixAttribute(string rdnPrefix);
+        public Nullable<ContextType> Context { get; }
+        public string RdnPrefix { get; }
+    }
+    public class GroupPrincipal : Principal {
+        public GroupPrincipal(PrincipalContext context);
+        public GroupPrincipal(PrincipalContext context, string samAccountName);
+        public Nullable<GroupScope> GroupScope { get; set; }
+        public Nullable<bool> IsSecurityGroup { get; set; }
+        public PrincipalCollection Members { get; }
+        public override void Dispose();
+        public static new GroupPrincipal FindByIdentity(PrincipalContext context, IdentityType identityType, string identityValue);
+        public static new GroupPrincipal FindByIdentity(PrincipalContext context, string identityValue);
+        public PrincipalSearchResult<Principal> GetMembers();
+        public PrincipalSearchResult<Principal> GetMembers(bool recursive);
+    }
+    public enum GroupScope {
+        Global = 1,
+        Local = 0,
+        Universal = 2,
+    }
+    public enum IdentityType {
+        DistinguishedName = 3,
+        Guid = 5,
+        Name = 1,
+        SamAccountName = 0,
+        Sid = 4,
+        UserPrincipalName = 2,
+    }
+    public enum MatchType {
+        Equals = 0,
+        GreaterThan = 2,
+        GreaterThanOrEquals = 3,
+        LessThan = 4,
+        LessThanOrEquals = 5,
+        NotEquals = 1,
+    }
+    public class MultipleMatchesException : PrincipalException {
+        public MultipleMatchesException();
+        protected MultipleMatchesException(SerializationInfo info, StreamingContext context);
+        public MultipleMatchesException(string message);
+        public MultipleMatchesException(string message, Exception innerException);
+    }
+    public class NoMatchingPrincipalException : PrincipalException {
+        public NoMatchingPrincipalException();
+        protected NoMatchingPrincipalException(SerializationInfo info, StreamingContext context);
+        public NoMatchingPrincipalException(string message);
+        public NoMatchingPrincipalException(string message, Exception innerException);
+    }
+    public class PasswordException : PrincipalException {
+        public PasswordException();
+        protected PasswordException(SerializationInfo info, StreamingContext context);
+        public PasswordException(string message);
+        public PasswordException(string message, Exception innerException);
+    }
+    public abstract class Principal : IDisposable {
+        protected Principal();
+        public PrincipalContext Context { get; }
+        protected internal PrincipalContext ContextRaw { get; set; }
+        public ContextType ContextType { get; }
+        public string Description { get; set; }
+        public string DisplayName { get; set; }
+        public string DistinguishedName { get; }
+        public Nullable<Guid> Guid { get; }
+        public string Name { get; set; }
+        public string SamAccountName { get; set; }
+        public SecurityIdentifier Sid { get; }
+        public string StructuralObjectClass { get; }
+        public string UserPrincipalName { get; set; }
+        protected void CheckDisposedOrDeleted();
+        public void Delete();
+        public virtual void Dispose();
+        public override bool Equals(object o);
+        protected object[] ExtensionGet(string attribute);
+        protected void ExtensionSet(string attribute, object value);
+        public static Principal FindByIdentity(PrincipalContext context, IdentityType identityType, string identityValue);
+        public static Principal FindByIdentity(PrincipalContext context, string identityValue);
+        protected static Principal FindByIdentityWithType(PrincipalContext context, Type principalType, IdentityType identityType, string identityValue);
+        protected static Principal FindByIdentityWithType(PrincipalContext context, Type principalType, string identityValue);
+        public PrincipalSearchResult<Principal> GetGroups();
+        public PrincipalSearchResult<Principal> GetGroups(PrincipalContext contextToQuery);
+        public override int GetHashCode();
+        public object GetUnderlyingObject();
+        public Type GetUnderlyingObjectType();
+        public bool IsMemberOf(GroupPrincipal group);
+        public bool IsMemberOf(PrincipalContext context, IdentityType identityType, string identityValue);
+        public void Save();
+        public void Save(PrincipalContext context);
+        public override string ToString();
+    }
+    public class PrincipalCollection : ICollection, ICollection<Principal>, IEnumerable, IEnumerable<Principal> {
+        public int Count { get; }
+        public bool IsReadOnly { get; }
+        public bool IsSynchronized { get; }
+        public object SyncRoot { get; }
+        int System.Collections.ICollection.Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public void Add(ComputerPrincipal computer);
+        public void Add(GroupPrincipal group);
+        public void Add(Principal principal);
+        public void Add(PrincipalContext context, IdentityType identityType, string identityValue);
+        public void Add(UserPrincipal user);
+        public void Clear();
+        public bool Contains(ComputerPrincipal computer);
+        public bool Contains(GroupPrincipal group);
+        public bool Contains(Principal principal);
+        public bool Contains(PrincipalContext context, IdentityType identityType, string identityValue);
+        public bool Contains(UserPrincipal user);
+        public void CopyTo(Principal[] array, int index);
+        public IEnumerator<Principal> GetEnumerator();
+        public bool Remove(ComputerPrincipal computer);
+        public bool Remove(GroupPrincipal group);
+        public bool Remove(Principal principal);
+        public bool Remove(PrincipalContext context, IdentityType identityType, string identityValue);
+        public bool Remove(UserPrincipal user);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public class PrincipalContext : IDisposable {
+        public PrincipalContext(ContextType contextType);
+        public PrincipalContext(ContextType contextType, string name);
+        public PrincipalContext(ContextType contextType, string name, string container);
+        public PrincipalContext(ContextType contextType, string name, string container, ContextOptions options);
+        public PrincipalContext(ContextType contextType, string name, string container, ContextOptions options, string userName, string password);
+        public PrincipalContext(ContextType contextType, string name, string userName, string password);
+        public PrincipalContext(ContextType contextType, string name, string container, string userName, string password);
+        public string ConnectedServer { get; }
+        public string Container { get; }
+        public ContextType ContextType { get; }
+        public string Name { get; }
+        public ContextOptions Options { get; }
+        public string UserName { get; }
+        public void Dispose();
+        public bool ValidateCredentials(string userName, string password);
+        public bool ValidateCredentials(string userName, string password, ContextOptions options);
+    }
+    public abstract class PrincipalException : SystemException {
+        protected PrincipalException(SerializationInfo info, StreamingContext context);
+    }
+    public class PrincipalExistsException : PrincipalException {
+        public PrincipalExistsException();
+        protected PrincipalExistsException(SerializationInfo info, StreamingContext context);
+        public PrincipalExistsException(string message);
+        public PrincipalExistsException(string message, Exception innerException);
+    }
+    public class PrincipalOperationException : PrincipalException {
+        public PrincipalOperationException();
+        protected PrincipalOperationException(SerializationInfo info, StreamingContext context);
+        public PrincipalOperationException(string message);
+        public PrincipalOperationException(string message, Exception innerException);
+        public PrincipalOperationException(string message, Exception innerException, int errorCode);
+        public PrincipalOperationException(string message, int errorCode);
+        public int ErrorCode { get; }
+        public override void GetObjectData(SerializationInfo info, StreamingContext context);
+    }
+    public class PrincipalSearcher : IDisposable {
+        public PrincipalSearcher();
+        public PrincipalSearcher(Principal queryFilter);
+        public PrincipalContext Context { get; }
+        public Principal QueryFilter { get; set; }
+        public virtual void Dispose();
+        public PrincipalSearchResult<Principal> FindAll();
+        public Principal FindOne();
+        public object GetUnderlyingSearcher();
+        public Type GetUnderlyingSearcherType();
+    }
+    public class PrincipalSearchResult<T> : IDisposable, IEnumerable, IEnumerable<T> {
+        public void Dispose();
+        public IEnumerator<T> GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public class PrincipalServerDownException : PrincipalException {
+        public PrincipalServerDownException();
+        protected PrincipalServerDownException(SerializationInfo info, StreamingContext context);
+        public PrincipalServerDownException(string message);
+        public PrincipalServerDownException(string message, Exception innerException);
+        public PrincipalServerDownException(string message, Exception innerException, int errorCode);
+        public PrincipalServerDownException(string message, Exception innerException, int errorCode, string serverName);
+        public PrincipalServerDownException(string message, int errorCode);
+        public override void GetObjectData(SerializationInfo info, StreamingContext context);
+    }
+    public class PrincipalValueCollection<T> : ICollection, ICollection<T>, IEnumerable, IEnumerable<T>, IList, IList<T> {
+        public int Count { get; }
+        public bool IsFixedSize { get; }
+        public bool IsReadOnly { get; }
+        public bool IsSynchronized { get; }
+        public T this[int index] { get; set; }
+        public object SyncRoot { get; }
+        int System.Collections.ICollection.Count { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public void Add(T value);
+        public void Clear();
+        public bool Contains(T value);
+        public void CopyTo(T[] array, int index);
+        public IEnumerator<T> GetEnumerator();
+        public int IndexOf(T value);
+        public void Insert(int index, T value);
+        public bool Remove(T value);
+        public void RemoveAt(int index);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        int System.Collections.IList.Add(object value);
+        void System.Collections.IList.Clear();
+        bool System.Collections.IList.Contains(object value);
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+        void System.Collections.IList.RemoveAt(int index);
+    }
+    public class UserPrincipal : AuthenticablePrincipal {
+        public UserPrincipal(PrincipalContext context);
+        public UserPrincipal(PrincipalContext context, string samAccountName, string password, bool enabled);
+        public override AdvancedFilters AdvancedSearchFilter { get; }
+        public static UserPrincipal Current { get; }
+        public string EmailAddress { get; set; }
+        public string EmployeeId { get; set; }
+        public string GivenName { get; set; }
+        public string MiddleName { get; set; }
+        public string Surname { get; set; }
+        public string VoiceTelephoneNumber { get; set; }
+        public static new PrincipalSearchResult<UserPrincipal> FindByBadPasswordAttempt(PrincipalContext context, DateTime time, MatchType type);
+        public static new PrincipalSearchResult<UserPrincipal> FindByExpirationTime(PrincipalContext context, DateTime time, MatchType type);
+        public static new UserPrincipal FindByIdentity(PrincipalContext context, IdentityType identityType, string identityValue);
+        public static new UserPrincipal FindByIdentity(PrincipalContext context, string identityValue);
+        public static new PrincipalSearchResult<UserPrincipal> FindByLockoutTime(PrincipalContext context, DateTime time, MatchType type);
+        public static new PrincipalSearchResult<UserPrincipal> FindByLogonTime(PrincipalContext context, DateTime time, MatchType type);
+        public static new PrincipalSearchResult<UserPrincipal> FindByPasswordSetTime(PrincipalContext context, DateTime time, MatchType type);
+        public PrincipalSearchResult<Principal> GetAuthorizationGroups();
+    }
+}
+namespace System.DirectoryServices.ActiveDirectory {
+    public class ActiveDirectoryInterSiteTransport : IDisposable {
+        public bool BridgeAllSiteLinks { get; set; }
+        public bool IgnoreReplicationSchedule { get; set; }
+        public ReadOnlySiteLinkBridgeCollection SiteLinkBridges { get; }
+        public ReadOnlySiteLinkCollection SiteLinks { get; }
+        public ActiveDirectoryTransportType TransportType { get; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public static ActiveDirectoryInterSiteTransport FindByTransportType(DirectoryContext context, ActiveDirectoryTransportType transport);
+        public DirectoryEntry GetDirectoryEntry();
+        public void Save();
+        public override string ToString();
+    }
+    public class ActiveDirectoryObjectExistsException : Exception {
+        public ActiveDirectoryObjectExistsException();
+        protected ActiveDirectoryObjectExistsException(SerializationInfo info, StreamingContext context);
+        public ActiveDirectoryObjectExistsException(string message);
+        public ActiveDirectoryObjectExistsException(string message, Exception inner);
+    }
+    public class ActiveDirectoryObjectNotFoundException : Exception, ISerializable {
+        public ActiveDirectoryObjectNotFoundException();
+        protected ActiveDirectoryObjectNotFoundException(SerializationInfo info, StreamingContext context);
+        public ActiveDirectoryObjectNotFoundException(string message);
+        public ActiveDirectoryObjectNotFoundException(string message, Exception inner);
+        public ActiveDirectoryObjectNotFoundException(string message, Type type, string name);
+        public string Name { get; }
+        public Type Type { get; }
+        public override void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
+    }
+    public class ActiveDirectoryOperationException : Exception, ISerializable {
+        public ActiveDirectoryOperationException();
+        protected ActiveDirectoryOperationException(SerializationInfo info, StreamingContext context);
+        public ActiveDirectoryOperationException(string message);
+        public ActiveDirectoryOperationException(string message, Exception inner);
+        public ActiveDirectoryOperationException(string message, Exception inner, int errorCode);
+        public ActiveDirectoryOperationException(string message, int errorCode);
+        public int ErrorCode { get; }
+        public override void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
+    }
+    public abstract class ActiveDirectoryPartition : IDisposable {
+        protected ActiveDirectoryPartition();
+        public string Name { get; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public abstract DirectoryEntry GetDirectoryEntry();
+        public override string ToString();
+    }
+    public class ActiveDirectoryReplicationMetadata : DictionaryBase {
+        public ReadOnlyStringCollection AttributeNames { get; }
+        public AttributeMetadata this[string name] { get; }
+        public AttributeMetadataCollection Values { get; }
+        public bool Contains(string attributeName);
+        public void CopyTo(AttributeMetadata[] array, int index);
+    }
+    public enum ActiveDirectoryRole {
+        InfrastructureRole = 4,
+        NamingRole = 1,
+        PdcRole = 2,
+        RidRole = 3,
+        SchemaRole = 0,
+    }
+    public class ActiveDirectoryRoleCollection : ReadOnlyCollectionBase {
+        public ActiveDirectoryRole this[int index] { get; }
+        public bool Contains(ActiveDirectoryRole role);
+        public void CopyTo(ActiveDirectoryRole[] roles, int index);
+        public int IndexOf(ActiveDirectoryRole role);
+    }
+    public class ActiveDirectorySchedule {
+        public ActiveDirectorySchedule();
+        public ActiveDirectorySchedule(ActiveDirectorySchedule schedule);
+        public bool[,,] RawSchedule { get; set; }
+        public void ResetSchedule();
+        public void SetDailySchedule(HourOfDay fromHour, MinuteOfHour fromMinute, HourOfDay toHour, MinuteOfHour toMinute);
+        public void SetSchedule(DayOfWeek day, HourOfDay fromHour, MinuteOfHour fromMinute, HourOfDay toHour, MinuteOfHour toMinute);
+        public void SetSchedule(DayOfWeek[] days, HourOfDay fromHour, MinuteOfHour fromMinute, HourOfDay toHour, MinuteOfHour toMinute);
+    }
+    public class ActiveDirectorySchema : ActiveDirectoryPartition {
+        public DirectoryServer SchemaRoleOwner { get; }
+        protected override void Dispose(bool disposing);
+        public ReadOnlyActiveDirectorySchemaClassCollection FindAllClasses();
+        public ReadOnlyActiveDirectorySchemaClassCollection FindAllClasses(SchemaClassType type);
+        public ReadOnlyActiveDirectorySchemaClassCollection FindAllDefunctClasses();
+        public ReadOnlyActiveDirectorySchemaPropertyCollection FindAllDefunctProperties();
+        public ReadOnlyActiveDirectorySchemaPropertyCollection FindAllProperties();
+        public ReadOnlyActiveDirectorySchemaPropertyCollection FindAllProperties(PropertyTypes type);
+        public ActiveDirectorySchemaClass FindClass(string ldapDisplayName);
+        public ActiveDirectorySchemaClass FindDefunctClass(string commonName);
+        public ActiveDirectorySchemaProperty FindDefunctProperty(string commonName);
+        public ActiveDirectorySchemaProperty FindProperty(string ldapDisplayName);
+        public static ActiveDirectorySchema GetCurrentSchema();
+        public override DirectoryEntry GetDirectoryEntry();
+        public static ActiveDirectorySchema GetSchema(DirectoryContext context);
+        public void RefreshSchema();
+    }
+    public class ActiveDirectorySchemaClass : IDisposable {
+        public ActiveDirectorySchemaClass(DirectoryContext context, string ldapDisplayName);
+        public ActiveDirectorySchemaClassCollection AuxiliaryClasses { get; }
+        public string CommonName { get; set; }
+        public ActiveDirectorySecurity DefaultObjectSecurityDescriptor { get; set; }
+        public string Description { get; set; }
+        public bool IsDefunct { get; set; }
+        public ActiveDirectorySchemaPropertyCollection MandatoryProperties { get; }
+        public string Name { get; }
+        public string Oid { get; set; }
+        public ActiveDirectorySchemaPropertyCollection OptionalProperties { get; }
+        public ReadOnlyActiveDirectorySchemaClassCollection PossibleInferiors { get; }
+        public ActiveDirectorySchemaClassCollection PossibleSuperiors { get; }
+        public Guid SchemaGuid { get; set; }
+        public ActiveDirectorySchemaClass SubClassOf { get; set; }
+        public SchemaClassType Type { get; set; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public static ActiveDirectorySchemaClass FindByName(DirectoryContext context, string ldapDisplayName);
+        public ReadOnlyActiveDirectorySchemaPropertyCollection GetAllProperties();
+        public DirectoryEntry GetDirectoryEntry();
+        public void Save();
+        public override string ToString();
+    }
+    public class ActiveDirectorySchemaClassCollection : CollectionBase {
+        public ActiveDirectorySchemaClass this[int index] { get; set; }
+        public int Add(ActiveDirectorySchemaClass schemaClass);
+        public void AddRange(ActiveDirectorySchemaClassCollection schemaClasses);
+        public void AddRange(ActiveDirectorySchemaClass[] schemaClasses);
+        public void AddRange(ReadOnlyActiveDirectorySchemaClassCollection schemaClasses);
+        public bool Contains(ActiveDirectorySchemaClass schemaClass);
+        public void CopyTo(ActiveDirectorySchemaClass[] schemaClasses, int index);
+        public int IndexOf(ActiveDirectorySchemaClass schemaClass);
+        public void Insert(int index, ActiveDirectorySchemaClass schemaClass);
+        protected override void OnClearComplete();
+        protected override void OnInsertComplete(int index, object value);
+        protected override void OnRemoveComplete(int index, object value);
+        protected override void OnSetComplete(int index, object oldValue, object newValue);
+        protected override void OnValidate(object value);
+        public void Remove(ActiveDirectorySchemaClass schemaClass);
+    }
+    public class ActiveDirectorySchemaProperty : IDisposable {
+        public ActiveDirectorySchemaProperty(DirectoryContext context, string ldapDisplayName);
+        public string CommonName { get; set; }
+        public string Description { get; set; }
+        public bool IsDefunct { get; set; }
+        public bool IsInAnr { get; set; }
+        public bool IsIndexed { get; set; }
+        public bool IsIndexedOverContainer { get; set; }
+        public bool IsInGlobalCatalog { get; set; }
+        public bool IsOnTombstonedObject { get; set; }
+        public bool IsSingleValued { get; set; }
+        public bool IsTupleIndexed { get; set; }
+        public ActiveDirectorySchemaProperty Link { get; }
+        public Nullable<int> LinkId { get; set; }
+        public string Name { get; }
+        public string Oid { get; set; }
+        public Nullable<int> RangeLower { get; set; }
+        public Nullable<int> RangeUpper { get; set; }
+        public Guid SchemaGuid { get; set; }
+        public ActiveDirectorySyntax Syntax { get; set; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public static ActiveDirectorySchemaProperty FindByName(DirectoryContext context, string ldapDisplayName);
+        public DirectoryEntry GetDirectoryEntry();
+        public void Save();
+        public override string ToString();
+    }
+    public class ActiveDirectorySchemaPropertyCollection : CollectionBase {
+        public ActiveDirectorySchemaProperty this[int index] { get; set; }
+        public int Add(ActiveDirectorySchemaProperty schemaProperty);
+        public void AddRange(ActiveDirectorySchemaPropertyCollection properties);
+        public void AddRange(ActiveDirectorySchemaProperty[] properties);
+        public void AddRange(ReadOnlyActiveDirectorySchemaPropertyCollection properties);
+        public bool Contains(ActiveDirectorySchemaProperty schemaProperty);
+        public void CopyTo(ActiveDirectorySchemaProperty[] properties, int index);
+        public int IndexOf(ActiveDirectorySchemaProperty schemaProperty);
+        public void Insert(int index, ActiveDirectorySchemaProperty schemaProperty);
+        protected override void OnClearComplete();
+        protected override void OnInsertComplete(int index, object value);
+        protected override void OnRemoveComplete(int index, object value);
+        protected override void OnSetComplete(int index, object oldValue, object newValue);
+        protected override void OnValidate(object value);
+        public void Remove(ActiveDirectorySchemaProperty schemaProperty);
+    }
+    public class ActiveDirectoryServerDownException : Exception, ISerializable {
+        public ActiveDirectoryServerDownException();
+        protected ActiveDirectoryServerDownException(SerializationInfo info, StreamingContext context);
+        public ActiveDirectoryServerDownException(string message);
+        public ActiveDirectoryServerDownException(string message, Exception inner);
+        public ActiveDirectoryServerDownException(string message, Exception inner, int errorCode, string name);
+        public ActiveDirectoryServerDownException(string message, int errorCode, string name);
+        public int ErrorCode { get; }
+        public override string Message { get; }
+        public string Name { get; }
+        public override void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
+    }
+    public class ActiveDirectorySite : IDisposable {
+        public ActiveDirectorySite(DirectoryContext context, string siteName);
+        public ReadOnlySiteCollection AdjacentSites { get; }
+        public ReadOnlyDirectoryServerCollection BridgeheadServers { get; }
+        public DomainCollection Domains { get; }
+        public DirectoryServer InterSiteTopologyGenerator { get; set; }
+        public ActiveDirectorySchedule IntraSiteReplicationSchedule { get; set; }
+        public string Location { get; set; }
+        public string Name { get; }
+        public ActiveDirectorySiteOptions Options { get; set; }
+        public DirectoryServerCollection PreferredRpcBridgeheadServers { get; }
+        public DirectoryServerCollection PreferredSmtpBridgeheadServers { get; }
+        public ReadOnlyDirectoryServerCollection Servers { get; }
+        public ReadOnlySiteLinkCollection SiteLinks { get; }
+        public ActiveDirectorySubnetCollection Subnets { get; }
+        public void Delete();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public static ActiveDirectorySite FindByName(DirectoryContext context, string siteName);
+        public static ActiveDirectorySite GetComputerSite();
+        public DirectoryEntry GetDirectoryEntry();
+        public void Save();
+        public override string ToString();
+    }
+    public class ActiveDirectorySiteCollection : CollectionBase {
+        public ActiveDirectorySite this[int index] { get; set; }
+        public int Add(ActiveDirectorySite site);
+        public void AddRange(ActiveDirectorySiteCollection sites);
+        public void AddRange(ActiveDirectorySite[] sites);
+        public bool Contains(ActiveDirectorySite site);
+        public void CopyTo(ActiveDirectorySite[] array, int index);
+        public int IndexOf(ActiveDirectorySite site);
+        public void Insert(int index, ActiveDirectorySite site);
+        protected override void OnClearComplete();
+        protected override void OnInsertComplete(int index, object value);
+        protected override void OnRemoveComplete(int index, object value);
+        protected override void OnSetComplete(int index, object oldValue, object newValue);
+        protected override void OnValidate(object value);
+        public void Remove(ActiveDirectorySite site);
+    }
+    public class ActiveDirectorySiteLink : IDisposable {
+        public ActiveDirectorySiteLink(DirectoryContext context, string siteLinkName);
+        public ActiveDirectorySiteLink(DirectoryContext context, string siteLinkName, ActiveDirectoryTransportType transport);
+        public ActiveDirectorySiteLink(DirectoryContext context, string siteLinkName, ActiveDirectoryTransportType transport, ActiveDirectorySchedule schedule);
+        public int Cost { get; set; }
+        public bool DataCompressionEnabled { get; set; }
+        public ActiveDirectorySchedule InterSiteReplicationSchedule { get; set; }
+        public string Name { get; }
+        public bool NotificationEnabled { get; set; }
+        public bool ReciprocalReplicationEnabled { get; set; }
+        public TimeSpan ReplicationInterval { get; set; }
+        public ActiveDirectorySiteCollection Sites { get; }
+        public ActiveDirectoryTransportType TransportType { get; }
+        public void Delete();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public static ActiveDirectorySiteLink FindByName(DirectoryContext context, string siteLinkName);
+        public static ActiveDirectorySiteLink FindByName(DirectoryContext context, string siteLinkName, ActiveDirectoryTransportType transport);
+        public DirectoryEntry GetDirectoryEntry();
+        public void Save();
+        public override string ToString();
+    }
+    public class ActiveDirectorySiteLinkBridge : IDisposable {
+        public ActiveDirectorySiteLinkBridge(DirectoryContext context, string bridgeName);
+        public ActiveDirectorySiteLinkBridge(DirectoryContext context, string bridgeName, ActiveDirectoryTransportType transport);
+        public string Name { get; }
+        public ActiveDirectorySiteLinkCollection SiteLinks { get; }
+        public ActiveDirectoryTransportType TransportType { get; }
+        public void Delete();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public static ActiveDirectorySiteLinkBridge FindByName(DirectoryContext context, string bridgeName);
+        public static ActiveDirectorySiteLinkBridge FindByName(DirectoryContext context, string bridgeName, ActiveDirectoryTransportType transport);
+        public DirectoryEntry GetDirectoryEntry();
+        public void Save();
+        public override string ToString();
+    }
+    public class ActiveDirectorySiteLinkCollection : CollectionBase {
+        public ActiveDirectorySiteLink this[int index] { get; set; }
+        public int Add(ActiveDirectorySiteLink link);
+        public void AddRange(ActiveDirectorySiteLinkCollection links);
+        public void AddRange(ActiveDirectorySiteLink[] links);
+        public bool Contains(ActiveDirectorySiteLink link);
+        public void CopyTo(ActiveDirectorySiteLink[] array, int index);
+        public int IndexOf(ActiveDirectorySiteLink link);
+        public void Insert(int index, ActiveDirectorySiteLink link);
+        protected override void OnClearComplete();
+        protected override void OnInsertComplete(int index, object value);
+        protected override void OnRemoveComplete(int index, object value);
+        protected override void OnSetComplete(int index, object oldValue, object newValue);
+        protected override void OnValidate(object value);
+        public void Remove(ActiveDirectorySiteLink link);
+    }
+    public enum ActiveDirectorySiteOptions {
+        AutoInterSiteTopologyDisabled = 16,
+        AutoMinimumHopDisabled = 4,
+        AutoTopologyDisabled = 1,
+        ForceKccWindows2003Behavior = 64,
+        GroupMembershipCachingEnabled = 32,
+        None = 0,
+        RandomBridgeHeaderServerSelectionDisabled = 256,
+        RedundantServerTopologyEnabled = 1024,
+        StaleServerDetectDisabled = 8,
+        TopologyCleanupDisabled = 2,
+        UseHashingForReplicationSchedule = 512,
+        UseWindows2000IstgElection = 128,
+    }
+    public class ActiveDirectorySubnet : IDisposable {
+        public ActiveDirectorySubnet(DirectoryContext context, string subnetName);
+        public ActiveDirectorySubnet(DirectoryContext context, string subnetName, string siteName);
+        public string Location { get; set; }
+        public string Name { get; }
+        public ActiveDirectorySite Site { get; set; }
+        public void Delete();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public static ActiveDirectorySubnet FindByName(DirectoryContext context, string subnetName);
+        public DirectoryEntry GetDirectoryEntry();
+        public void Save();
+        public override string ToString();
+    }
+    public class ActiveDirectorySubnetCollection : CollectionBase {
+        public ActiveDirectorySubnet this[int index] { get; set; }
+        public int Add(ActiveDirectorySubnet subnet);
+        public void AddRange(ActiveDirectorySubnetCollection subnets);
+        public void AddRange(ActiveDirectorySubnet[] subnets);
+        public bool Contains(ActiveDirectorySubnet subnet);
+        public void CopyTo(ActiveDirectorySubnet[] array, int index);
+        public int IndexOf(ActiveDirectorySubnet subnet);
+        public void Insert(int index, ActiveDirectorySubnet subnet);
+        protected override void OnClear();
+        protected override void OnClearComplete();
+        protected override void OnInsertComplete(int index, object value);
+        protected override void OnRemoveComplete(int index, object value);
+        protected override void OnSetComplete(int index, object oldValue, object newValue);
+        protected override void OnValidate(object value);
+        public void Remove(ActiveDirectorySubnet subnet);
+    }
+    public enum ActiveDirectorySyntax {
+        AccessPointDN = 19,
+        Bool = 8,
+        CaseExactString = 0,
+        CaseIgnoreString = 1,
+        DirectoryString = 3,
+        DN = 12,
+        DNWithBinary = 13,
+        DNWithString = 14,
+        Enumeration = 15,
+        GeneralizedTime = 10,
+        IA5String = 16,
+        Int = 6,
+        Int64 = 7,
+        NumericString = 2,
+        OctetString = 4,
+        Oid = 9,
+        ORName = 20,
+        PresentationAddress = 21,
+        PrintableString = 17,
+        ReplicaLink = 22,
+        SecurityDescriptor = 5,
+        Sid = 18,
+        UtcTime = 11,
+    }
+    public enum ActiveDirectoryTransportType {
+        Rpc = 0,
+        Smtp = 1,
+    }
+    public class AdamInstance : DirectoryServer {
+        public ConfigurationSet ConfigurationSet { get; }
+        public string DefaultPartition { get; set; }
+        public string HostName { get; }
+        public override ReplicationConnectionCollection InboundConnections { get; }
+        public override string IPAddress { get; }
+        public int LdapPort { get; }
+        public override ReplicationConnectionCollection OutboundConnections { get; }
+        public AdamRoleCollection Roles { get; }
+        public override string SiteName { get; }
+        public int SslPort { get; }
+        public override SyncUpdateCallback SyncFromAllServersCallback { get; set; }
+        public override void CheckReplicationConsistency();
+        protected override void Dispose(bool disposing);
+        ~AdamInstance();
+        public static AdamInstanceCollection FindAll(DirectoryContext context, string partitionName);
+        public static AdamInstance FindOne(DirectoryContext context, string partitionName);
+        public static AdamInstance GetAdamInstance(DirectoryContext context);
+        public override ReplicationNeighborCollection GetAllReplicationNeighbors();
+        public override ReplicationFailureCollection GetReplicationConnectionFailures();
+        public override ReplicationCursorCollection GetReplicationCursors(string partition);
+        public override ActiveDirectoryReplicationMetadata GetReplicationMetadata(string objectPath);
+        public override ReplicationNeighborCollection GetReplicationNeighbors(string partition);
+        public override ReplicationOperationInformation GetReplicationOperationInformation();
+        public void Save();
+        public void SeizeRoleOwnership(AdamRole role);
+        public override void SyncReplicaFromAllServers(string partition, SyncFromAllServersOptions options);
+        public override void SyncReplicaFromServer(string partition, string sourceServer);
+        public void TransferRoleOwnership(AdamRole role);
+        public override void TriggerSyncReplicaFromNeighbors(string partition);
+    }
+    public class AdamInstanceCollection : ReadOnlyCollectionBase {
+        public AdamInstance this[int index] { get; }
+        public bool Contains(AdamInstance adamInstance);
+        public void CopyTo(AdamInstance[] adamInstances, int index);
+        public int IndexOf(AdamInstance adamInstance);
+    }
+    public enum AdamRole {
+        NamingRole = 1,
+        SchemaRole = 0,
+    }
+    public class AdamRoleCollection : ReadOnlyCollectionBase {
+        public AdamRole this[int index] { get; }
+        public bool Contains(AdamRole role);
+        public void CopyTo(AdamRole[] roles, int index);
+        public int IndexOf(AdamRole role);
+    }
+    public class ApplicationPartition : ActiveDirectoryPartition {
+        public ApplicationPartition(DirectoryContext context, string distinguishedName);
+        public ApplicationPartition(DirectoryContext context, string distinguishedName, string objectClass);
+        public DirectoryServerCollection DirectoryServers { get; }
+        public string SecurityReferenceDomain { get; set; }
+        public void Delete();
+        protected override void Dispose(bool disposing);
+        public ReadOnlyDirectoryServerCollection FindAllDirectoryServers();
+        public ReadOnlyDirectoryServerCollection FindAllDirectoryServers(string siteName);
+        public ReadOnlyDirectoryServerCollection FindAllDiscoverableDirectoryServers();
+        public ReadOnlyDirectoryServerCollection FindAllDiscoverableDirectoryServers(string siteName);
+        public static ApplicationPartition FindByName(DirectoryContext context, string distinguishedName);
+        public DirectoryServer FindDirectoryServer();
+        public DirectoryServer FindDirectoryServer(bool forceRediscovery);
+        public DirectoryServer FindDirectoryServer(string siteName);
+        public DirectoryServer FindDirectoryServer(string siteName, bool forceRediscovery);
+        public static ApplicationPartition GetApplicationPartition(DirectoryContext context);
+        public override DirectoryEntry GetDirectoryEntry();
+        public void Save();
+    }
+    public class ApplicationPartitionCollection : ReadOnlyCollectionBase {
+        public ApplicationPartition this[int index] { get; }
+        public bool Contains(ApplicationPartition applicationPartition);
+        public void CopyTo(ApplicationPartition[] applicationPartitions, int index);
+        public int IndexOf(ApplicationPartition applicationPartition);
+    }
+    public class AttributeMetadata {
+        public DateTime LastOriginatingChangeTime { get; }
+        public Guid LastOriginatingInvocationId { get; }
+        public long LocalChangeUsn { get; }
+        public string Name { get; }
+        public long OriginatingChangeUsn { get; }
+        public string OriginatingServer { get; }
+        public int Version { get; }
+    }
+    public class AttributeMetadataCollection : ReadOnlyCollectionBase {
+        public AttributeMetadata this[int index] { get; }
+        public bool Contains(AttributeMetadata metadata);
+        public void CopyTo(AttributeMetadata[] metadata, int index);
+        public int IndexOf(AttributeMetadata metadata);
+    }
+    public class ConfigurationSet {
+        public AdamInstanceCollection AdamInstances { get; }
+        public ApplicationPartitionCollection ApplicationPartitions { get; }
+        public string Name { get; }
+        public AdamInstance NamingRoleOwner { get; }
+        public ActiveDirectorySchema Schema { get; }
+        public AdamInstance SchemaRoleOwner { get; }
+        public ReadOnlySiteCollection Sites { get; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public AdamInstance FindAdamInstance();
+        public AdamInstance FindAdamInstance(string partitionName);
+        public AdamInstance FindAdamInstance(string partitionName, string siteName);
+        public AdamInstanceCollection FindAllAdamInstances();
+        public AdamInstanceCollection FindAllAdamInstances(string partitionName);
+        public AdamInstanceCollection FindAllAdamInstances(string partitionName, string siteName);
+        public static ConfigurationSet GetConfigurationSet(DirectoryContext context);
+        public DirectoryEntry GetDirectoryEntry();
+        public ReplicationSecurityLevel GetSecurityLevel();
+        public void SetSecurityLevel(ReplicationSecurityLevel securityLevel);
+        public override string ToString();
+    }
+    public class DirectoryContext {
+        public DirectoryContext(DirectoryContextType contextType);
+        public DirectoryContext(DirectoryContextType contextType, string name);
+        public DirectoryContext(DirectoryContextType contextType, string username, string password);
+        public DirectoryContext(DirectoryContextType contextType, string name, string username, string password);
+        public DirectoryContextType ContextType { get; }
+        public string Name { get; }
+        public string UserName { get; }
+    }
+    public enum DirectoryContextType {
+        ApplicationPartition = 4,
+        ConfigurationSet = 3,
+        DirectoryServer = 2,
+        Domain = 0,
+        Forest = 1,
+    }
+    public abstract class DirectoryServer : IDisposable {
+        protected DirectoryServer();
+        public abstract ReplicationConnectionCollection InboundConnections { get; }
+        public abstract string IPAddress { get; }
+        public string Name { get; }
+        public abstract ReplicationConnectionCollection OutboundConnections { get; }
+        public ReadOnlyStringCollection Partitions { get; }
+        public abstract string SiteName { get; }
+        public abstract SyncUpdateCallback SyncFromAllServersCallback { get; set; }
+        public abstract void CheckReplicationConsistency();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        ~DirectoryServer();
+        public abstract ReplicationNeighborCollection GetAllReplicationNeighbors();
+        public DirectoryEntry GetDirectoryEntry();
+        public abstract ReplicationFailureCollection GetReplicationConnectionFailures();
+        public abstract ReplicationCursorCollection GetReplicationCursors(string partition);
+        public abstract ActiveDirectoryReplicationMetadata GetReplicationMetadata(string objectPath);
+        public abstract ReplicationNeighborCollection GetReplicationNeighbors(string partition);
+        public abstract ReplicationOperationInformation GetReplicationOperationInformation();
+        public void MoveToAnotherSite(string siteName);
+        public abstract void SyncReplicaFromAllServers(string partition, SyncFromAllServersOptions options);
+        public abstract void SyncReplicaFromServer(string partition, string sourceServer);
+        public override string ToString();
+        public abstract void TriggerSyncReplicaFromNeighbors(string partition);
+    }
+    public class DirectoryServerCollection : CollectionBase {
+        public DirectoryServer this[int index] { get; set; }
+        public int Add(DirectoryServer server);
+        public void AddRange(DirectoryServer[] servers);
+        public bool Contains(DirectoryServer server);
+        public void CopyTo(DirectoryServer[] array, int index);
+        public int IndexOf(DirectoryServer server);
+        public void Insert(int index, DirectoryServer server);
+        protected override void OnClear();
+        protected override void OnClearComplete();
+        protected override void OnInsertComplete(int index, object value);
+        protected override void OnRemoveComplete(int index, object value);
+        protected override void OnSetComplete(int index, object oldValue, object newValue);
+        protected override void OnValidate(object value);
+        public void Remove(DirectoryServer server);
+    }
+    public class Domain : ActiveDirectoryPartition {
+        public DomainCollection Children { get; }
+        public DomainControllerCollection DomainControllers { get; }
+        public DomainMode DomainMode { get; }
+        public int DomainModeLevel { get; }
+        public Forest Forest { get; }
+        public DomainController InfrastructureRoleOwner { get; }
+        public Domain Parent { get; }
+        public DomainController PdcRoleOwner { get; }
+        public DomainController RidRoleOwner { get; }
+        public void CreateLocalSideOfTrustRelationship(string targetDomainName, TrustDirection direction, string trustPassword);
+        public void CreateTrustRelationship(Domain targetDomain, TrustDirection direction);
+        public void DeleteLocalSideOfTrustRelationship(string targetDomainName);
+        public void DeleteTrustRelationship(Domain targetDomain);
+        public DomainControllerCollection FindAllDiscoverableDomainControllers();
+        public DomainControllerCollection FindAllDiscoverableDomainControllers(string siteName);
+        public DomainControllerCollection FindAllDomainControllers();
+        public DomainControllerCollection FindAllDomainControllers(string siteName);
+        public DomainController FindDomainController();
+        public DomainController FindDomainController(LocatorOptions flag);
+        public DomainController FindDomainController(string siteName);
+        public DomainController FindDomainController(string siteName, LocatorOptions flag);
+        public TrustRelationshipInformationCollection GetAllTrustRelationships();
+        public static Domain GetComputerDomain();
+        public static Domain GetCurrentDomain();
+        public override DirectoryEntry GetDirectoryEntry();
+        public static Domain GetDomain(DirectoryContext context);
+        public bool GetSelectiveAuthenticationStatus(string targetDomainName);
+        public bool GetSidFilteringStatus(string targetDomainName);
+        public TrustRelationshipInformation GetTrustRelationship(string targetDomainName);
+        public void RaiseDomainFunctionality(DomainMode domainMode);
+        public void RaiseDomainFunctionalityLevel(int domainMode);
+        public void RepairTrustRelationship(Domain targetDomain);
+        public void SetSelectiveAuthenticationStatus(string targetDomainName, bool enable);
+        public void SetSidFilteringStatus(string targetDomainName, bool enable);
+        public void UpdateLocalSideOfTrustRelationship(string targetDomainName, string newTrustPassword);
+        public void UpdateLocalSideOfTrustRelationship(string targetDomainName, TrustDirection newTrustDirection, string newTrustPassword);
+        public void UpdateTrustRelationship(Domain targetDomain, TrustDirection newTrustDirection);
+        public void VerifyOutboundTrustRelationship(string targetDomainName);
+        public void VerifyTrustRelationship(Domain targetDomain, TrustDirection direction);
+    }
+    public class DomainCollection : ReadOnlyCollectionBase {
+        public Domain this[int index] { get; }
+        public bool Contains(Domain domain);
+        public void CopyTo(Domain[] domains, int index);
+        public int IndexOf(Domain domain);
+    }
+    public enum DomainCollisionOptions {
+        NetBiosNameDisabledByAdmin = 4,
+        NetBiosNameDisabledByConflict = 8,
+        None = 0,
+        SidDisabledByAdmin = 1,
+        SidDisabledByConflict = 2,
+    }
+    public class DomainController : DirectoryServer {
+        protected DomainController();
+        public DateTime CurrentTime { get; }
+        public Domain Domain { get; }
+        public Forest Forest { get; }
+        public long HighestCommittedUsn { get; }
+        public override ReplicationConnectionCollection InboundConnections { get; }
+        public override string IPAddress { get; }
+        public string OSVersion { get; }
+        public override ReplicationConnectionCollection OutboundConnections { get; }
+        public ActiveDirectoryRoleCollection Roles { get; }
+        public override string SiteName { get; }
+        public override SyncUpdateCallback SyncFromAllServersCallback { get; set; }
+        public override void CheckReplicationConsistency();
+        protected override void Dispose(bool disposing);
+        public virtual GlobalCatalog EnableGlobalCatalog();
+        ~DomainController();
+        public static DomainControllerCollection FindAll(DirectoryContext context);
+        public static DomainControllerCollection FindAll(DirectoryContext context, string siteName);
+        public static DomainController FindOne(DirectoryContext context);
+        public static DomainController FindOne(DirectoryContext context, LocatorOptions flag);
+        public static DomainController FindOne(DirectoryContext context, string siteName);
+        public static DomainController FindOne(DirectoryContext context, string siteName, LocatorOptions flag);
+        public override ReplicationNeighborCollection GetAllReplicationNeighbors();
+        public virtual DirectorySearcher GetDirectorySearcher();
+        public static DomainController GetDomainController(DirectoryContext context);
+        public override ReplicationFailureCollection GetReplicationConnectionFailures();
+        public override ReplicationCursorCollection GetReplicationCursors(string partition);
+        public override ActiveDirectoryReplicationMetadata GetReplicationMetadata(string objectPath);
+        public override ReplicationNeighborCollection GetReplicationNeighbors(string partition);
+        public override ReplicationOperationInformation GetReplicationOperationInformation();
+        public virtual bool IsGlobalCatalog();
+        public void SeizeRoleOwnership(ActiveDirectoryRole role);
+        public override void SyncReplicaFromAllServers(string partition, SyncFromAllServersOptions options);
+        public override void SyncReplicaFromServer(string partition, string sourceServer);
+        public void TransferRoleOwnership(ActiveDirectoryRole role);
+        public override void TriggerSyncReplicaFromNeighbors(string partition);
+    }
+    public class DomainControllerCollection : ReadOnlyCollectionBase {
+        public DomainController this[int index] { get; }
+        public bool Contains(DomainController domainController);
+        public void CopyTo(DomainController[] domainControllers, int index);
+        public int IndexOf(DomainController domainController);
+    }
+    public enum DomainMode {
+        Unknown = -1,
+        Windows2000MixedDomain = 0,
+        Windows2000NativeDomain = 1,
+        Windows2003Domain = 3,
+        Windows2003InterimDomain = 2,
+        Windows2008Domain = 4,
+        Windows2008R2Domain = 5,
+        Windows2012R2Domain = 7,
+        Windows8Domain = 6,
+    }
+    public class Forest : IDisposable {
+        public ApplicationPartitionCollection ApplicationPartitions { get; }
+        public DomainCollection Domains { get; }
+        public ForestMode ForestMode { get; }
+        public int ForestModeLevel { get; }
+        public GlobalCatalogCollection GlobalCatalogs { get; }
+        public string Name { get; }
+        public DomainController NamingRoleOwner { get; }
+        public Domain RootDomain { get; }
+        public ActiveDirectorySchema Schema { get; }
+        public DomainController SchemaRoleOwner { get; }
+        public ReadOnlySiteCollection Sites { get; }
+        public void CreateLocalSideOfTrustRelationship(string targetForestName, TrustDirection direction, string trustPassword);
+        public void CreateTrustRelationship(Forest targetForest, TrustDirection direction);
+        public void DeleteLocalSideOfTrustRelationship(string targetForestName);
+        public void DeleteTrustRelationship(Forest targetForest);
+        public void Dispose();
+        protected void Dispose(bool disposing);
+        public GlobalCatalogCollection FindAllDiscoverableGlobalCatalogs();
+        public GlobalCatalogCollection FindAllDiscoverableGlobalCatalogs(string siteName);
+        public GlobalCatalogCollection FindAllGlobalCatalogs();
+        public GlobalCatalogCollection FindAllGlobalCatalogs(string siteName);
+        public GlobalCatalog FindGlobalCatalog();
+        public GlobalCatalog FindGlobalCatalog(LocatorOptions flag);
+        public GlobalCatalog FindGlobalCatalog(string siteName);
+        public GlobalCatalog FindGlobalCatalog(string siteName, LocatorOptions flag);
+        public TrustRelationshipInformationCollection GetAllTrustRelationships();
+        public static Forest GetCurrentForest();
+        public static Forest GetForest(DirectoryContext context);
+        public bool GetSelectiveAuthenticationStatus(string targetForestName);
+        public bool GetSidFilteringStatus(string targetForestName);
+        public ForestTrustRelationshipInformation GetTrustRelationship(string targetForestName);
+        public void RaiseForestFunctionality(ForestMode forestMode);
+        public void RaiseForestFunctionalityLevel(int forestMode);
+        public void RepairTrustRelationship(Forest targetForest);
+        public void SetSelectiveAuthenticationStatus(string targetForestName, bool enable);
+        public void SetSidFilteringStatus(string targetForestName, bool enable);
+        public override string ToString();
+        public void UpdateLocalSideOfTrustRelationship(string targetForestName, string newTrustPassword);
+        public void UpdateLocalSideOfTrustRelationship(string targetForestName, TrustDirection newTrustDirection, string newTrustPassword);
+        public void UpdateTrustRelationship(Forest targetForest, TrustDirection newTrustDirection);
+        public void VerifyOutboundTrustRelationship(string targetForestName);
+        public void VerifyTrustRelationship(Forest targetForest, TrustDirection direction);
+    }
+    public enum ForestMode {
+        Unknown = -1,
+        Windows2000Forest = 0,
+        Windows2003Forest = 2,
+        Windows2003InterimForest = 1,
+        Windows2008Forest = 3,
+        Windows2008R2Forest = 4,
+        Windows2012R2Forest = 6,
+        Windows8Forest = 5,
+    }
+    public class ForestTrustCollisionException : ActiveDirectoryOperationException, ISerializable {
+        public ForestTrustCollisionException();
+        protected ForestTrustCollisionException(SerializationInfo info, StreamingContext context);
+        public ForestTrustCollisionException(string message);
+        public ForestTrustCollisionException(string message, Exception inner);
+        public ForestTrustCollisionException(string message, Exception inner, ForestTrustRelationshipCollisionCollection collisions);
+        public ForestTrustRelationshipCollisionCollection Collisions { get; }
+        public override void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
+    }
+    public enum ForestTrustCollisionType {
+        Domain = 1,
+        Other = 2,
+        TopLevelName = 0,
+    }
+    public class ForestTrustDomainInfoCollection : ReadOnlyCollectionBase {
+        public ForestTrustDomainInformation this[int index] { get; }
+        public bool Contains(ForestTrustDomainInformation information);
+        public void CopyTo(ForestTrustDomainInformation[] array, int index);
+        public int IndexOf(ForestTrustDomainInformation information);
+    }
+    public class ForestTrustDomainInformation {
+        public string DnsName { get; }
+        public string DomainSid { get; }
+        public string NetBiosName { get; }
+        public ForestTrustDomainStatus Status { get; set; }
+    }
+    public enum ForestTrustDomainStatus {
+        Enabled = 0,
+        NetBiosNameAdminDisabled = 4,
+        NetBiosNameConflictDisabled = 8,
+        SidAdminDisabled = 1,
+        SidConflictDisabled = 2,
+    }
+    public class ForestTrustRelationshipCollision {
+        public string CollisionRecord { get; }
+        public ForestTrustCollisionType CollisionType { get; }
+        public DomainCollisionOptions DomainCollisionOption { get; }
+        public TopLevelNameCollisionOptions TopLevelNameCollisionOption { get; }
+    }
+    public class ForestTrustRelationshipCollisionCollection : ReadOnlyCollectionBase {
+        public ForestTrustRelationshipCollision this[int index] { get; }
+        public bool Contains(ForestTrustRelationshipCollision collision);
+        public void CopyTo(ForestTrustRelationshipCollision[] array, int index);
+        public int IndexOf(ForestTrustRelationshipCollision collision);
+    }
+    public class ForestTrustRelationshipInformation : TrustRelationshipInformation {
+        public StringCollection ExcludedTopLevelNames { get; }
+        public TopLevelNameCollection TopLevelNames { get; }
+        public ForestTrustDomainInfoCollection TrustedDomainInformation { get; }
+        public void Save();
+    }
+    public class GlobalCatalog : DomainController {
+        public DomainController DisableGlobalCatalog();
+        public override GlobalCatalog EnableGlobalCatalog();
+        public static new GlobalCatalogCollection FindAll(DirectoryContext context);
+        public static new GlobalCatalogCollection FindAll(DirectoryContext context, string siteName);
+        public ReadOnlyActiveDirectorySchemaPropertyCollection FindAllProperties();
+        public static new GlobalCatalog FindOne(DirectoryContext context);
+        public static new GlobalCatalog FindOne(DirectoryContext context, LocatorOptions flag);
+        public static new GlobalCatalog FindOne(DirectoryContext context, string siteName);
+        public static new GlobalCatalog FindOne(DirectoryContext context, string siteName, LocatorOptions flag);
+        public override DirectorySearcher GetDirectorySearcher();
+        public static GlobalCatalog GetGlobalCatalog(DirectoryContext context);
+        public override bool IsGlobalCatalog();
+    }
+    public class GlobalCatalogCollection : ReadOnlyCollectionBase {
+        public GlobalCatalog this[int index] { get; }
+        public bool Contains(GlobalCatalog globalCatalog);
+        public void CopyTo(GlobalCatalog[] globalCatalogs, int index);
+        public int IndexOf(GlobalCatalog globalCatalog);
+    }
+    public enum HourOfDay {
+        Eight = 8,
+        Eighteen = 18,
+        Eleven = 11,
+        Fifteen = 15,
+        Five = 5,
+        Four = 4,
+        Fourteen = 14,
+        Nine = 9,
+        Nineteen = 19,
+        One = 1,
+        Seven = 7,
+        Seventeen = 17,
+        Six = 6,
+        Sixteen = 16,
+        Ten = 10,
+        Thirteen = 13,
+        Three = 3,
+        Twelve = 12,
+        Twenty = 20,
+        TwentyOne = 21,
+        TwentyThree = 23,
+        TwentyTwo = 22,
+        Two = 2,
+        Zero = 0,
+    }
+    public enum LocatorOptions : long {
+        AvoidSelf = (long)16384,
+        ForceRediscovery = (long)1,
+        KdcRequired = (long)1024,
+        TimeServerRequired = (long)2048,
+        WriteableRequired = (long)4096,
+    }
+    public enum MinuteOfHour {
+        Fifteen = 15,
+        FortyFive = 45,
+        Thirty = 30,
+        Zero = 0,
+    }
+    public enum NotificationStatus {
+        IntraSiteOnly = 1,
+        NoNotification = 0,
+        NotificationAlways = 2,
+    }
+    public enum PropertyTypes {
+        Indexed = 2,
+        InGlobalCatalog = 4,
+    }
+    public class ReadOnlyActiveDirectorySchemaClassCollection : ReadOnlyCollectionBase {
+        public ActiveDirectorySchemaClass this[int index] { get; }
+        public bool Contains(ActiveDirectorySchemaClass schemaClass);
+        public void CopyTo(ActiveDirectorySchemaClass[] classes, int index);
+        public int IndexOf(ActiveDirectorySchemaClass schemaClass);
+    }
+    public class ReadOnlyActiveDirectorySchemaPropertyCollection : ReadOnlyCollectionBase {
+        public ActiveDirectorySchemaProperty this[int index] { get; }
+        public bool Contains(ActiveDirectorySchemaProperty schemaProperty);
+        public void CopyTo(ActiveDirectorySchemaProperty[] properties, int index);
+        public int IndexOf(ActiveDirectorySchemaProperty schemaProperty);
+    }
+    public class ReadOnlyDirectoryServerCollection : ReadOnlyCollectionBase {
+        public DirectoryServer this[int index] { get; }
+        public bool Contains(DirectoryServer directoryServer);
+        public void CopyTo(DirectoryServer[] directoryServers, int index);
+        public int IndexOf(DirectoryServer directoryServer);
+    }
+    public class ReadOnlySiteCollection : ReadOnlyCollectionBase {
+        public ActiveDirectorySite this[int index] { get; }
+        public bool Contains(ActiveDirectorySite site);
+        public void CopyTo(ActiveDirectorySite[] sites, int index);
+        public int IndexOf(ActiveDirectorySite site);
+    }
+    public class ReadOnlySiteLinkBridgeCollection : ReadOnlyCollectionBase {
+        public ActiveDirectorySiteLinkBridge this[int index] { get; }
+        public bool Contains(ActiveDirectorySiteLinkBridge bridge);
+        public void CopyTo(ActiveDirectorySiteLinkBridge[] bridges, int index);
+        public int IndexOf(ActiveDirectorySiteLinkBridge bridge);
+    }
+    public class ReadOnlySiteLinkCollection : ReadOnlyCollectionBase {
+        public ActiveDirectorySiteLink this[int index] { get; }
+        public bool Contains(ActiveDirectorySiteLink link);
+        public void CopyTo(ActiveDirectorySiteLink[] links, int index);
+        public int IndexOf(ActiveDirectorySiteLink link);
+    }
+    public class ReadOnlyStringCollection : ReadOnlyCollectionBase {
+        public string this[int index] { get; }
+        public bool Contains(string value);
+        public void CopyTo(string[] values, int index);
+        public int IndexOf(string value);
+    }
+    public class ReplicationConnection : IDisposable {
+        public ReplicationConnection(DirectoryContext context, string name, DirectoryServer sourceServer);
+        public ReplicationConnection(DirectoryContext context, string name, DirectoryServer sourceServer, ActiveDirectorySchedule schedule);
+        public ReplicationConnection(DirectoryContext context, string name, DirectoryServer sourceServer, ActiveDirectorySchedule schedule, ActiveDirectoryTransportType transport);
+        public ReplicationConnection(DirectoryContext context, string name, DirectoryServer sourceServer, ActiveDirectoryTransportType transport);
+        public NotificationStatus ChangeNotificationStatus { get; set; }
+        public bool DataCompressionEnabled { get; set; }
+        public string DestinationServer { get; }
+        public bool Enabled { get; set; }
+        public bool GeneratedByKcc { get; set; }
+        public string Name { get; }
+        public bool ReciprocalReplicationEnabled { get; set; }
+        public ActiveDirectorySchedule ReplicationSchedule { get; set; }
+        public bool ReplicationScheduleOwnedByUser { get; set; }
+        public ReplicationSpan ReplicationSpan { get; }
+        public string SourceServer { get; }
+        public ActiveDirectoryTransportType TransportType { get; }
+        public void Delete();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        ~ReplicationConnection();
+        public static ReplicationConnection FindByName(DirectoryContext context, string name);
+        public DirectoryEntry GetDirectoryEntry();
+        public void Save();
+        public override string ToString();
+    }
+    public class ReplicationConnectionCollection : ReadOnlyCollectionBase {
+        public ReplicationConnection this[int index] { get; }
+        public bool Contains(ReplicationConnection connection);
+        public void CopyTo(ReplicationConnection[] connections, int index);
+        public int IndexOf(ReplicationConnection connection);
+    }
+    public class ReplicationCursor {
+        public DateTime LastSuccessfulSyncTime { get; }
+        public string PartitionName { get; }
+        public Guid SourceInvocationId { get; }
+        public string SourceServer { get; }
+        public long UpToDatenessUsn { get; }
+    }
+    public class ReplicationCursorCollection : ReadOnlyCollectionBase {
+        public ReplicationCursor this[int index] { get; }
+        public bool Contains(ReplicationCursor cursor);
+        public void CopyTo(ReplicationCursor[] values, int index);
+        public int IndexOf(ReplicationCursor cursor);
+    }
+    public class ReplicationFailure {
+        public int ConsecutiveFailureCount { get; }
+        public DateTime FirstFailureTime { get; }
+        public int LastErrorCode { get; }
+        public string LastErrorMessage { get; }
+        public string SourceServer { get; }
+    }
+    public class ReplicationFailureCollection : ReadOnlyCollectionBase {
+        public ReplicationFailure this[int index] { get; }
+        public bool Contains(ReplicationFailure failure);
+        public void CopyTo(ReplicationFailure[] failures, int index);
+        public int IndexOf(ReplicationFailure failure);
+    }
+    public class ReplicationNeighbor {
+        public enum ReplicationNeighborOptions : long {
+            CompressChanges = (long)268435456,
+            DisableScheduledSync = (long)134217728,
+            FullSyncInProgress = (long)65536,
+            FullSyncNextPacket = (long)131072,
+            IgnoreChangeNotifications = (long)67108864,
+            NeverSynced = (long)2097152,
+            NoChangeNotifications = (long)536870912,
+            PartialAttributeSet = (long)1073741824,
+            Preempted = (long)16777216,
+            ReturnObjectParent = (long)2048,
+            ScheduledSync = (long)64,
+            SyncOnStartup = (long)32,
+            TwoWaySync = (long)512,
+            UseInterSiteTransport = (long)128,
+            Writeable = (long)16,
+        }
+        public int ConsecutiveFailureCount { get; }
+        public DateTime LastAttemptedSync { get; }
+        public DateTime LastSuccessfulSync { get; }
+        public string LastSyncMessage { get; }
+        public int LastSyncResult { get; }
+        public string PartitionName { get; }
+        public ReplicationNeighbor.ReplicationNeighborOptions ReplicationNeighborOption { get; }
+        public Guid SourceInvocationId { get; }
+        public string SourceServer { get; }
+        public ActiveDirectoryTransportType TransportType { get; }
+        public long UsnAttributeFilter { get; }
+        public long UsnLastObjectChangeSynced { get; }
+    }
+    public class ReplicationNeighborCollection : ReadOnlyCollectionBase {
+        public ReplicationNeighbor this[int index] { get; }
+        public bool Contains(ReplicationNeighbor neighbor);
+        public void CopyTo(ReplicationNeighbor[] neighbors, int index);
+        public int IndexOf(ReplicationNeighbor neighbor);
+    }
+    public class ReplicationOperation {
+        public int OperationNumber { get; }
+        public ReplicationOperationType OperationType { get; }
+        public string PartitionName { get; }
+        public int Priority { get; }
+        public string SourceServer { get; }
+        public DateTime TimeEnqueued { get; }
+    }
+    public class ReplicationOperationCollection : ReadOnlyCollectionBase {
+        public ReplicationOperation this[int index] { get; }
+        public bool Contains(ReplicationOperation operation);
+        public void CopyTo(ReplicationOperation[] operations, int index);
+        public int IndexOf(ReplicationOperation operation);
+    }
+    public class ReplicationOperationInformation {
+        public ReplicationOperationInformation();
+        public ReplicationOperation CurrentOperation { get; }
+        public DateTime OperationStartTime { get; }
+        public ReplicationOperationCollection PendingOperations { get; }
+    }
+    public enum ReplicationOperationType {
+        Add = 1,
+        Delete = 2,
+        Modify = 3,
+        Sync = 0,
+        UpdateReference = 4,
+    }
+    public enum ReplicationSecurityLevel {
+        MutualAuthentication = 2,
+        Negotiate = 1,
+        NegotiatePassThrough = 0,
+    }
+    public enum ReplicationSpan {
+        InterSite = 1,
+        IntraSite = 0,
+    }
+    public enum SchemaClassType {
+        Abstract = 2,
+        Auxiliary = 3,
+        Structural = 1,
+        Type88 = 0,
+    }
+    public enum SyncFromAllServersErrorCategory {
+        ErrorContactingServer = 0,
+        ErrorReplicating = 1,
+        ServerUnreachable = 2,
+    }
+    public class SyncFromAllServersErrorInformation {
+        public SyncFromAllServersErrorCategory ErrorCategory { get; }
+        public int ErrorCode { get; }
+        public string ErrorMessage { get; }
+        public string SourceServer { get; }
+        public string TargetServer { get; }
+    }
+    public enum SyncFromAllServersEvent {
+        Error = 0,
+        Finished = 3,
+        SyncCompleted = 2,
+        SyncStarted = 1,
+    }
+    public class SyncFromAllServersOperationException : ActiveDirectoryOperationException, ISerializable {
+        public SyncFromAllServersOperationException();
+        protected SyncFromAllServersOperationException(SerializationInfo info, StreamingContext context);
+        public SyncFromAllServersOperationException(string message);
+        public SyncFromAllServersOperationException(string message, Exception inner);
+        public SyncFromAllServersOperationException(string message, Exception inner, SyncFromAllServersErrorInformation[] errors);
+        public SyncFromAllServersErrorInformation[] ErrorInformation { get; }
+        public override void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
+    }
+    public enum SyncFromAllServersOptions {
+        AbortIfServerUnavailable = 1,
+        CheckServerAlivenessOnly = 8,
+        CrossSite = 64,
+        None = 0,
+        PushChangeOutward = 32,
+        SkipInitialCheck = 16,
+        SyncAdjacentServerOnly = 2,
+    }
+    public delegate bool SyncUpdateCallback(SyncFromAllServersEvent eventType, string targetServer, string sourceServer, SyncFromAllServersOperationException exception); {
+        public SyncUpdateCallback(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(SyncFromAllServersEvent eventType, string targetServer, string sourceServer, SyncFromAllServersOperationException exception, AsyncCallback callback, object @object);
+        public virtual bool EndInvoke(IAsyncResult result);
+        public virtual bool Invoke(SyncFromAllServersEvent eventType, string targetServer, string sourceServer, SyncFromAllServersOperationException exception);
+    }
+    public class TopLevelName {
+        public string Name { get; }
+        public TopLevelNameStatus Status { get; set; }
+    }
+    public class TopLevelNameCollection : ReadOnlyCollectionBase {
+        public TopLevelName this[int index] { get; }
+        public bool Contains(TopLevelName name);
+        public void CopyTo(TopLevelName[] names, int index);
+        public int IndexOf(TopLevelName name);
+    }
+    public enum TopLevelNameCollisionOptions {
+        DisabledByAdmin = 2,
+        DisabledByConflict = 4,
+        NewlyCreated = 1,
+        None = 0,
+    }
+    public enum TopLevelNameStatus {
+        AdminDisabled = 2,
+        ConflictDisabled = 4,
+        Enabled = 0,
+        NewlyCreated = 1,
+    }
+    public enum TrustDirection {
+        Bidirectional = 3,
+        Inbound = 1,
+        Outbound = 2,
+    }
+    public class TrustRelationshipInformation {
+        public string SourceName { get; }
+        public string TargetName { get; }
+        public TrustDirection TrustDirection { get; }
+        public TrustType TrustType { get; }
+    }
+    public class TrustRelationshipInformationCollection : ReadOnlyCollectionBase {
+        public TrustRelationshipInformation this[int index] { get; }
+        public bool Contains(TrustRelationshipInformation information);
+        public void CopyTo(TrustRelationshipInformation[] array, int index);
+        public int IndexOf(TrustRelationshipInformation information);
+    }
+    public enum TrustType {
+        CrossLink = 2,
+        External = 3,
+        Forest = 4,
+        Kerberos = 5,
+        ParentChild = 1,
+        TreeRoot = 0,
+        Unknown = 6,
+    }
+}
+namespace System.DirectoryServices.Protocols {
+    public class AddRequest : DirectoryRequest {
+        public AddRequest();
+        public AddRequest(string distinguishedName, params DirectoryAttribute[] attributes);
+        public AddRequest(string distinguishedName, string objectClass);
+        public DirectoryAttributeCollection Attributes { get; }
+        public string DistinguishedName { get; set; }
+    }
+    public class AddResponse : DirectoryResponse {
+    }
+    public class AsqRequestControl : DirectoryControl {
+        public AsqRequestControl();
+        public AsqRequestControl(string attributeName);
+        public string AttributeName { get; set; }
+        public override byte[] GetValue();
+    }
+    public class AsqResponseControl : DirectoryControl {
+        public ResultCode Result { get; }
+    }
+    public enum AuthType {
+        Anonymous = 0,
+        Basic = 1,
+        Digest = 4,
+        Dpa = 6,
+        External = 8,
+        Kerberos = 9,
+        Msn = 7,
+        Negotiate = 2,
+        Ntlm = 3,
+        Sicily = 5,
+    }
+    public class BerConversionException : DirectoryException {
+        public BerConversionException();
+        protected BerConversionException(SerializationInfo info, StreamingContext context);
+        public BerConversionException(string message);
+        public BerConversionException(string message, Exception inner);
+    }
+    public static class BerConverter {
+        public static object[] Decode(string format, byte[] value);
+        public static byte[] Encode(string format, params object[] value);
+    }
+    public class CompareRequest : DirectoryRequest {
+        public CompareRequest();
+        public CompareRequest(string distinguishedName, DirectoryAttribute assertion);
+        public CompareRequest(string distinguishedName, string attributeName, byte[] value);
+        public CompareRequest(string distinguishedName, string attributeName, string value);
+        public CompareRequest(string distinguishedName, string attributeName, Uri value);
+        public DirectoryAttribute Assertion { get; }
+        public string DistinguishedName { get; set; }
+    }
+    public class CompareResponse : DirectoryResponse
+    public class CrossDomainMoveControl : DirectoryControl {
+        public CrossDomainMoveControl();
+        public CrossDomainMoveControl(string targetDomainController);
+        public string TargetDomainController { get; set; }
+        public override byte[] GetValue();
+    }
+    public class DeleteRequest : DirectoryRequest {
+        public DeleteRequest();
+        public DeleteRequest(string distinguishedName);
+        public string DistinguishedName { get; set; }
+    }
+    public class DeleteResponse : DirectoryResponse
+    public enum DereferenceAlias {
+        Always = 3,
+        FindingBaseObject = 2,
+        InSearching = 1,
+        Never = 0,
+    }
+    public delegate void DereferenceConnectionCallback(LdapConnection primaryConnection, LdapConnection connectionToDereference); {
+        public DereferenceConnectionCallback(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(LdapConnection primaryConnection, LdapConnection connectionToDereference, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(LdapConnection primaryConnection, LdapConnection connectionToDereference);
+    }
+    public class DirectoryAttribute : CollectionBase {
+        public DirectoryAttribute();
+        public DirectoryAttribute(string name, byte[] value);
+        public DirectoryAttribute(string name, params object[] values);
+        public DirectoryAttribute(string name, string value);
+        public DirectoryAttribute(string name, Uri value);
+        public object this[int index] { get; set; }
+        public string Name { get; set; }
+        public int Add(byte[] value);
+        public int Add(string value);
+        public int Add(Uri value);
+        public void AddRange(object[] values);
+        public bool Contains(object value);
+        public void CopyTo(object[] array, int index);
+        public object[] GetValues(Type valuesType);
+        public int IndexOf(object value);
+        public void Insert(int index, byte[] value);
+        public void Insert(int index, string value);
+        public void Insert(int index, Uri value);
+        protected override void OnValidate(object value);
+        public void Remove(object value);
+    }
+    public class DirectoryAttributeCollection : CollectionBase {
+        public DirectoryAttributeCollection();
+        public DirectoryAttribute this[int index] { get; set; }
+        public int Add(DirectoryAttribute attribute);
+        public void AddRange(DirectoryAttributeCollection attributeCollection);
+        public void AddRange(DirectoryAttribute[] attributes);
+        public bool Contains(DirectoryAttribute value);
+        public void CopyTo(DirectoryAttribute[] array, int index);
+        public int IndexOf(DirectoryAttribute value);
+        public void Insert(int index, DirectoryAttribute value);
+        protected override void OnValidate(object value);
+        public void Remove(DirectoryAttribute value);
+    }
+    public class DirectoryAttributeModification : DirectoryAttribute {
+        public DirectoryAttributeModification();
+        public DirectoryAttributeOperation Operation { get; set; }
+    }
+    public class DirectoryAttributeModificationCollection : CollectionBase {
+        public DirectoryAttributeModificationCollection();
+        public DirectoryAttributeModification this[int index] { get; set; }
+        public int Add(DirectoryAttributeModification attribute);
+        public void AddRange(DirectoryAttributeModificationCollection attributeCollection);
+        public void AddRange(DirectoryAttributeModification[] attributes);
+        public bool Contains(DirectoryAttributeModification value);
+        public void CopyTo(DirectoryAttributeModification[] array, int index);
+        public int IndexOf(DirectoryAttributeModification value);
+        public void Insert(int index, DirectoryAttributeModification value);
+        protected override void OnValidate(object value);
+        public void Remove(DirectoryAttributeModification value);
+    }
+    public enum DirectoryAttributeOperation {
+        Add = 0,
+        Delete = 1,
+        Replace = 2,
+    }
+    public abstract class DirectoryConnection {
+        protected DirectoryConnection();
+        public X509CertificateCollection ClientCertificates { get; }
+        public virtual NetworkCredential Credential { set; }
+        public virtual DirectoryIdentifier Directory { get; }
+        public virtual TimeSpan Timeout { get; set; }
+        public abstract DirectoryResponse SendRequest(DirectoryRequest request);
+    }
+    public class DirectoryControl {
+        public DirectoryControl(string type, byte[] value, bool isCritical, bool serverSide);
+        public bool IsCritical { get; set; }
+        public bool ServerSide { get; set; }
+        public string Type { get; }
+        public virtual byte[] GetValue();
+    }
+    public class DirectoryControlCollection : CollectionBase {
+        public DirectoryControlCollection();
+        public DirectoryControl this[int index] { get; set; }
+        public int Add(DirectoryControl control);
+        public void AddRange(DirectoryControlCollection controlCollection);
+        public void AddRange(DirectoryControl[] controls);
+        public bool Contains(DirectoryControl value);
+        public void CopyTo(DirectoryControl[] array, int index);
+        public int IndexOf(DirectoryControl value);
+        public void Insert(int index, DirectoryControl value);
+        protected override void OnValidate(object value);
+        public void Remove(DirectoryControl value);
+    }
+    public class DirectoryException : Exception {
+        public DirectoryException();
+        protected DirectoryException(SerializationInfo info, StreamingContext context);
+        public DirectoryException(string message);
+        public DirectoryException(string message, Exception inner);
+    }
+    public abstract class DirectoryIdentifier {
+        protected DirectoryIdentifier();
+    }
+    public class DirectoryNotificationControl : DirectoryControl {
+        public DirectoryNotificationControl();
+    }
+    public abstract class DirectoryOperation {
+        protected DirectoryOperation();
+    }
+    public class DirectoryOperationException : DirectoryException, ISerializable {
+        public DirectoryOperationException();
+        public DirectoryOperationException(DirectoryResponse response);
+        public DirectoryOperationException(DirectoryResponse response, string message);
+        public DirectoryOperationException(DirectoryResponse response, string message, Exception inner);
+        protected DirectoryOperationException(SerializationInfo info, StreamingContext context);
+        public DirectoryOperationException(string message);
+        public DirectoryOperationException(string message, Exception inner);
+        public DirectoryResponse Response { get; }
+        public override void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
+    }
+    public abstract class DirectoryRequest : DirectoryOperation {
+        public DirectoryControlCollection Controls { get; }
+        public string RequestId { get; set; }
+    }
+    public abstract class DirectoryResponse : DirectoryOperation {
+        public virtual DirectoryControl[] Controls { get; }
+        public virtual string ErrorMessage { get; }
+        public virtual string MatchedDN { get; }
+        public virtual Uri[] Referral { get; }
+        public string RequestId { get; }
+        public virtual ResultCode ResultCode { get; }
+    }
+    public enum DirectorySynchronizationOptions : long {
+        IncrementalValues = (long)2147483648,
+        None = (long)0,
+        ObjectSecurity = (long)1,
+        ParentsFirst = (long)2048,
+        PublicDataOnly = (long)8192,
+    }
+    public class DirSyncRequestControl : DirectoryControl {
+        public DirSyncRequestControl();
+        public DirSyncRequestControl(byte[] cookie);
+        public DirSyncRequestControl(byte[] cookie, DirectorySynchronizationOptions option);
+        public DirSyncRequestControl(byte[] cookie, DirectorySynchronizationOptions option, int attributeCount);
+        public int AttributeCount { get; set; }
+        public byte[] Cookie { get; set; }
+        public DirectorySynchronizationOptions Option { get; set; }
+        public override byte[] GetValue();
+    }
+    public class DirSyncResponseControl : DirectoryControl {
+        public byte[] Cookie { get; }
+        public bool MoreData { get; }
+        public int ResultSize { get; }
+    }
+    public class DomainScopeControl : DirectoryControl {
+        public DomainScopeControl();
+    }
+    public class DsmlAuthRequest : DirectoryRequest {
+        public DsmlAuthRequest();
+        public DsmlAuthRequest(string principal);
+        public string Principal { get; set; }
+    }
+    public class ExtendedDNControl : DirectoryControl {
+        public ExtendedDNControl();
+        public ExtendedDNControl(ExtendedDNFlag flag);
+        public ExtendedDNFlag Flag { get; set; }
+        public override byte[] GetValue();
+    }
+    public enum ExtendedDNFlag {
+        HexString = 0,
+        StandardString = 1,
+    }
+    public class ExtendedRequest : DirectoryRequest {
+        public ExtendedRequest();
+        public ExtendedRequest(string requestName);
+        public ExtendedRequest(string requestName, byte[] requestValue);
+        public string RequestName { get; set; }
+        public byte[] RequestValue { get; set; }
+    }
+    public class ExtendedResponse : DirectoryResponse {
+        public string ResponseName { get; }
+        public byte[] ResponseValue { get; }
+    }
+    public class LazyCommitControl : DirectoryControl {
+        public LazyCommitControl();
+    }
+    public class LdapConnection : DirectoryConnection, IDisposable {
+        public LdapConnection(LdapDirectoryIdentifier identifier);
+        public LdapConnection(LdapDirectoryIdentifier identifier, NetworkCredential credential);
+        public LdapConnection(LdapDirectoryIdentifier identifier, NetworkCredential credential, AuthType authType);
+        public LdapConnection(string server);
+        public AuthType AuthType { get; set; }
+        public bool AutoBind { get; set; }
+        public override NetworkCredential Credential { set; }
+        public LdapSessionOptions SessionOptions { get; }
+        public override TimeSpan Timeout { get; set; }
+        public void Abort(IAsyncResult asyncResult);
+        public IAsyncResult BeginSendRequest(DirectoryRequest request, PartialResultProcessing partialMode, AsyncCallback callback, object state);
+        public IAsyncResult BeginSendRequest(DirectoryRequest request, TimeSpan requestTimeout, PartialResultProcessing partialMode, AsyncCallback callback, object state);
+        public void Bind();
+        public void Bind(NetworkCredential newCredential);
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public DirectoryResponse EndSendRequest(IAsyncResult asyncResult);
+        ~LdapConnection();
+        public PartialResultsCollection GetPartialResults(IAsyncResult asyncResult);
+        public override DirectoryResponse SendRequest(DirectoryRequest request);
+        public DirectoryResponse SendRequest(DirectoryRequest request, TimeSpan requestTimeout);
+    }
+    public class LdapDirectoryIdentifier : DirectoryIdentifier {
+        public LdapDirectoryIdentifier(string server);
+        public LdapDirectoryIdentifier(string server, bool fullyQualifiedDnsHostName, bool connectionless);
+        public LdapDirectoryIdentifier(string server, int portNumber);
+        public LdapDirectoryIdentifier(string server, int portNumber, bool fullyQualifiedDnsHostName, bool connectionless);
+        public LdapDirectoryIdentifier(string[] servers, bool fullyQualifiedDnsHostName, bool connectionless);
+        public LdapDirectoryIdentifier(string[] servers, int portNumber, bool fullyQualifiedDnsHostName, bool connectionless);
+        public bool Connectionless { get; }
+        public bool FullyQualifiedDnsHostName { get; }
+        public int PortNumber { get; }
+        public string[] Servers { get; }
+    }
+    public class LdapException : DirectoryException, ISerializable {
+        public LdapException();
+        public LdapException(int errorCode);
+        public LdapException(int errorCode, string message);
+        public LdapException(int errorCode, string message, Exception inner);
+        public LdapException(int errorCode, string message, string serverErrorMessage);
+        protected LdapException(SerializationInfo info, StreamingContext context);
+        public LdapException(string message);
+        public LdapException(string message, Exception inner);
+        public int ErrorCode { get; }
+        public PartialResultsCollection PartialResults { get; }
+        public string ServerErrorMessage { get; }
+        public override void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
+    }
+    public class LdapSessionOptions {
+        public bool AutoReconnect { get; set; }
+        public string DomainName { get; set; }
+        public string HostName { get; set; }
+        public bool HostReachable { get; }
+        public LocatorFlags LocatorFlag { get; set; }
+        public TimeSpan PingKeepAliveTimeout { get; set; }
+        public int PingLimit { get; set; }
+        public TimeSpan PingWaitTimeout { get; set; }
+        public int ProtocolVersion { get; set; }
+        public QueryClientCertificateCallback QueryClientCertificate { get; set; }
+        public ReferralCallback ReferralCallback { get; set; }
+        public ReferralChasingOptions ReferralChasing { get; set; }
+        public int ReferralHopLimit { get; set; }
+        public bool RootDseCache { get; set; }
+        public string SaslMethod { get; set; }
+        public bool Sealing { get; set; }
+        public bool SecureSocketLayer { get; set; }
+        public object SecurityContext { get; }
+        public TimeSpan SendTimeout { get; set; }
+        public bool Signing { get; set; }
+        public SecurityPackageContextConnectionInformation SslInformation { get; }
+        public int SspiFlag { get; set; }
+        public bool TcpKeepAlive { get; set; }
+        public VerifyServerCertificateCallback VerifyServerCertificate { get; set; }
+        public void FastConcurrentBind();
+        public void StartTransportLayerSecurity(DirectoryControlCollection controls);
+        public void StopTransportLayerSecurity();
+    }
+    public enum LocatorFlags : long {
+        AvoidSelf = (long)16384,
+        DirectoryServicesPreferred = (long)32,
+        DirectoryServicesRequired = (long)16,
+        ForceRediscovery = (long)1,
+        GCRequired = (long)64,
+        GoodTimeServerPreferred = (long)8192,
+        IPRequired = (long)512,
+        IsDnsName = (long)131072,
+        IsFlatName = (long)65536,
+        KdcRequired = (long)1024,
+        None = (long)0,
+        OnlyLdapNeeded = (long)32768,
+        PdcRequired = (long)128,
+        ReturnDnsName = (long)1073741824,
+        ReturnFlatName = (long)2147483648,
+        TimeServerRequired = (long)2048,
+        WriteableRequired = (long)4096,
+    }
+    public class ModifyDNRequest : DirectoryRequest {
+        public ModifyDNRequest();
+        public ModifyDNRequest(string distinguishedName, string newParentDistinguishedName, string newName);
+        public bool DeleteOldRdn { get; set; }
+        public string DistinguishedName { get; set; }
+        public string NewName { get; set; }
+        public string NewParentDistinguishedName { get; set; }
+    }
+    public class ModifyDNResponse : DirectoryResponse
+    public class ModifyRequest : DirectoryRequest {
+        public ModifyRequest();
+        public ModifyRequest(string distinguishedName, params DirectoryAttributeModification[] modifications);
+        public ModifyRequest(string distinguishedName, DirectoryAttributeOperation operation, string attributeName, params object[] values);
+        public string DistinguishedName { get; set; }
+        public DirectoryAttributeModificationCollection Modifications { get; }
+    }
+    public class ModifyResponse : DirectoryResponse
+    public delegate bool NotifyOfNewConnectionCallback(LdapConnection primaryConnection, LdapConnection referralFromConnection, string newDistinguishedName, LdapDirectoryIdentifier identifier, LdapConnection newConnection, NetworkCredential credential, long currentUserToken, int errorCodeFromBind); {
+        public NotifyOfNewConnectionCallback(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(LdapConnection primaryConnection, LdapConnection referralFromConnection, string newDistinguishedName, LdapDirectoryIdentifier identifier, LdapConnection newConnection, NetworkCredential credential, long currentUserToken, int errorCodeFromBind, AsyncCallback callback, object @object);
+        public virtual bool EndInvoke(IAsyncResult result);
+        public virtual bool Invoke(LdapConnection primaryConnection, LdapConnection referralFromConnection, string newDistinguishedName, LdapDirectoryIdentifier identifier, LdapConnection newConnection, NetworkCredential credential, long currentUserToken, int errorCodeFromBind);
+    }
+    public class PageResultRequestControl : DirectoryControl {
+        public PageResultRequestControl();
+        public PageResultRequestControl(byte[] cookie);
+        public PageResultRequestControl(int pageSize);
+        public byte[] Cookie { get; set; }
+        public int PageSize { get; set; }
+        public override byte[] GetValue();
+    }
+    public class PageResultResponseControl : DirectoryControl {
+        public byte[] Cookie { get; }
+        public int TotalCount { get; }
+    }
+    public enum PartialResultProcessing {
+        NoPartialResultSupport = 0,
+        ReturnPartialResults = 1,
+        ReturnPartialResultsAndNotifyCallback = 2,
+    }
+    public class PartialResultsCollection : ReadOnlyCollectionBase {
+        public object this[int index] { get; }
+        public bool Contains(object value);
+        public void CopyTo(object[] values, int index);
+        public int IndexOf(object value);
+    }
+    public class PermissiveModifyControl : DirectoryControl {
+        public PermissiveModifyControl();
+    }
+    public delegate X509Certificate QueryClientCertificateCallback(LdapConnection connection, byte[][] trustedCAs); {
+        public QueryClientCertificateCallback(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(LdapConnection connection, byte[][] trustedCAs, AsyncCallback callback, object @object);
+        public virtual X509Certificate EndInvoke(IAsyncResult result);
+        public virtual X509Certificate Invoke(LdapConnection connection, byte[][] trustedCAs);
+    }
+    public delegate LdapConnection QueryForConnectionCallback(LdapConnection primaryConnection, LdapConnection referralFromConnection, string newDistinguishedName, LdapDirectoryIdentifier identifier, NetworkCredential credential, long currentUserToken); {
+        public QueryForConnectionCallback(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(LdapConnection primaryConnection, LdapConnection referralFromConnection, string newDistinguishedName, LdapDirectoryIdentifier identifier, NetworkCredential credential, long currentUserToken, AsyncCallback callback, object @object);
+        public virtual LdapConnection EndInvoke(IAsyncResult result);
+        public virtual LdapConnection Invoke(LdapConnection primaryConnection, LdapConnection referralFromConnection, string newDistinguishedName, LdapDirectoryIdentifier identifier, NetworkCredential credential, long currentUserToken);
+    }
+    public class QuotaControl : DirectoryControl {
+        public QuotaControl();
+        public QuotaControl(SecurityIdentifier querySid);
+        public SecurityIdentifier QuerySid { get; set; }
+        public override byte[] GetValue();
+    }
+    public sealed class ReferralCallback {
+        public ReferralCallback();
+        public DereferenceConnectionCallback DereferenceConnection { get; set; }
+        public NotifyOfNewConnectionCallback NotifyNewConnection { get; set; }
+        public QueryForConnectionCallback QueryForConnection { get; set; }
+    }
+    public enum ReferralChasingOptions {
+        All = 96,
+        External = 64,
+        None = 0,
+        Subordinate = 32,
+    }
+    public enum ResultCode {
+        AdminLimitExceeded = 11,
+        AffectsMultipleDsas = 71,
+        AliasDereferencingProblem = 36,
+        AliasProblem = 33,
+        AttributeOrValueExists = 20,
+        AuthMethodNotSupported = 7,
+        Busy = 51,
+        CompareFalse = 5,
+        CompareTrue = 6,
+        ConfidentialityRequired = 13,
+        ConstraintViolation = 19,
+        EntryAlreadyExists = 68,
+        InappropriateAuthentication = 48,
+        InappropriateMatching = 18,
+        InsufficientAccessRights = 50,
+        InvalidAttributeSyntax = 21,
+        InvalidDNSyntax = 34,
+        LoopDetect = 54,
+        NamingViolation = 64,
+        NoSuchAttribute = 16,
+        NoSuchObject = 32,
+        NotAllowedOnNonLeaf = 66,
+        NotAllowedOnRdn = 67,
+        ObjectClassModificationsProhibited = 69,
+        ObjectClassViolation = 65,
+        OffsetRangeError = 61,
+        OperationsError = 1,
+        Other = 80,
+        ProtocolError = 2,
+        Referral = 10,
+        ReferralV2 = 9,
+        ResultsTooLarge = 70,
+        SaslBindInProgress = 14,
+        SizeLimitExceeded = 4,
+        SortControlMissing = 60,
+        StrongAuthRequired = 8,
+        Success = 0,
+        TimeLimitExceeded = 3,
+        Unavailable = 52,
+        UnavailableCriticalExtension = 12,
+        UndefinedAttributeType = 17,
+        UnwillingToPerform = 53,
+        VirtualListViewError = 76,
+    }
+    public enum SearchOption {
+        DomainScope = 1,
+        PhantomRoot = 2,
+    }
+    public class SearchOptionsControl : DirectoryControl {
+        public SearchOptionsControl();
+        public SearchOptionsControl(SearchOption flags);
+        public SearchOption SearchOption { get; set; }
+        public override byte[] GetValue();
+    }
+    public class SearchRequest : DirectoryRequest {
+        public SearchRequest();
+        public SearchRequest(string distinguishedName, string ldapFilter, SearchScope searchScope, params string[] attributeList);
+        public DereferenceAlias Aliases { get; set; }
+        public StringCollection Attributes { get; }
+        public string DistinguishedName { get; set; }
+        public object Filter { get; set; }
+        public SearchScope Scope { get; set; }
+        public int SizeLimit { get; set; }
+        public TimeSpan TimeLimit { get; set; }
+        public bool TypesOnly { get; set; }
+    }
+    public class SearchResponse : DirectoryResponse {
+        public override DirectoryControl[] Controls { get; }
+        public SearchResultEntryCollection Entries { get; }
+        public override string ErrorMessage { get; }
+        public override string MatchedDN { get; }
+        public SearchResultReferenceCollection References { get; }
+        public override Uri[] Referral { get; }
+        public override ResultCode ResultCode { get; }
+    }
+    public class SearchResultAttributeCollection : DictionaryBase {
+        public ICollection AttributeNames { get; }
+        public DirectoryAttribute this[string attributeName] { get; }
+        public ICollection Values { get; }
+        public bool Contains(string attributeName);
+        public void CopyTo(DirectoryAttribute[] array, int index);
+    }
+    public class SearchResultEntry {
+        public SearchResultAttributeCollection Attributes { get; }
+        public DirectoryControl[] Controls { get; }
+        public string DistinguishedName { get; }
+    }
+    public class SearchResultEntryCollection : ReadOnlyCollectionBase {
+        public SearchResultEntry this[int index] { get; }
+        public bool Contains(SearchResultEntry value);
+        public void CopyTo(SearchResultEntry[] values, int index);
+        public int IndexOf(SearchResultEntry value);
+    }
+    public class SearchResultReference {
+        public DirectoryControl[] Controls { get; }
+        public Uri[] Reference { get; }
+    }
+    public class SearchResultReferenceCollection : ReadOnlyCollectionBase {
+        public SearchResultReference this[int index] { get; }
+        public bool Contains(SearchResultReference value);
+        public void CopyTo(SearchResultReference[] values, int index);
+        public int IndexOf(SearchResultReference value);
+    }
+    public enum SearchScope {
+        Base = 0,
+        OneLevel = 1,
+        Subtree = 2,
+    }
+    public class SecurityDescriptorFlagControl : DirectoryControl {
+        public SecurityDescriptorFlagControl();
+        public SecurityDescriptorFlagControl(SecurityMasks masks);
+        public SecurityMasks SecurityMasks { get; set; }
+        public override byte[] GetValue();
+    }
+    public enum SecurityMasks {
+        Dacl = 4,
+        Group = 2,
+        None = 0,
+        Owner = 1,
+        Sacl = 8,
+    }
+    public class SecurityPackageContextConnectionInformation {
+        public CipherAlgorithmType AlgorithmIdentifier { get; }
+        public int CipherStrength { get; }
+        public int ExchangeStrength { get; }
+        public HashAlgorithmType Hash { get; }
+        public int HashStrength { get; }
+        public int KeyExchangeAlgorithm { get; }
+        public SecurityProtocol Protocol { get; }
+    }
+    public enum SecurityProtocol {
+        Pct1Client = 2,
+        Pct1Server = 1,
+        Ssl2Client = 8,
+        Ssl2Server = 4,
+        Ssl3Client = 32,
+        Ssl3Server = 16,
+        Tls1Client = 128,
+        Tls1Server = 64,
+    }
+    public class ShowDeletedControl : DirectoryControl {
+        public ShowDeletedControl();
+    }
+    public class SortKey {
+        public SortKey();
+        public SortKey(string attributeName, string matchingRule, bool reverseOrder);
+        public string AttributeName { get; set; }
+        public string MatchingRule { get; set; }
+        public bool ReverseOrder { get; set; }
+    }
+    public class SortRequestControl : DirectoryControl {
+        public SortRequestControl(params SortKey[] sortKeys);
+        public SortRequestControl(string attributeName, bool reverseOrder);
+        public SortRequestControl(string attributeName, string matchingRule, bool reverseOrder);
+        public SortKey[] SortKeys { get; set; }
+        public override byte[] GetValue();
+    }
+    public class SortResponseControl : DirectoryControl {
+        public string AttributeName { get; }
+        public ResultCode Result { get; }
+    }
+    public class TlsOperationException : DirectoryOperationException {
+        public TlsOperationException();
+        public TlsOperationException(DirectoryResponse response);
+        public TlsOperationException(DirectoryResponse response, string message);
+        public TlsOperationException(DirectoryResponse response, string message, Exception inner);
+        protected TlsOperationException(SerializationInfo info, StreamingContext context);
+        public TlsOperationException(string message);
+        public TlsOperationException(string message, Exception inner);
+    }
+    public class TreeDeleteControl : DirectoryControl {
+        public TreeDeleteControl();
+    }
+    public class VerifyNameControl : DirectoryControl {
+        public VerifyNameControl();
+        public VerifyNameControl(string serverName);
+        public VerifyNameControl(string serverName, int flag);
+        public int Flag { get; set; }
+        public string ServerName { get; set; }
+        public override byte[] GetValue();
+    }
+    public delegate bool VerifyServerCertificateCallback(LdapConnection connection, X509Certificate certificate); {
+        public VerifyServerCertificateCallback(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(LdapConnection connection, X509Certificate certificate, AsyncCallback callback, object @object);
+        public virtual bool EndInvoke(IAsyncResult result);
+        public virtual bool Invoke(LdapConnection connection, X509Certificate certificate);
+    }
+    public class VlvRequestControl : DirectoryControl {
+        public VlvRequestControl();
+        public VlvRequestControl(int beforeCount, int afterCount, byte[] target);
+        public VlvRequestControl(int beforeCount, int afterCount, int offset);
+        public VlvRequestControl(int beforeCount, int afterCount, string target);
+        public int AfterCount { get; set; }
+        public int BeforeCount { get; set; }
+        public byte[] ContextId { get; set; }
+        public int EstimateCount { get; set; }
+        public int Offset { get; set; }
+        public byte[] Target { get; set; }
+        public override byte[] GetValue();
+    }
+    public class VlvResponseControl : DirectoryControl {
+        public int ContentCount { get; }
+        public byte[] ContextId { get; }
+        public ResultCode Result { get; }
+        public int TargetPosition { get; }
+    }
+}
 namespace System.Drawing {
+    public sealed class Bitmap : Image {
+        public Bitmap(Image original);
+        public Bitmap(Image original, int width, int height);
+        public Bitmap(Image original, Size newSize);
+        public Bitmap(int width, int height);
+        public Bitmap(int width, int height, Graphics g);
+        public Bitmap(int width, int height, int stride, PixelFormat format, IntPtr scan0);
+        public Bitmap(int width, int height, PixelFormat format);
+        public Bitmap(Stream stream);
+        public Bitmap(Stream stream, bool useIcm);
+        public Bitmap(string filename);
+        public Bitmap(string filename, bool useIcm);
+        public Bitmap(Type type, string resource);
+        public Bitmap Clone(Rectangle rect, PixelFormat format);
+        public Bitmap Clone(RectangleF rect, PixelFormat format);
+        public static Bitmap FromHicon(IntPtr hicon);
+        public static Bitmap FromResource(IntPtr hinstance, string bitmapName);
+        public IntPtr GetHbitmap();
+        public IntPtr GetHbitmap(Color background);
+        public IntPtr GetHicon();
+        public Color GetPixel(int x, int y);
+        public BitmapData LockBits(Rectangle rect, ImageLockMode flags, PixelFormat format);
+        public BitmapData LockBits(Rectangle rect, ImageLockMode flags, PixelFormat format, BitmapData bitmapData);
+        public void MakeTransparent();
+        public void MakeTransparent(Color transparentColor);
+        public void SetPixel(int x, int y, Color color);
+        public void SetResolution(float xDpi, float yDpi);
+        public void UnlockBits(BitmapData bitmapdata);
+    }
+    public class BitmapSuffixInSameAssemblyAttribute : Attribute {
+        public BitmapSuffixInSameAssemblyAttribute();
+    }
+    public class BitmapSuffixInSatelliteAssemblyAttribute : Attribute {
+        public BitmapSuffixInSatelliteAssemblyAttribute();
+    }
+    public abstract class Brush : MarshalByRefObject, ICloneable, IDisposable {
+        protected Brush();
+        public abstract object Clone();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        ~Brush();
+        protected internal void SetNativeBrush(IntPtr brush);
+    }
+    public static class Brushes {
+        public static Brush AliceBlue { get; }
+        public static Brush AntiqueWhite { get; }
+        public static Brush Aqua { get; }
+        public static Brush Aquamarine { get; }
+        public static Brush Azure { get; }
+        public static Brush Beige { get; }
+        public static Brush Bisque { get; }
+        public static Brush Black { get; }
+        public static Brush BlanchedAlmond { get; }
+        public static Brush Blue { get; }
+        public static Brush BlueViolet { get; }
+        public static Brush Brown { get; }
+        public static Brush BurlyWood { get; }
+        public static Brush CadetBlue { get; }
+        public static Brush Chartreuse { get; }
+        public static Brush Chocolate { get; }
+        public static Brush Coral { get; }
+        public static Brush CornflowerBlue { get; }
+        public static Brush Cornsilk { get; }
+        public static Brush Crimson { get; }
+        public static Brush Cyan { get; }
+        public static Brush DarkBlue { get; }
+        public static Brush DarkCyan { get; }
+        public static Brush DarkGoldenrod { get; }
+        public static Brush DarkGray { get; }
+        public static Brush DarkGreen { get; }
+        public static Brush DarkKhaki { get; }
+        public static Brush DarkMagenta { get; }
+        public static Brush DarkOliveGreen { get; }
+        public static Brush DarkOrange { get; }
+        public static Brush DarkOrchid { get; }
+        public static Brush DarkRed { get; }
+        public static Brush DarkSalmon { get; }
+        public static Brush DarkSeaGreen { get; }
+        public static Brush DarkSlateBlue { get; }
+        public static Brush DarkSlateGray { get; }
+        public static Brush DarkTurquoise { get; }
+        public static Brush DarkViolet { get; }
+        public static Brush DeepPink { get; }
+        public static Brush DeepSkyBlue { get; }
+        public static Brush DimGray { get; }
+        public static Brush DodgerBlue { get; }
+        public static Brush Firebrick { get; }
+        public static Brush FloralWhite { get; }
+        public static Brush ForestGreen { get; }
+        public static Brush Fuchsia { get; }
+        public static Brush Gainsboro { get; }
+        public static Brush GhostWhite { get; }
+        public static Brush Gold { get; }
+        public static Brush Goldenrod { get; }
+        public static Brush Gray { get; }
+        public static Brush Green { get; }
+        public static Brush GreenYellow { get; }
+        public static Brush Honeydew { get; }
+        public static Brush HotPink { get; }
+        public static Brush IndianRed { get; }
+        public static Brush Indigo { get; }
+        public static Brush Ivory { get; }
+        public static Brush Khaki { get; }
+        public static Brush Lavender { get; }
+        public static Brush LavenderBlush { get; }
+        public static Brush LawnGreen { get; }
+        public static Brush LemonChiffon { get; }
+        public static Brush LightBlue { get; }
+        public static Brush LightCoral { get; }
+        public static Brush LightCyan { get; }
+        public static Brush LightGoldenrodYellow { get; }
+        public static Brush LightGray { get; }
+        public static Brush LightGreen { get; }
+        public static Brush LightPink { get; }
+        public static Brush LightSalmon { get; }
+        public static Brush LightSeaGreen { get; }
+        public static Brush LightSkyBlue { get; }
+        public static Brush LightSlateGray { get; }
+        public static Brush LightSteelBlue { get; }
+        public static Brush LightYellow { get; }
+        public static Brush Lime { get; }
+        public static Brush LimeGreen { get; }
+        public static Brush Linen { get; }
+        public static Brush Magenta { get; }
+        public static Brush Maroon { get; }
+        public static Brush MediumAquamarine { get; }
+        public static Brush MediumBlue { get; }
+        public static Brush MediumOrchid { get; }
+        public static Brush MediumPurple { get; }
+        public static Brush MediumSeaGreen { get; }
+        public static Brush MediumSlateBlue { get; }
+        public static Brush MediumSpringGreen { get; }
+        public static Brush MediumTurquoise { get; }
+        public static Brush MediumVioletRed { get; }
+        public static Brush MidnightBlue { get; }
+        public static Brush MintCream { get; }
+        public static Brush MistyRose { get; }
+        public static Brush Moccasin { get; }
+        public static Brush NavajoWhite { get; }
+        public static Brush Navy { get; }
+        public static Brush OldLace { get; }
+        public static Brush Olive { get; }
+        public static Brush OliveDrab { get; }
+        public static Brush Orange { get; }
+        public static Brush OrangeRed { get; }
+        public static Brush Orchid { get; }
+        public static Brush PaleGoldenrod { get; }
+        public static Brush PaleGreen { get; }
+        public static Brush PaleTurquoise { get; }
+        public static Brush PaleVioletRed { get; }
+        public static Brush PapayaWhip { get; }
+        public static Brush PeachPuff { get; }
+        public static Brush Peru { get; }
+        public static Brush Pink { get; }
+        public static Brush Plum { get; }
+        public static Brush PowderBlue { get; }
+        public static Brush Purple { get; }
+        public static Brush Red { get; }
+        public static Brush RosyBrown { get; }
+        public static Brush RoyalBlue { get; }
+        public static Brush SaddleBrown { get; }
+        public static Brush Salmon { get; }
+        public static Brush SandyBrown { get; }
+        public static Brush SeaGreen { get; }
+        public static Brush SeaShell { get; }
+        public static Brush Sienna { get; }
+        public static Brush Silver { get; }
+        public static Brush SkyBlue { get; }
+        public static Brush SlateBlue { get; }
+        public static Brush SlateGray { get; }
+        public static Brush Snow { get; }
+        public static Brush SpringGreen { get; }
+        public static Brush SteelBlue { get; }
+        public static Brush Tan { get; }
+        public static Brush Teal { get; }
+        public static Brush Thistle { get; }
+        public static Brush Tomato { get; }
+        public static Brush Transparent { get; }
+        public static Brush Turquoise { get; }
+        public static Brush Violet { get; }
+        public static Brush Wheat { get; }
+        public static Brush White { get; }
+        public static Brush WhiteSmoke { get; }
+        public static Brush Yellow { get; }
+        public static Brush YellowGreen { get; }
+    }
+    public sealed class BufferedGraphics : IDisposable {
+        public Graphics Graphics { get; }
+        public void Dispose();
+        public void Render();
+        public void Render(Graphics target);
+        public void Render(IntPtr targetDC);
+    }
+    public sealed class BufferedGraphicsContext : IDisposable {
+        public BufferedGraphicsContext();
+        public Size MaximumBuffer { get; set; }
+        public BufferedGraphics Allocate(Graphics targetGraphics, Rectangle targetRectangle);
+        public BufferedGraphics Allocate(IntPtr targetDC, Rectangle targetRectangle);
+        public void Dispose();
+        public void Invalidate();
+    }
+    public static class BufferedGraphicsManager {
+        public static BufferedGraphicsContext Current { get; }
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct CharacterRange {
+        public CharacterRange(int First, int Length);
+        public int First { get; set; }
+        public int Length { get; set; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static bool operator ==(CharacterRange cr1, CharacterRange cr2);
+        public static bool operator !=(CharacterRange cr1, CharacterRange cr2);
+    }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
-    public struct Color : IEquatable<Color> {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Color : IEquatable<Color> {
+        public bool IsKnownColor { get; }
+        public bool IsSystemColor { get; }
+        public static Color FromKnownColor(KnownColor color);
+        public KnownColor ToKnownColor();
     }
+    public sealed class ColorTranslator {
+        public static Color FromHtml(string htmlColor);
+        public static Color FromOle(int oleColor);
+        public static Color FromWin32(int win32Color);
+        public static string ToHtml(Color c);
+        public static int ToOle(Color c);
+        public static int ToWin32(Color c);
+    }
+    public enum ContentAlignment {
+        BottomCenter = 512,
+        BottomLeft = 256,
+        BottomRight = 1024,
+        MiddleCenter = 32,
+        MiddleLeft = 16,
+        MiddleRight = 64,
+        TopCenter = 2,
+        TopLeft = 1,
+        TopRight = 4,
+    }
+    public enum CopyPixelOperation {
+        Blackness = 66,
+        CaptureBlt = 1073741824,
+        DestinationInvert = 5570569,
+        MergeCopy = 12583114,
+        MergePaint = 12255782,
+        NoMirrorBitmap = -2147483648,
+        NotSourceCopy = 3342344,
+        NotSourceErase = 1114278,
+        PatCopy = 15728673,
+        PatInvert = 5898313,
+        PatPaint = 16452105,
+        SourceAnd = 8913094,
+        SourceCopy = 13369376,
+        SourceErase = 4457256,
+        SourceInvert = 6684742,
+        SourcePaint = 15597702,
+        Whiteness = 16711778,
+    }
+    public sealed class Font : MarshalByRefObject, ICloneable, IDisposable, ISerializable {
+        public Font(Font prototype, FontStyle newStyle);
+        public Font(FontFamily family, float emSize);
+        public Font(FontFamily family, float emSize, FontStyle style);
+        public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit);
+        public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet);
+        public Font(FontFamily family, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont);
+        public Font(FontFamily family, float emSize, GraphicsUnit unit);
+        public Font(string familyName, float emSize);
+        public Font(string familyName, float emSize, FontStyle style);
+        public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit);
+        public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet);
+        public Font(string familyName, float emSize, FontStyle style, GraphicsUnit unit, byte gdiCharSet, bool gdiVerticalFont);
+        public Font(string familyName, float emSize, GraphicsUnit unit);
+        public bool Bold { get; }
+        public FontFamily FontFamily { get; }
+        public byte GdiCharSet { get; }
+        public bool GdiVerticalFont { get; }
+        public int Height { get; }
+        public bool IsSystemFont { get; }
+        public bool Italic { get; }
+        public string Name { get; }
+        public string OriginalFontName { get; }
+        public float Size { get; }
+        public float SizeInPoints { get; }
+        public bool Strikeout { get; }
+        public FontStyle Style { get; }
+        public string SystemFontName { get; }
+        public bool Underline { get; }
+        public GraphicsUnit Unit { get; }
+        public object Clone();
+        public void Dispose();
+        public override bool Equals(object obj);
+        public static Font FromHdc(IntPtr hdc);
+        public static Font FromHfont(IntPtr hfont);
+        public static Font FromLogFont(object lf);
+        public static Font FromLogFont(object lf, IntPtr hdc);
+        public override int GetHashCode();
+        public float GetHeight();
+        public float GetHeight(Graphics graphics);
+        public float GetHeight(float dpi);
+        void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context);
+        public IntPtr ToHfont();
+        public void ToLogFont(object logFont);
+        public void ToLogFont(object logFont, Graphics graphics);
+        public override string ToString();
+    }
+    public sealed class FontFamily : MarshalByRefObject, IDisposable {
+        public FontFamily(GenericFontFamilies genericFamily);
+        public FontFamily(string name);
+        public FontFamily(string name, FontCollection fontCollection);
+        public static FontFamily[] Families { get; }
+        public static FontFamily GenericMonospace { get; }
+        public static FontFamily GenericSansSerif { get; }
+        public static FontFamily GenericSerif { get; }
+        public string Name { get; }
+        public void Dispose();
+        public override bool Equals(object obj);
+        public int GetCellAscent(FontStyle style);
+        public int GetCellDescent(FontStyle style);
+        public int GetEmHeight(FontStyle style);
+        public static FontFamily[] GetFamilies(Graphics graphics);
+        public override int GetHashCode();
+        public int GetLineSpacing(FontStyle style);
+        public string GetName(int language);
+        public bool IsStyleAvailable(FontStyle style);
+        public override string ToString();
+    }
+    public enum FontStyle {
+        Bold = 1,
+        Italic = 2,
+        Regular = 0,
+        Strikeout = 8,
+        Underline = 4,
+    }
+    public sealed class Graphics : MarshalByRefObject, IDeviceContext, IDisposable {
+        public delegate bool DrawImageAbort(IntPtr callbackdata); {
+            public DrawImageAbort(object @object, IntPtr method);
+            public virtual IAsyncResult BeginInvoke(IntPtr callbackdata, AsyncCallback callback, object @object);
+            public virtual bool EndInvoke(IAsyncResult result);
+            public virtual bool Invoke(IntPtr callbackdata);
+        }
+        public delegate bool EnumerateMetafileProc(EmfPlusRecordType recordType, int flags, int dataSize, IntPtr data, PlayRecordCallback callbackData); {
+            public EnumerateMetafileProc(object @object, IntPtr method);
+            public virtual IAsyncResult BeginInvoke(EmfPlusRecordType recordType, int flags, int dataSize, IntPtr data, PlayRecordCallback callbackData, AsyncCallback callback, object @object);
+            public virtual bool EndInvoke(IAsyncResult result);
+            public virtual bool Invoke(EmfPlusRecordType recordType, int flags, int dataSize, IntPtr data, PlayRecordCallback callbackData);
+        }
+        public Region Clip { get; set; }
+        public RectangleF ClipBounds { get; }
+        public CompositingMode CompositingMode { get; set; }
+        public CompositingQuality CompositingQuality { get; set; }
+        public float DpiX { get; }
+        public float DpiY { get; }
+        public InterpolationMode InterpolationMode { get; set; }
+        public bool IsClipEmpty { get; }
+        public bool IsVisibleClipEmpty { get; }
+        public float PageScale { get; set; }
+        public GraphicsUnit PageUnit { get; set; }
+        public PixelOffsetMode PixelOffsetMode { get; set; }
+        public Point RenderingOrigin { get; set; }
+        public SmoothingMode SmoothingMode { get; set; }
+        public int TextContrast { get; set; }
+        public TextRenderingHint TextRenderingHint { get; set; }
+        public Matrix Transform { get; set; }
+        public RectangleF VisibleClipBounds { get; }
+        public void AddMetafileComment(byte[] data);
+        public GraphicsContainer BeginContainer();
+        public GraphicsContainer BeginContainer(Rectangle dstrect, Rectangle srcrect, GraphicsUnit unit);
+        public GraphicsContainer BeginContainer(RectangleF dstrect, RectangleF srcrect, GraphicsUnit unit);
+        public void Clear(Color color);
+        public void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, Size blockRegionSize);
+        public void CopyFromScreen(int sourceX, int sourceY, int destinationX, int destinationY, Size blockRegionSize, CopyPixelOperation copyPixelOperation);
+        public void CopyFromScreen(Point upperLeftSource, Point upperLeftDestination, Size blockRegionSize);
+        public void CopyFromScreen(Point upperLeftSource, Point upperLeftDestination, Size blockRegionSize, CopyPixelOperation copyPixelOperation);
+        public void Dispose();
+        public void DrawArc(Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle);
+        public void DrawArc(Pen pen, Rectangle rect, float startAngle, float sweepAngle);
+        public void DrawArc(Pen pen, RectangleF rect, float startAngle, float sweepAngle);
+        public void DrawArc(Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);
+        public void DrawBezier(Pen pen, Point pt1, Point pt2, Point pt3, Point pt4);
+        public void DrawBezier(Pen pen, PointF pt1, PointF pt2, PointF pt3, PointF pt4);
+        public void DrawBezier(Pen pen, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);
+        public void DrawBeziers(Pen pen, PointF[] points);
+        public void DrawBeziers(Pen pen, Point[] points);
+        public void DrawClosedCurve(Pen pen, PointF[] points);
+        public void DrawClosedCurve(Pen pen, PointF[] points, float tension, FillMode fillmode);
+        public void DrawClosedCurve(Pen pen, Point[] points);
+        public void DrawClosedCurve(Pen pen, Point[] points, float tension, FillMode fillmode);
+        public void DrawCurve(Pen pen, PointF[] points);
+        public void DrawCurve(Pen pen, PointF[] points, int offset, int numberOfSegments);
+        public void DrawCurve(Pen pen, PointF[] points, int offset, int numberOfSegments, float tension);
+        public void DrawCurve(Pen pen, PointF[] points, float tension);
+        public void DrawCurve(Pen pen, Point[] points);
+        public void DrawCurve(Pen pen, Point[] points, int offset, int numberOfSegments, float tension);
+        public void DrawCurve(Pen pen, Point[] points, float tension);
+        public void DrawEllipse(Pen pen, int x, int y, int width, int height);
+        public void DrawEllipse(Pen pen, Rectangle rect);
+        public void DrawEllipse(Pen pen, RectangleF rect);
+        public void DrawEllipse(Pen pen, float x, float y, float width, float height);
+        public void DrawIcon(Icon icon, int x, int y);
+        public void DrawIcon(Icon icon, Rectangle targetRect);
+        public void DrawIconUnstretched(Icon icon, Rectangle targetRect);
+        public void DrawImage(Image image, int x, int y);
+        public void DrawImage(Image image, int x, int y, int width, int height);
+        public void DrawImage(Image image, int x, int y, Rectangle srcRect, GraphicsUnit srcUnit);
+        public void DrawImage(Image image, Point point);
+        public void DrawImage(Image image, PointF point);
+        public void DrawImage(Image image, PointF[] destPoints);
+        public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit);
+        public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr);
+        public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, Graphics.DrawImageAbort callback);
+        public void DrawImage(Image image, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, Graphics.DrawImageAbort callback, int callbackData);
+        public void DrawImage(Image image, Point[] destPoints);
+        public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit);
+        public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr);
+        public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, Graphics.DrawImageAbort callback);
+        public void DrawImage(Image image, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, ImageAttributes imageAttr, Graphics.DrawImageAbort callback, int callbackData);
+        public void DrawImage(Image image, Rectangle rect);
+        public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit);
+        public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttr);
+        public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttr, Graphics.DrawImageAbort callback);
+        public void DrawImage(Image image, Rectangle destRect, int srcX, int srcY, int srcWidth, int srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, Graphics.DrawImageAbort callback, IntPtr callbackData);
+        public void DrawImage(Image image, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit);
+        public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit);
+        public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs);
+        public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, Graphics.DrawImageAbort callback);
+        public void DrawImage(Image image, Rectangle destRect, float srcX, float srcY, float srcWidth, float srcHeight, GraphicsUnit srcUnit, ImageAttributes imageAttrs, Graphics.DrawImageAbort callback, IntPtr callbackData);
+        public void DrawImage(Image image, RectangleF rect);
+        public void DrawImage(Image image, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit);
+        public void DrawImage(Image image, float x, float y);
+        public void DrawImage(Image image, float x, float y, RectangleF srcRect, GraphicsUnit srcUnit);
+        public void DrawImage(Image image, float x, float y, float width, float height);
+        public void DrawImageUnscaled(Image image, int x, int y);
+        public void DrawImageUnscaled(Image image, int x, int y, int width, int height);
+        public void DrawImageUnscaled(Image image, Point point);
+        public void DrawImageUnscaled(Image image, Rectangle rect);
+        public void DrawImageUnscaledAndClipped(Image image, Rectangle rect);
+        public void DrawLine(Pen pen, int x1, int y1, int x2, int y2);
+        public void DrawLine(Pen pen, Point pt1, Point pt2);
+        public void DrawLine(Pen pen, PointF pt1, PointF pt2);
+        public void DrawLine(Pen pen, float x1, float y1, float x2, float y2);
+        public void DrawLines(Pen pen, PointF[] points);
+        public void DrawLines(Pen pen, Point[] points);
+        public void DrawPath(Pen pen, GraphicsPath path);
+        public void DrawPie(Pen pen, int x, int y, int width, int height, int startAngle, int sweepAngle);
+        public void DrawPie(Pen pen, Rectangle rect, float startAngle, float sweepAngle);
+        public void DrawPie(Pen pen, RectangleF rect, float startAngle, float sweepAngle);
+        public void DrawPie(Pen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);
+        public void DrawPolygon(Pen pen, PointF[] points);
+        public void DrawPolygon(Pen pen, Point[] points);
+        public void DrawRectangle(Pen pen, int x, int y, int width, int height);
+        public void DrawRectangle(Pen pen, Rectangle rect);
+        public void DrawRectangle(Pen pen, float x, float y, float width, float height);
+        public void DrawRectangles(Pen pen, RectangleF[] rects);
+        public void DrawRectangles(Pen pen, Rectangle[] rects);
+        public void DrawString(string s, Font font, Brush brush, PointF point);
+        public void DrawString(string s, Font font, Brush brush, PointF point, StringFormat format);
+        public void DrawString(string s, Font font, Brush brush, RectangleF layoutRectangle);
+        public void DrawString(string s, Font font, Brush brush, RectangleF layoutRectangle, StringFormat format);
+        public void DrawString(string s, Font font, Brush brush, float x, float y);
+        public void DrawString(string s, Font font, Brush brush, float x, float y, StringFormat format);
+        public void EndContainer(GraphicsContainer container);
+        public void EnumerateMetafile(Metafile metafile, Point destPoint, Graphics.EnumerateMetafileProc callback);
+        public void EnumerateMetafile(Metafile metafile, Point destPoint, Graphics.EnumerateMetafileProc callback, IntPtr callbackData);
+        public void EnumerateMetafile(Metafile metafile, Point destPoint, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
+        public void EnumerateMetafile(Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback);
+        public void EnumerateMetafile(Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData);
+        public void EnumerateMetafile(Metafile metafile, Point destPoint, Rectangle srcRect, GraphicsUnit unit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
+        public void EnumerateMetafile(Metafile metafile, PointF destPoint, Graphics.EnumerateMetafileProc callback);
+        public void EnumerateMetafile(Metafile metafile, PointF destPoint, Graphics.EnumerateMetafileProc callback, IntPtr callbackData);
+        public void EnumerateMetafile(Metafile metafile, PointF destPoint, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
+        public void EnumerateMetafile(Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback);
+        public void EnumerateMetafile(Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData);
+        public void EnumerateMetafile(Metafile metafile, PointF destPoint, RectangleF srcRect, GraphicsUnit unit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
+        public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, Graphics.EnumerateMetafileProc callback);
+        public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, Graphics.EnumerateMetafileProc callback, IntPtr callbackData);
+        public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
+        public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback);
+        public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData);
+        public void EnumerateMetafile(Metafile metafile, PointF[] destPoints, RectangleF srcRect, GraphicsUnit unit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
+        public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Graphics.EnumerateMetafileProc callback);
+        public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Graphics.EnumerateMetafileProc callback, IntPtr callbackData);
+        public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
+        public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback);
+        public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData);
+        public void EnumerateMetafile(Metafile metafile, Point[] destPoints, Rectangle srcRect, GraphicsUnit unit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
+        public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Graphics.EnumerateMetafileProc callback);
+        public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Graphics.EnumerateMetafileProc callback, IntPtr callbackData);
+        public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
+        public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback);
+        public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData);
+        public void EnumerateMetafile(Metafile metafile, Rectangle destRect, Rectangle srcRect, GraphicsUnit unit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
+        public void EnumerateMetafile(Metafile metafile, RectangleF destRect, Graphics.EnumerateMetafileProc callback);
+        public void EnumerateMetafile(Metafile metafile, RectangleF destRect, Graphics.EnumerateMetafileProc callback, IntPtr callbackData);
+        public void EnumerateMetafile(Metafile metafile, RectangleF destRect, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
+        public void EnumerateMetafile(Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback);
+        public void EnumerateMetafile(Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit srcUnit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData);
+        public void EnumerateMetafile(Metafile metafile, RectangleF destRect, RectangleF srcRect, GraphicsUnit unit, Graphics.EnumerateMetafileProc callback, IntPtr callbackData, ImageAttributes imageAttr);
+        public void ExcludeClip(Rectangle rect);
+        public void ExcludeClip(Region region);
+        public void FillClosedCurve(Brush brush, PointF[] points);
+        public void FillClosedCurve(Brush brush, PointF[] points, FillMode fillmode);
+        public void FillClosedCurve(Brush brush, PointF[] points, FillMode fillmode, float tension);
+        public void FillClosedCurve(Brush brush, Point[] points);
+        public void FillClosedCurve(Brush brush, Point[] points, FillMode fillmode);
+        public void FillClosedCurve(Brush brush, Point[] points, FillMode fillmode, float tension);
+        public void FillEllipse(Brush brush, int x, int y, int width, int height);
+        public void FillEllipse(Brush brush, Rectangle rect);
+        public void FillEllipse(Brush brush, RectangleF rect);
+        public void FillEllipse(Brush brush, float x, float y, float width, float height);
+        public void FillPath(Brush brush, GraphicsPath path);
+        public void FillPie(Brush brush, int x, int y, int width, int height, int startAngle, int sweepAngle);
+        public void FillPie(Brush brush, Rectangle rect, float startAngle, float sweepAngle);
+        public void FillPie(Brush brush, float x, float y, float width, float height, float startAngle, float sweepAngle);
+        public void FillPolygon(Brush brush, PointF[] points);
+        public void FillPolygon(Brush brush, PointF[] points, FillMode fillMode);
+        public void FillPolygon(Brush brush, Point[] points);
+        public void FillPolygon(Brush brush, Point[] points, FillMode fillMode);
+        public void FillRectangle(Brush brush, int x, int y, int width, int height);
+        public void FillRectangle(Brush brush, Rectangle rect);
+        public void FillRectangle(Brush brush, RectangleF rect);
+        public void FillRectangle(Brush brush, float x, float y, float width, float height);
+        public void FillRectangles(Brush brush, RectangleF[] rects);
+        public void FillRectangles(Brush brush, Rectangle[] rects);
+        public void FillRegion(Brush brush, Region region);
+        public void Flush();
+        public void Flush(FlushIntention intention);
+        public static Graphics FromHdc(IntPtr hdc);
+        public static Graphics FromHdc(IntPtr hdc, IntPtr hdevice);
+        public static Graphics FromHdcInternal(IntPtr hdc);
+        public static Graphics FromHwnd(IntPtr hwnd);
+        public static Graphics FromHwndInternal(IntPtr hwnd);
+        public static Graphics FromImage(Image image);
+        public object GetContextInfo();
+        public static IntPtr GetHalftonePalette();
+        public IntPtr GetHdc();
+        public Color GetNearestColor(Color color);
+        public void IntersectClip(Rectangle rect);
+        public void IntersectClip(RectangleF rect);
+        public void IntersectClip(Region region);
+        public bool IsVisible(int x, int y);
+        public bool IsVisible(int x, int y, int width, int height);
+        public bool IsVisible(Point point);
+        public bool IsVisible(PointF point);
+        public bool IsVisible(Rectangle rect);
+        public bool IsVisible(RectangleF rect);
+        public bool IsVisible(float x, float y);
+        public bool IsVisible(float x, float y, float width, float height);
+        public Region[] MeasureCharacterRanges(string text, Font font, RectangleF layoutRect, StringFormat stringFormat);
+        public SizeF MeasureString(string text, Font font);
+        public SizeF MeasureString(string text, Font font, int width);
+        public SizeF MeasureString(string text, Font font, int width, StringFormat format);
+        public SizeF MeasureString(string text, Font font, PointF origin, StringFormat stringFormat);
+        public SizeF MeasureString(string text, Font font, SizeF layoutArea);
+        public SizeF MeasureString(string text, Font font, SizeF layoutArea, StringFormat stringFormat);
+        public SizeF MeasureString(string text, Font font, SizeF layoutArea, StringFormat stringFormat, out int charactersFitted, out int linesFilled);
+        public void MultiplyTransform(Matrix matrix);
+        public void MultiplyTransform(Matrix matrix, MatrixOrder order);
+        public void ReleaseHdc();
+        public void ReleaseHdc(IntPtr hdc);
+        public void ReleaseHdcInternal(IntPtr hdc);
+        public void ResetClip();
+        public void ResetTransform();
+        public void Restore(GraphicsState gstate);
+        public void RotateTransform(float angle);
+        public void RotateTransform(float angle, MatrixOrder order);
+        public GraphicsState Save();
+        public void ScaleTransform(float sx, float sy);
+        public void ScaleTransform(float sx, float sy, MatrixOrder order);
+        public void SetClip(Graphics g);
+        public void SetClip(Graphics g, CombineMode combineMode);
+        public void SetClip(GraphicsPath path);
+        public void SetClip(GraphicsPath path, CombineMode combineMode);
+        public void SetClip(Rectangle rect);
+        public void SetClip(Rectangle rect, CombineMode combineMode);
+        public void SetClip(RectangleF rect);
+        public void SetClip(RectangleF rect, CombineMode combineMode);
+        public void SetClip(Region region, CombineMode combineMode);
+        public void TransformPoints(CoordinateSpace destSpace, CoordinateSpace srcSpace, PointF[] pts);
+        public void TransformPoints(CoordinateSpace destSpace, CoordinateSpace srcSpace, Point[] pts);
+        public void TranslateClip(int dx, int dy);
+        public void TranslateClip(float dx, float dy);
+        public void TranslateTransform(float dx, float dy);
+        public void TranslateTransform(float dx, float dy, MatrixOrder order);
+    }
+    public enum GraphicsUnit {
+        Display = 1,
+        Document = 5,
+        Inch = 4,
+        Millimeter = 6,
+        Pixel = 2,
+        Point = 3,
+        World = 0,
+    }
+    public sealed class Icon : MarshalByRefObject, ICloneable, IDisposable, ISerializable {
+        public Icon(Icon original, int width, int height);
+        public Icon(Icon original, Size size);
+        public Icon(Stream stream);
+        public Icon(Stream stream, int width, int height);
+        public Icon(Stream stream, Size size);
+        public Icon(string fileName);
+        public Icon(string fileName, int width, int height);
+        public Icon(string fileName, Size size);
+        public Icon(Type type, string resource);
+        public IntPtr Handle { get; }
+        public int Height { get; }
+        public Size Size { get; }
+        public int Width { get; }
+        public object Clone();
+        public void Dispose();
+        public static Icon ExtractAssociatedIcon(string filePath);
+        public static Icon FromHandle(IntPtr handle);
+        public void Save(Stream outputStream);
+        void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
+        public Bitmap ToBitmap();
+        public override string ToString();
+    }
+    public interface IDeviceContext : IDisposable {
+        IntPtr GetHdc();
+        void ReleaseHdc();
+    }
+    public abstract class Image : MarshalByRefObject, ICloneable, IDisposable, ISerializable {
+        public delegate bool GetThumbnailImageAbort(); {
+            public GetThumbnailImageAbort(object @object, IntPtr method);
+            public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object @object);
+            public virtual bool EndInvoke(IAsyncResult result);
+            public virtual bool Invoke();
+        }
+        public int Flags { get; }
+        public Guid[] FrameDimensionsList { get; }
+        public int Height { get; }
+        public float HorizontalResolution { get; }
+        public ColorPalette Palette { get; set; }
+        public SizeF PhysicalDimension { get; }
+        public PixelFormat PixelFormat { get; }
+        public int[] PropertyIdList { get; }
+        public PropertyItem[] PropertyItems { get; }
+        public ImageFormat RawFormat { get; }
+        public Size Size { get; }
+        public object Tag { get; set; }
+        public float VerticalResolution { get; }
+        public int Width { get; }
+        public object Clone();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        ~Image();
+        public static Image FromFile(string filename);
+        public static Image FromFile(string filename, bool useEmbeddedColorManagement);
+        public static Bitmap FromHbitmap(IntPtr hbitmap);
+        public static Bitmap FromHbitmap(IntPtr hbitmap, IntPtr hpalette);
+        public static Image FromStream(Stream stream);
+        public static Image FromStream(Stream stream, bool useEmbeddedColorManagement);
+        public static Image FromStream(Stream stream, bool useEmbeddedColorManagement, bool validateImageData);
+        public RectangleF GetBounds(ref GraphicsUnit pageUnit);
+        public EncoderParameters GetEncoderParameterList(Guid encoder);
+        public int GetFrameCount(FrameDimension dimension);
+        public static int GetPixelFormatSize(PixelFormat pixfmt);
+        public PropertyItem GetPropertyItem(int propid);
+        public Image GetThumbnailImage(int thumbWidth, int thumbHeight, Image.GetThumbnailImageAbort callback, IntPtr callbackData);
+        public static bool IsAlphaPixelFormat(PixelFormat pixfmt);
+        public static bool IsCanonicalPixelFormat(PixelFormat pixfmt);
+        public static bool IsExtendedPixelFormat(PixelFormat pixfmt);
+        public void RemovePropertyItem(int propid);
+        public void RotateFlip(RotateFlipType rotateFlipType);
+        public void Save(Stream stream, ImageCodecInfo encoder, EncoderParameters encoderParams);
+        public void Save(Stream stream, ImageFormat format);
+        public void Save(string filename);
+        public void Save(string filename, ImageCodecInfo encoder, EncoderParameters encoderParams);
+        public void Save(string filename, ImageFormat format);
+        public void SaveAdd(EncoderParameters encoderParams);
+        public void SaveAdd(Image image, EncoderParameters encoderParams);
+        public int SelectActiveFrame(FrameDimension dimension, int frameIndex);
+        public void SetPropertyItem(PropertyItem propitem);
+        void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
+    }
+    public sealed class ImageAnimator {
+        public static void Animate(Image image, EventHandler onFrameChangedHandler);
+        public static bool CanAnimate(Image image);
+        public static void StopAnimate(Image image, EventHandler onFrameChangedHandler);
+        public static void UpdateFrames();
+        public static void UpdateFrames(Image image);
+    }
+    public enum KnownColor {
+        ActiveBorder = 1,
+        ActiveCaption = 2,
+        ActiveCaptionText = 3,
+        AliceBlue = 28,
+        AntiqueWhite = 29,
+        AppWorkspace = 4,
+        Aqua = 30,
+        Aquamarine = 31,
+        Azure = 32,
+        Beige = 33,
+        Bisque = 34,
+        Black = 35,
+        BlanchedAlmond = 36,
+        Blue = 37,
+        BlueViolet = 38,
+        Brown = 39,
+        BurlyWood = 40,
+        ButtonFace = 168,
+        ButtonHighlight = 169,
+        ButtonShadow = 170,
+        CadetBlue = 41,
+        Chartreuse = 42,
+        Chocolate = 43,
+        Control = 5,
+        ControlDark = 6,
+        ControlDarkDark = 7,
+        ControlLight = 8,
+        ControlLightLight = 9,
+        ControlText = 10,
+        Coral = 44,
+        CornflowerBlue = 45,
+        Cornsilk = 46,
+        Crimson = 47,
+        Cyan = 48,
+        DarkBlue = 49,
+        DarkCyan = 50,
+        DarkGoldenrod = 51,
+        DarkGray = 52,
+        DarkGreen = 53,
+        DarkKhaki = 54,
+        DarkMagenta = 55,
+        DarkOliveGreen = 56,
+        DarkOrange = 57,
+        DarkOrchid = 58,
+        DarkRed = 59,
+        DarkSalmon = 60,
+        DarkSeaGreen = 61,
+        DarkSlateBlue = 62,
+        DarkSlateGray = 63,
+        DarkTurquoise = 64,
+        DarkViolet = 65,
+        DeepPink = 66,
+        DeepSkyBlue = 67,
+        Desktop = 11,
+        DimGray = 68,
+        DodgerBlue = 69,
+        Firebrick = 70,
+        FloralWhite = 71,
+        ForestGreen = 72,
+        Fuchsia = 73,
+        Gainsboro = 74,
+        GhostWhite = 75,
+        Gold = 76,
+        Goldenrod = 77,
+        GradientActiveCaption = 171,
+        GradientInactiveCaption = 172,
+        Gray = 78,
+        GrayText = 12,
+        Green = 79,
+        GreenYellow = 80,
+        Highlight = 13,
+        HighlightText = 14,
+        Honeydew = 81,
+        HotPink = 82,
+        HotTrack = 15,
+        InactiveBorder = 16,
+        InactiveCaption = 17,
+        InactiveCaptionText = 18,
+        IndianRed = 83,
+        Indigo = 84,
+        Info = 19,
+        InfoText = 20,
+        Ivory = 85,
+        Khaki = 86,
+        Lavender = 87,
+        LavenderBlush = 88,
+        LawnGreen = 89,
+        LemonChiffon = 90,
+        LightBlue = 91,
+        LightCoral = 92,
+        LightCyan = 93,
+        LightGoldenrodYellow = 94,
+        LightGray = 95,
+        LightGreen = 96,
+        LightPink = 97,
+        LightSalmon = 98,
+        LightSeaGreen = 99,
+        LightSkyBlue = 100,
+        LightSlateGray = 101,
+        LightSteelBlue = 102,
+        LightYellow = 103,
+        Lime = 104,
+        LimeGreen = 105,
+        Linen = 106,
+        Magenta = 107,
+        Maroon = 108,
+        MediumAquamarine = 109,
+        MediumBlue = 110,
+        MediumOrchid = 111,
+        MediumPurple = 112,
+        MediumSeaGreen = 113,
+        MediumSlateBlue = 114,
+        MediumSpringGreen = 115,
+        MediumTurquoise = 116,
+        MediumVioletRed = 117,
+        Menu = 21,
+        MenuBar = 173,
+        MenuHighlight = 174,
+        MenuText = 22,
+        MidnightBlue = 118,
+        MintCream = 119,
+        MistyRose = 120,
+        Moccasin = 121,
+        NavajoWhite = 122,
+        Navy = 123,
+        OldLace = 124,
+        Olive = 125,
+        OliveDrab = 126,
+        Orange = 127,
+        OrangeRed = 128,
+        Orchid = 129,
+        PaleGoldenrod = 130,
+        PaleGreen = 131,
+        PaleTurquoise = 132,
+        PaleVioletRed = 133,
+        PapayaWhip = 134,
+        PeachPuff = 135,
+        Peru = 136,
+        Pink = 137,
+        Plum = 138,
+        PowderBlue = 139,
+        Purple = 140,
+        Red = 141,
+        RosyBrown = 142,
+        RoyalBlue = 143,
+        SaddleBrown = 144,
+        Salmon = 145,
+        SandyBrown = 146,
+        ScrollBar = 23,
+        SeaGreen = 147,
+        SeaShell = 148,
+        Sienna = 149,
+        Silver = 150,
+        SkyBlue = 151,
+        SlateBlue = 152,
+        SlateGray = 153,
+        Snow = 154,
+        SpringGreen = 155,
+        SteelBlue = 156,
+        Tan = 157,
+        Teal = 158,
+        Thistle = 159,
+        Tomato = 160,
+        Transparent = 27,
+        Turquoise = 161,
+        Violet = 162,
+        Wheat = 163,
+        White = 164,
+        WhiteSmoke = 165,
+        Window = 24,
+        WindowFrame = 25,
+        WindowText = 26,
+        Yellow = 166,
+        YellowGreen = 167,
+    }
+    public sealed class Pen : MarshalByRefObject, ICloneable, IDisposable {
+        public Pen(Brush brush);
+        public Pen(Brush brush, float width);
+        public Pen(Color color);
+        public Pen(Color color, float width);
+        public PenAlignment Alignment { get; set; }
+        public Brush Brush { get; set; }
+        public Color Color { get; set; }
+        public float[] CompoundArray { get; set; }
+        public CustomLineCap CustomEndCap { get; set; }
+        public CustomLineCap CustomStartCap { get; set; }
+        public DashCap DashCap { get; set; }
+        public float DashOffset { get; set; }
+        public float[] DashPattern { get; set; }
+        public DashStyle DashStyle { get; set; }
+        public LineCap EndCap { get; set; }
+        public LineJoin LineJoin { get; set; }
+        public float MiterLimit { get; set; }
+        public PenType PenType { get; }
+        public LineCap StartCap { get; set; }
+        public Matrix Transform { get; set; }
+        public float Width { get; set; }
+        public object Clone();
+        public void Dispose();
+        public void MultiplyTransform(Matrix matrix);
+        public void MultiplyTransform(Matrix matrix, MatrixOrder order);
+        public void ResetTransform();
+        public void RotateTransform(float angle);
+        public void RotateTransform(float angle, MatrixOrder order);
+        public void ScaleTransform(float sx, float sy);
+        public void ScaleTransform(float sx, float sy, MatrixOrder order);
+        public void SetLineCap(LineCap startCap, LineCap endCap, DashCap dashCap);
+        public void TranslateTransform(float dx, float dy);
+        public void TranslateTransform(float dx, float dy, MatrixOrder order);
+    }
+    public static class Pens {
+        public static Pen AliceBlue { get; }
+        public static Pen AntiqueWhite { get; }
+        public static Pen Aqua { get; }
+        public static Pen Aquamarine { get; }
+        public static Pen Azure { get; }
+        public static Pen Beige { get; }
+        public static Pen Bisque { get; }
+        public static Pen Black { get; }
+        public static Pen BlanchedAlmond { get; }
+        public static Pen Blue { get; }
+        public static Pen BlueViolet { get; }
+        public static Pen Brown { get; }
+        public static Pen BurlyWood { get; }
+        public static Pen CadetBlue { get; }
+        public static Pen Chartreuse { get; }
+        public static Pen Chocolate { get; }
+        public static Pen Coral { get; }
+        public static Pen CornflowerBlue { get; }
+        public static Pen Cornsilk { get; }
+        public static Pen Crimson { get; }
+        public static Pen Cyan { get; }
+        public static Pen DarkBlue { get; }
+        public static Pen DarkCyan { get; }
+        public static Pen DarkGoldenrod { get; }
+        public static Pen DarkGray { get; }
+        public static Pen DarkGreen { get; }
+        public static Pen DarkKhaki { get; }
+        public static Pen DarkMagenta { get; }
+        public static Pen DarkOliveGreen { get; }
+        public static Pen DarkOrange { get; }
+        public static Pen DarkOrchid { get; }
+        public static Pen DarkRed { get; }
+        public static Pen DarkSalmon { get; }
+        public static Pen DarkSeaGreen { get; }
+        public static Pen DarkSlateBlue { get; }
+        public static Pen DarkSlateGray { get; }
+        public static Pen DarkTurquoise { get; }
+        public static Pen DarkViolet { get; }
+        public static Pen DeepPink { get; }
+        public static Pen DeepSkyBlue { get; }
+        public static Pen DimGray { get; }
+        public static Pen DodgerBlue { get; }
+        public static Pen Firebrick { get; }
+        public static Pen FloralWhite { get; }
+        public static Pen ForestGreen { get; }
+        public static Pen Fuchsia { get; }
+        public static Pen Gainsboro { get; }
+        public static Pen GhostWhite { get; }
+        public static Pen Gold { get; }
+        public static Pen Goldenrod { get; }
+        public static Pen Gray { get; }
+        public static Pen Green { get; }
+        public static Pen GreenYellow { get; }
+        public static Pen Honeydew { get; }
+        public static Pen HotPink { get; }
+        public static Pen IndianRed { get; }
+        public static Pen Indigo { get; }
+        public static Pen Ivory { get; }
+        public static Pen Khaki { get; }
+        public static Pen Lavender { get; }
+        public static Pen LavenderBlush { get; }
+        public static Pen LawnGreen { get; }
+        public static Pen LemonChiffon { get; }
+        public static Pen LightBlue { get; }
+        public static Pen LightCoral { get; }
+        public static Pen LightCyan { get; }
+        public static Pen LightGoldenrodYellow { get; }
+        public static Pen LightGray { get; }
+        public static Pen LightGreen { get; }
+        public static Pen LightPink { get; }
+        public static Pen LightSalmon { get; }
+        public static Pen LightSeaGreen { get; }
+        public static Pen LightSkyBlue { get; }
+        public static Pen LightSlateGray { get; }
+        public static Pen LightSteelBlue { get; }
+        public static Pen LightYellow { get; }
+        public static Pen Lime { get; }
+        public static Pen LimeGreen { get; }
+        public static Pen Linen { get; }
+        public static Pen Magenta { get; }
+        public static Pen Maroon { get; }
+        public static Pen MediumAquamarine { get; }
+        public static Pen MediumBlue { get; }
+        public static Pen MediumOrchid { get; }
+        public static Pen MediumPurple { get; }
+        public static Pen MediumSeaGreen { get; }
+        public static Pen MediumSlateBlue { get; }
+        public static Pen MediumSpringGreen { get; }
+        public static Pen MediumTurquoise { get; }
+        public static Pen MediumVioletRed { get; }
+        public static Pen MidnightBlue { get; }
+        public static Pen MintCream { get; }
+        public static Pen MistyRose { get; }
+        public static Pen Moccasin { get; }
+        public static Pen NavajoWhite { get; }
+        public static Pen Navy { get; }
+        public static Pen OldLace { get; }
+        public static Pen Olive { get; }
+        public static Pen OliveDrab { get; }
+        public static Pen Orange { get; }
+        public static Pen OrangeRed { get; }
+        public static Pen Orchid { get; }
+        public static Pen PaleGoldenrod { get; }
+        public static Pen PaleGreen { get; }
+        public static Pen PaleTurquoise { get; }
+        public static Pen PaleVioletRed { get; }
+        public static Pen PapayaWhip { get; }
+        public static Pen PeachPuff { get; }
+        public static Pen Peru { get; }
+        public static Pen Pink { get; }
+        public static Pen Plum { get; }
+        public static Pen PowderBlue { get; }
+        public static Pen Purple { get; }
+        public static Pen Red { get; }
+        public static Pen RosyBrown { get; }
+        public static Pen RoyalBlue { get; }
+        public static Pen SaddleBrown { get; }
+        public static Pen Salmon { get; }
+        public static Pen SandyBrown { get; }
+        public static Pen SeaGreen { get; }
+        public static Pen SeaShell { get; }
+        public static Pen Sienna { get; }
+        public static Pen Silver { get; }
+        public static Pen SkyBlue { get; }
+        public static Pen SlateBlue { get; }
+        public static Pen SlateGray { get; }
+        public static Pen Snow { get; }
+        public static Pen SpringGreen { get; }
+        public static Pen SteelBlue { get; }
+        public static Pen Tan { get; }
+        public static Pen Teal { get; }
+        public static Pen Thistle { get; }
+        public static Pen Tomato { get; }
+        public static Pen Transparent { get; }
+        public static Pen Turquoise { get; }
+        public static Pen Violet { get; }
+        public static Pen Wheat { get; }
+        public static Pen White { get; }
+        public static Pen WhiteSmoke { get; }
+        public static Pen Yellow { get; }
+        public static Pen YellowGreen { get; }
+    }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
-    public struct Point : IEquatable<Point> {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Point : IEquatable<Point> {
     }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
-    public struct PointF : IEquatable<PointF> {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct PointF : IEquatable<PointF> {
     }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
-    public struct Rectangle : IEquatable<Rectangle> {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Rectangle : IEquatable<Rectangle> {
     }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
-    public struct RectangleF : IEquatable<RectangleF> {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct RectangleF : IEquatable<RectangleF> {
     }
+    public sealed class Region : MarshalByRefObject, IDisposable {
+        public Region();
+        public Region(GraphicsPath path);
+        public Region(Rectangle rect);
+        public Region(RectangleF rect);
+        public Region(RegionData rgnData);
+        public Region Clone();
+        public void Complement(GraphicsPath path);
+        public void Complement(Rectangle rect);
+        public void Complement(RectangleF rect);
+        public void Complement(Region region);
+        public void Dispose();
+        public bool Equals(Region region, Graphics g);
+        public void Exclude(GraphicsPath path);
+        public void Exclude(Rectangle rect);
+        public void Exclude(RectangleF rect);
+        public void Exclude(Region region);
+        public static Region FromHrgn(IntPtr hrgn);
+        public RectangleF GetBounds(Graphics g);
+        public IntPtr GetHrgn(Graphics g);
+        public RegionData GetRegionData();
+        public RectangleF[] GetRegionScans(Matrix matrix);
+        public void Intersect(GraphicsPath path);
+        public void Intersect(Rectangle rect);
+        public void Intersect(RectangleF rect);
+        public void Intersect(Region region);
+        public bool IsEmpty(Graphics g);
+        public bool IsInfinite(Graphics g);
+        public bool IsVisible(int x, int y, Graphics g);
+        public bool IsVisible(int x, int y, int width, int height);
+        public bool IsVisible(int x, int y, int width, int height, Graphics g);
+        public bool IsVisible(Point point);
+        public bool IsVisible(Point point, Graphics g);
+        public bool IsVisible(PointF point);
+        public bool IsVisible(PointF point, Graphics g);
+        public bool IsVisible(Rectangle rect);
+        public bool IsVisible(Rectangle rect, Graphics g);
+        public bool IsVisible(RectangleF rect);
+        public bool IsVisible(RectangleF rect, Graphics g);
+        public bool IsVisible(float x, float y);
+        public bool IsVisible(float x, float y, Graphics g);
+        public bool IsVisible(float x, float y, float width, float height);
+        public bool IsVisible(float x, float y, float width, float height, Graphics g);
+        public void MakeEmpty();
+        public void MakeInfinite();
+        public void ReleaseHrgn(IntPtr regionHandle);
+        public void Transform(Matrix matrix);
+        public void Translate(int dx, int dy);
+        public void Translate(float dx, float dy);
+        public void Union(GraphicsPath path);
+        public void Union(Rectangle rect);
+        public void Union(RectangleF rect);
+        public void Union(Region region);
+        public void Xor(GraphicsPath path);
+        public void Xor(Rectangle rect);
+        public void Xor(RectangleF rect);
+        public void Xor(Region region);
+    }
+    public enum RotateFlipType {
+        Rotate180FlipNone = 2,
+        Rotate180FlipX = 6,
+        Rotate180FlipXY = 0,
+        Rotate180FlipY = 4,
+        Rotate270FlipNone = 3,
+        Rotate270FlipX = 7,
+        Rotate270FlipXY = 1,
+        Rotate270FlipY = 5,
+        Rotate90FlipNone = 1,
+        Rotate90FlipX = 5,
+        Rotate90FlipXY = 3,
+        Rotate90FlipY = 7,
+        RotateNoneFlipNone = 0,
+        RotateNoneFlipX = 4,
+        RotateNoneFlipXY = 2,
+        RotateNoneFlipY = 6,
+    }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
-    public struct Size : IEquatable<Size> {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct Size : IEquatable<Size> {
+        public static Size operator /(Size left, int right);
+        public static SizeF operator /(Size left, float right);
+        public static Size operator *(int left, Size right);
+        public static SizeF operator *(float left, Size right);
+        public static Size operator *(Size left, int right);
+        public static SizeF operator *(Size left, float right);
     }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
-    public struct SizeF : IEquatable<SizeF> {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SizeF : IEquatable<SizeF> {
+        public static SizeF operator /(SizeF left, float right);
+        public static SizeF operator *(float left, SizeF right);
+        public static SizeF operator *(SizeF left, float right);
     }
+    public sealed class SolidBrush : Brush {
+        public SolidBrush(Color color);
+        public Color Color { get; set; }
+        public override object Clone();
+    }
+    public enum StringAlignment {
+        Center = 1,
+        Far = 2,
+        Near = 0,
+    }
+    public enum StringDigitSubstitute {
+        National = 2,
+        None = 1,
+        Traditional = 3,
+        User = 0,
+    }
+    public sealed class StringFormat : MarshalByRefObject, ICloneable, IDisposable {
+        public StringFormat();
+        public StringFormat(StringFormat format);
+        public StringFormat(StringFormatFlags options);
+        public StringFormat(StringFormatFlags options, int language);
+        public StringAlignment Alignment { get; set; }
+        public int DigitSubstitutionLanguage { get; }
+        public StringDigitSubstitute DigitSubstitutionMethod { get; }
+        public StringFormatFlags FormatFlags { get; set; }
+        public static StringFormat GenericDefault { get; }
+        public static StringFormat GenericTypographic { get; }
+        public HotkeyPrefix HotkeyPrefix { get; set; }
+        public StringAlignment LineAlignment { get; set; }
+        public StringTrimming Trimming { get; set; }
+        public object Clone();
+        public void Dispose();
+        public float[] GetTabStops(out float firstTabOffset);
+        public void SetDigitSubstitution(int language, StringDigitSubstitute substitute);
+        public void SetMeasurableCharacterRanges(CharacterRange[] ranges);
+        public void SetTabStops(float firstTabOffset, float[] tabStops);
+        public override string ToString();
+    }
+    public enum StringFormatFlags {
+        DirectionRightToLeft = 1,
+        DirectionVertical = 2,
+        DisplayFormatControl = 32,
+        FitBlackBox = 4,
+        LineLimit = 8192,
+        MeasureTrailingSpaces = 2048,
+        NoClip = 16384,
+        NoFontFallback = 1024,
+        NoWrap = 4096,
+    }
+    public enum StringTrimming {
+        Character = 1,
+        EllipsisCharacter = 3,
+        EllipsisPath = 5,
+        EllipsisWord = 4,
+        None = 0,
+        Word = 2,
+    }
+    public enum StringUnit {
+        Display = 1,
+        Document = 5,
+        Em = 32,
+        Inch = 4,
+        Millimeter = 6,
+        Pixel = 2,
+        Point = 3,
+        World = 0,
+    }
+    public static class SystemBrushes {
+        public static Brush ActiveBorder { get; }
+        public static Brush ActiveCaption { get; }
+        public static Brush ActiveCaptionText { get; }
+        public static Brush AppWorkspace { get; }
+        public static Brush ButtonFace { get; }
+        public static Brush ButtonHighlight { get; }
+        public static Brush ButtonShadow { get; }
+        public static Brush Control { get; }
+        public static Brush ControlDark { get; }
+        public static Brush ControlDarkDark { get; }
+        public static Brush ControlLight { get; }
+        public static Brush ControlLightLight { get; }
+        public static Brush ControlText { get; }
+        public static Brush Desktop { get; }
+        public static Brush GradientActiveCaption { get; }
+        public static Brush GradientInactiveCaption { get; }
+        public static Brush GrayText { get; }
+        public static Brush Highlight { get; }
+        public static Brush HighlightText { get; }
+        public static Brush HotTrack { get; }
+        public static Brush InactiveBorder { get; }
+        public static Brush InactiveCaption { get; }
+        public static Brush InactiveCaptionText { get; }
+        public static Brush Info { get; }
+        public static Brush InfoText { get; }
+        public static Brush Menu { get; }
+        public static Brush MenuBar { get; }
+        public static Brush MenuHighlight { get; }
+        public static Brush MenuText { get; }
+        public static Brush ScrollBar { get; }
+        public static Brush Window { get; }
+        public static Brush WindowFrame { get; }
+        public static Brush WindowText { get; }
+        public static Brush FromSystemColor(Color c);
+    }
+    public static class SystemColors {
+        public static Color ActiveBorder { get; }
+        public static Color ActiveCaption { get; }
+        public static Color ActiveCaptionText { get; }
+        public static Color AppWorkspace { get; }
+        public static Color ButtonFace { get; }
+        public static Color ButtonHighlight { get; }
+        public static Color ButtonShadow { get; }
+        public static Color Control { get; }
+        public static Color ControlDark { get; }
+        public static Color ControlDarkDark { get; }
+        public static Color ControlLight { get; }
+        public static Color ControlLightLight { get; }
+        public static Color ControlText { get; }
+        public static Color Desktop { get; }
+        public static Color GradientActiveCaption { get; }
+        public static Color GradientInactiveCaption { get; }
+        public static Color GrayText { get; }
+        public static Color Highlight { get; }
+        public static Color HighlightText { get; }
+        public static Color HotTrack { get; }
+        public static Color InactiveBorder { get; }
+        public static Color InactiveCaption { get; }
+        public static Color InactiveCaptionText { get; }
+        public static Color Info { get; }
+        public static Color InfoText { get; }
+        public static Color Menu { get; }
+        public static Color MenuBar { get; }
+        public static Color MenuHighlight { get; }
+        public static Color MenuText { get; }
+        public static Color ScrollBar { get; }
+        public static Color Window { get; }
+        public static Color WindowFrame { get; }
+        public static Color WindowText { get; }
+    }
+    public static class SystemFonts {
+        public static Font CaptionFont { get; }
+        public static Font DefaultFont { get; }
+        public static Font DialogFont { get; }
+        public static Font IconTitleFont { get; }
+        public static Font MenuFont { get; }
+        public static Font MessageBoxFont { get; }
+        public static Font SmallCaptionFont { get; }
+        public static Font StatusFont { get; }
+        public static Font GetFontByName(string systemFontName);
+    }
+    public static class SystemIcons {
+        public static Icon Application { get; }
+        public static Icon Asterisk { get; }
+        public static Icon Error { get; }
+        public static Icon Exclamation { get; }
+        public static Icon Hand { get; }
+        public static Icon Information { get; }
+        public static Icon Question { get; }
+        public static Icon Shield { get; }
+        public static Icon Warning { get; }
+        public static Icon WinLogo { get; }
+    }
+    public static class SystemPens {
+        public static Pen ActiveBorder { get; }
+        public static Pen ActiveCaption { get; }
+        public static Pen ActiveCaptionText { get; }
+        public static Pen AppWorkspace { get; }
+        public static Pen ButtonFace { get; }
+        public static Pen ButtonHighlight { get; }
+        public static Pen ButtonShadow { get; }
+        public static Pen Control { get; }
+        public static Pen ControlDark { get; }
+        public static Pen ControlDarkDark { get; }
+        public static Pen ControlLight { get; }
+        public static Pen ControlLightLight { get; }
+        public static Pen ControlText { get; }
+        public static Pen Desktop { get; }
+        public static Pen GradientActiveCaption { get; }
+        public static Pen GradientInactiveCaption { get; }
+        public static Pen GrayText { get; }
+        public static Pen Highlight { get; }
+        public static Pen HighlightText { get; }
+        public static Pen HotTrack { get; }
+        public static Pen InactiveBorder { get; }
+        public static Pen InactiveCaption { get; }
+        public static Pen InactiveCaptionText { get; }
+        public static Pen Info { get; }
+        public static Pen InfoText { get; }
+        public static Pen Menu { get; }
+        public static Pen MenuBar { get; }
+        public static Pen MenuHighlight { get; }
+        public static Pen MenuText { get; }
+        public static Pen ScrollBar { get; }
+        public static Pen Window { get; }
+        public static Pen WindowFrame { get; }
+        public static Pen WindowText { get; }
+        public static Pen FromSystemColor(Color c);
+    }
+    public sealed class TextureBrush : Brush {
+        public TextureBrush(Image bitmap);
+        public TextureBrush(Image image, Rectangle dstRect);
+        public TextureBrush(Image image, Rectangle dstRect, ImageAttributes imageAttr);
+        public TextureBrush(Image image, RectangleF dstRect);
+        public TextureBrush(Image image, RectangleF dstRect, ImageAttributes imageAttr);
+        public TextureBrush(Image image, WrapMode wrapMode);
+        public TextureBrush(Image image, WrapMode wrapMode, Rectangle dstRect);
+        public TextureBrush(Image image, WrapMode wrapMode, RectangleF dstRect);
+        public Image Image { get; }
+        public Matrix Transform { get; set; }
+        public WrapMode WrapMode { get; set; }
+        public override object Clone();
+        public void MultiplyTransform(Matrix matrix);
+        public void MultiplyTransform(Matrix matrix, MatrixOrder order);
+        public void ResetTransform();
+        public void RotateTransform(float angle);
+        public void RotateTransform(float angle, MatrixOrder order);
+        public void ScaleTransform(float sx, float sy);
+        public void ScaleTransform(float sx, float sy, MatrixOrder order);
+        public void TranslateTransform(float dx, float dy);
+        public void TranslateTransform(float dx, float dy, MatrixOrder order);
+    }
+    public class ToolboxBitmapAttribute : Attribute {
+        public static readonly ToolboxBitmapAttribute Default;
+        public ToolboxBitmapAttribute(string imageFile);
+        public ToolboxBitmapAttribute(Type t);
+        public ToolboxBitmapAttribute(Type t, string name);
+        public override bool Equals(object value);
+        public override int GetHashCode();
+        public Image GetImage(object component);
+        public Image GetImage(object component, bool large);
+        public Image GetImage(Type type);
+        public Image GetImage(Type type, bool large);
+        public Image GetImage(Type type, string imgName, bool large);
+        public static Image GetImageFromResource(Type t, string imageName, bool large);
+    }
 }
+namespace System.Drawing.Configuration {
+    public sealed class SystemDrawingSection : ConfigurationSection {
+        public SystemDrawingSection();
+        public string BitmapSuffix { get; set; }
+    }
+}
+namespace System.Drawing.Design {
+    public sealed class CategoryNameCollection : ReadOnlyCollectionBase {
+        public CategoryNameCollection(CategoryNameCollection value);
+        public CategoryNameCollection(string[] value);
+        public string this[int index] { get; }
+        public bool Contains(string value);
+        public void CopyTo(string[] array, int index);
+        public int IndexOf(string value);
+    }
+}
+namespace System.Drawing.Drawing2D {
+    public sealed class AdjustableArrowCap : CustomLineCap {
+        public AdjustableArrowCap(float width, float height);
+        public AdjustableArrowCap(float width, float height, bool isFilled);
+        public bool Filled { get; set; }
+        public float Height { get; set; }
+        public float MiddleInset { get; set; }
+        public float Width { get; set; }
+    }
+    public sealed class Blend {
+        public Blend();
+        public Blend(int count);
+        public float[] Factors { get; set; }
+        public float[] Positions { get; set; }
+    }
+    public sealed class ColorBlend {
+        public ColorBlend();
+        public ColorBlend(int count);
+        public Color[] Colors { get; set; }
+        public float[] Positions { get; set; }
+    }
+    public enum CombineMode {
+        Complement = 5,
+        Exclude = 4,
+        Intersect = 1,
+        Replace = 0,
+        Union = 2,
+        Xor = 3,
+    }
+    public enum CompositingMode {
+        SourceCopy = 1,
+        SourceOver = 0,
+    }
+    public enum CompositingQuality {
+        AssumeLinear = 4,
+        Default = 0,
+        GammaCorrected = 3,
+        HighQuality = 2,
+        HighSpeed = 1,
+        Invalid = -1,
+    }
+    public enum CoordinateSpace {
+        Device = 2,
+        Page = 1,
+        World = 0,
+    }
+    public class CustomLineCap : MarshalByRefObject, ICloneable, IDisposable {
+        public CustomLineCap(GraphicsPath fillPath, GraphicsPath strokePath);
+        public CustomLineCap(GraphicsPath fillPath, GraphicsPath strokePath, LineCap baseCap);
+        public CustomLineCap(GraphicsPath fillPath, GraphicsPath strokePath, LineCap baseCap, float baseInset);
+        public LineCap BaseCap { get; set; }
+        public float BaseInset { get; set; }
+        public LineJoin StrokeJoin { get; set; }
+        public float WidthScale { get; set; }
+        public object Clone();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        ~CustomLineCap();
+        public void GetStrokeCaps(out LineCap startCap, out LineCap endCap);
+        public void SetStrokeCaps(LineCap startCap, LineCap endCap);
+    }
+    public enum DashCap {
+        Flat = 0,
+        Round = 2,
+        Triangle = 3,
+    }
+    public enum DashStyle {
+        Custom = 5,
+        Dash = 1,
+        DashDot = 3,
+        DashDotDot = 4,
+        Dot = 2,
+        Solid = 0,
+    }
+    public enum FillMode {
+        Alternate = 0,
+        Winding = 1,
+    }
+    public enum FlushIntention {
+        Flush = 0,
+        Sync = 1,
+    }
+    public sealed class GraphicsContainer : MarshalByRefObject
+    public sealed class GraphicsPath : MarshalByRefObject, ICloneable, IDisposable {
+        public GraphicsPath();
+        public GraphicsPath(FillMode fillMode);
+        public GraphicsPath(PointF[] pts, byte[] types);
+        public GraphicsPath(PointF[] pts, byte[] types, FillMode fillMode);
+        public GraphicsPath(Point[] pts, byte[] types);
+        public GraphicsPath(Point[] pts, byte[] types, FillMode fillMode);
+        public FillMode FillMode { get; set; }
+        public PathData PathData { get; }
+        public PointF[] PathPoints { get; }
+        public byte[] PathTypes { get; }
+        public int PointCount { get; }
+        public void AddArc(int x, int y, int width, int height, float startAngle, float sweepAngle);
+        public void AddArc(Rectangle rect, float startAngle, float sweepAngle);
+        public void AddArc(RectangleF rect, float startAngle, float sweepAngle);
+        public void AddArc(float x, float y, float width, float height, float startAngle, float sweepAngle);
+        public void AddBezier(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
+        public void AddBezier(Point pt1, Point pt2, Point pt3, Point pt4);
+        public void AddBezier(PointF pt1, PointF pt2, PointF pt3, PointF pt4);
+        public void AddBezier(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4);
+        public void AddBeziers(PointF[] points);
+        public void AddBeziers(params Point[] points);
+        public void AddClosedCurve(PointF[] points);
+        public void AddClosedCurve(PointF[] points, float tension);
+        public void AddClosedCurve(Point[] points);
+        public void AddClosedCurve(Point[] points, float tension);
+        public void AddCurve(PointF[] points);
+        public void AddCurve(PointF[] points, int offset, int numberOfSegments, float tension);
+        public void AddCurve(PointF[] points, float tension);
+        public void AddCurve(Point[] points);
+        public void AddCurve(Point[] points, int offset, int numberOfSegments, float tension);
+        public void AddCurve(Point[] points, float tension);
+        public void AddEllipse(int x, int y, int width, int height);
+        public void AddEllipse(Rectangle rect);
+        public void AddEllipse(RectangleF rect);
+        public void AddEllipse(float x, float y, float width, float height);
+        public void AddLine(int x1, int y1, int x2, int y2);
+        public void AddLine(Point pt1, Point pt2);
+        public void AddLine(PointF pt1, PointF pt2);
+        public void AddLine(float x1, float y1, float x2, float y2);
+        public void AddLines(PointF[] points);
+        public void AddLines(Point[] points);
+        public void AddPath(GraphicsPath addingPath, bool connect);
+        public void AddPie(int x, int y, int width, int height, float startAngle, float sweepAngle);
+        public void AddPie(Rectangle rect, float startAngle, float sweepAngle);
+        public void AddPie(float x, float y, float width, float height, float startAngle, float sweepAngle);
+        public void AddPolygon(PointF[] points);
+        public void AddPolygon(Point[] points);
+        public void AddRectangle(Rectangle rect);
+        public void AddRectangle(RectangleF rect);
+        public void AddRectangles(RectangleF[] rects);
+        public void AddRectangles(Rectangle[] rects);
+        public void AddString(string s, FontFamily family, int style, float emSize, Point origin, StringFormat format);
+        public void AddString(string s, FontFamily family, int style, float emSize, PointF origin, StringFormat format);
+        public void AddString(string s, FontFamily family, int style, float emSize, Rectangle layoutRect, StringFormat format);
+        public void AddString(string s, FontFamily family, int style, float emSize, RectangleF layoutRect, StringFormat format);
+        public void ClearMarkers();
+        public object Clone();
+        public void CloseAllFigures();
+        public void CloseFigure();
+        public void Dispose();
+        public void Flatten();
+        public void Flatten(Matrix matrix);
+        public void Flatten(Matrix matrix, float flatness);
+        public RectangleF GetBounds();
+        public RectangleF GetBounds(Matrix matrix);
+        public RectangleF GetBounds(Matrix matrix, Pen pen);
+        public PointF GetLastPoint();
+        public bool IsOutlineVisible(int x, int y, Pen pen);
+        public bool IsOutlineVisible(int x, int y, Pen pen, Graphics graphics);
+        public bool IsOutlineVisible(Point point, Pen pen);
+        public bool IsOutlineVisible(Point pt, Pen pen, Graphics graphics);
+        public bool IsOutlineVisible(PointF point, Pen pen);
+        public bool IsOutlineVisible(PointF pt, Pen pen, Graphics graphics);
+        public bool IsOutlineVisible(float x, float y, Pen pen);
+        public bool IsOutlineVisible(float x, float y, Pen pen, Graphics graphics);
+        public bool IsVisible(int x, int y);
+        public bool IsVisible(int x, int y, Graphics graphics);
+        public bool IsVisible(Point point);
+        public bool IsVisible(Point pt, Graphics graphics);
+        public bool IsVisible(PointF point);
+        public bool IsVisible(PointF pt, Graphics graphics);
+        public bool IsVisible(float x, float y);
+        public bool IsVisible(float x, float y, Graphics graphics);
+        public void Reset();
+        public void Reverse();
+        public void SetMarkers();
+        public void StartFigure();
+        public void Transform(Matrix matrix);
+        public void Warp(PointF[] destPoints, RectangleF srcRect);
+        public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix);
+        public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix, WarpMode warpMode);
+        public void Warp(PointF[] destPoints, RectangleF srcRect, Matrix matrix, WarpMode warpMode, float flatness);
+        public void Widen(Pen pen);
+        public void Widen(Pen pen, Matrix matrix);
+        public void Widen(Pen pen, Matrix matrix, float flatness);
+    }
+    public sealed class GraphicsPathIterator : MarshalByRefObject, IDisposable {
+        public GraphicsPathIterator(GraphicsPath path);
+        public int Count { get; }
+        public int SubpathCount { get; }
+        public int CopyData(ref PointF[] points, ref byte[] types, int startIndex, int endIndex);
+        public void Dispose();
+        public int Enumerate(ref PointF[] points, ref byte[] types);
+        public bool HasCurve();
+        public int NextMarker(GraphicsPath path);
+        public int NextMarker(out int startIndex, out int endIndex);
+        public int NextPathType(out byte pathType, out int startIndex, out int endIndex);
+        public int NextSubpath(GraphicsPath path, out bool isClosed);
+        public int NextSubpath(out int startIndex, out int endIndex, out bool isClosed);
+        public void Rewind();
+    }
+    public sealed class GraphicsState : MarshalByRefObject
+    public sealed class HatchBrush : Brush {
+        public HatchBrush(HatchStyle hatchstyle, Color foreColor);
+        public HatchBrush(HatchStyle hatchstyle, Color foreColor, Color backColor);
+        public Color BackgroundColor { get; }
+        public Color ForegroundColor { get; }
+        public HatchStyle HatchStyle { get; }
+        public override object Clone();
+    }
+    public enum HatchStyle {
+        BackwardDiagonal = 3,
+        Cross = 4,
+        DarkDownwardDiagonal = 20,
+        DarkHorizontal = 29,
+        DarkUpwardDiagonal = 21,
+        DarkVertical = 28,
+        DashedDownwardDiagonal = 30,
+        DashedHorizontal = 32,
+        DashedUpwardDiagonal = 31,
+        DashedVertical = 33,
+        DiagonalBrick = 38,
+        DiagonalCross = 5,
+        Divot = 42,
+        DottedDiamond = 44,
+        DottedGrid = 43,
+        ForwardDiagonal = 2,
+        Horizontal = 0,
+        HorizontalBrick = 39,
+        LargeCheckerBoard = 50,
+        LargeConfetti = 35,
+        LargeGrid = 4,
+        LightDownwardDiagonal = 18,
+        LightHorizontal = 25,
+        LightUpwardDiagonal = 19,
+        LightVertical = 24,
+        Max = 4,
+        Min = 0,
+        NarrowHorizontal = 27,
+        NarrowVertical = 26,
+        OutlinedDiamond = 51,
+        Percent05 = 6,
+        Percent10 = 7,
+        Percent20 = 8,
+        Percent25 = 9,
+        Percent30 = 10,
+        Percent40 = 11,
+        Percent50 = 12,
+        Percent60 = 13,
+        Percent70 = 14,
+        Percent75 = 15,
+        Percent80 = 16,
+        Percent90 = 17,
+        Plaid = 41,
+        Shingle = 45,
+        SmallCheckerBoard = 49,
+        SmallConfetti = 34,
+        SmallGrid = 48,
+        SolidDiamond = 52,
+        Sphere = 47,
+        Trellis = 46,
+        Vertical = 1,
+        Wave = 37,
+        Weave = 40,
+        WideDownwardDiagonal = 22,
+        WideUpwardDiagonal = 23,
+        ZigZag = 36,
+    }
+    public enum InterpolationMode {
+        Bicubic = 4,
+        Bilinear = 3,
+        Default = 0,
+        High = 2,
+        HighQualityBicubic = 7,
+        HighQualityBilinear = 6,
+        Invalid = -1,
+        Low = 1,
+        NearestNeighbor = 5,
+    }
+    public sealed class LinearGradientBrush : Brush {
+        public LinearGradientBrush(Point point1, Point point2, Color color1, Color color2);
+        public LinearGradientBrush(PointF point1, PointF point2, Color color1, Color color2);
+        public LinearGradientBrush(Rectangle rect, Color color1, Color color2, LinearGradientMode linearGradientMode);
+        public LinearGradientBrush(Rectangle rect, Color color1, Color color2, float angle);
+        public LinearGradientBrush(Rectangle rect, Color color1, Color color2, float angle, bool isAngleScaleable);
+        public LinearGradientBrush(RectangleF rect, Color color1, Color color2, LinearGradientMode linearGradientMode);
+        public LinearGradientBrush(RectangleF rect, Color color1, Color color2, float angle);
+        public LinearGradientBrush(RectangleF rect, Color color1, Color color2, float angle, bool isAngleScaleable);
+        public Blend Blend { get; set; }
+        public bool GammaCorrection { get; set; }
+        public ColorBlend InterpolationColors { get; set; }
+        public Color[] LinearColors { get; set; }
+        public RectangleF Rectangle { get; }
+        public Matrix Transform { get; set; }
+        public WrapMode WrapMode { get; set; }
+        public override object Clone();
+        public void MultiplyTransform(Matrix matrix);
+        public void MultiplyTransform(Matrix matrix, MatrixOrder order);
+        public void ResetTransform();
+        public void RotateTransform(float angle);
+        public void RotateTransform(float angle, MatrixOrder order);
+        public void ScaleTransform(float sx, float sy);
+        public void ScaleTransform(float sx, float sy, MatrixOrder order);
+        public void SetBlendTriangularShape(float focus);
+        public void SetBlendTriangularShape(float focus, float scale);
+        public void SetSigmaBellShape(float focus);
+        public void SetSigmaBellShape(float focus, float scale);
+        public void TranslateTransform(float dx, float dy);
+        public void TranslateTransform(float dx, float dy, MatrixOrder order);
+    }
+    public enum LinearGradientMode {
+        BackwardDiagonal = 3,
+        ForwardDiagonal = 2,
+        Horizontal = 0,
+        Vertical = 1,
+    }
+    public enum LineCap {
+        AnchorMask = 240,
+        ArrowAnchor = 20,
+        Custom = 255,
+        DiamondAnchor = 19,
+        Flat = 0,
+        NoAnchor = 16,
+        Round = 2,
+        RoundAnchor = 18,
+        Square = 1,
+        SquareAnchor = 17,
+        Triangle = 3,
+    }
+    public enum LineJoin {
+        Bevel = 1,
+        Miter = 0,
+        MiterClipped = 3,
+        Round = 2,
+    }
+    public sealed class Matrix : MarshalByRefObject, IDisposable {
+        public Matrix();
+        public Matrix(Rectangle rect, Point[] plgpts);
+        public Matrix(RectangleF rect, PointF[] plgpts);
+        public Matrix(float m11, float m12, float m21, float m22, float dx, float dy);
+        public float[] Elements { get; }
+        public bool IsIdentity { get; }
+        public bool IsInvertible { get; }
+        public float OffsetX { get; }
+        public float OffsetY { get; }
+        public Matrix Clone();
+        public void Dispose();
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public void Invert();
+        public void Multiply(Matrix matrix);
+        public void Multiply(Matrix matrix, MatrixOrder order);
+        public void Reset();
+        public void Rotate(float angle);
+        public void Rotate(float angle, MatrixOrder order);
+        public void RotateAt(float angle, PointF point);
+        public void RotateAt(float angle, PointF point, MatrixOrder order);
+        public void Scale(float scaleX, float scaleY);
+        public void Scale(float scaleX, float scaleY, MatrixOrder order);
+        public void Shear(float shearX, float shearY);
+        public void Shear(float shearX, float shearY, MatrixOrder order);
+        public void TransformPoints(PointF[] pts);
+        public void TransformPoints(Point[] pts);
+        public void TransformVectors(PointF[] pts);
+        public void TransformVectors(Point[] pts);
+        public void Translate(float offsetX, float offsetY);
+        public void Translate(float offsetX, float offsetY, MatrixOrder order);
+        public void VectorTransformPoints(Point[] pts);
+    }
+    public enum MatrixOrder {
+        Append = 1,
+        Prepend = 0,
+    }
+    public sealed class PathData {
+        public PathData();
+        public PointF[] Points { get; set; }
+        public byte[] Types { get; set; }
+    }
+    public sealed class PathGradientBrush : Brush {
+        public PathGradientBrush(GraphicsPath path);
+        public PathGradientBrush(PointF[] points);
+        public PathGradientBrush(PointF[] points, WrapMode wrapMode);
+        public PathGradientBrush(Point[] points);
+        public PathGradientBrush(Point[] points, WrapMode wrapMode);
+        public Blend Blend { get; set; }
+        public Color CenterColor { get; set; }
+        public PointF CenterPoint { get; set; }
+        public PointF FocusScales { get; set; }
+        public ColorBlend InterpolationColors { get; set; }
+        public RectangleF Rectangle { get; }
+        public Color[] SurroundColors { get; set; }
+        public Matrix Transform { get; set; }
+        public WrapMode WrapMode { get; set; }
+        public override object Clone();
+        public void MultiplyTransform(Matrix matrix);
+        public void MultiplyTransform(Matrix matrix, MatrixOrder order);
+        public void ResetTransform();
+        public void RotateTransform(float angle);
+        public void RotateTransform(float angle, MatrixOrder order);
+        public void ScaleTransform(float sx, float sy);
+        public void ScaleTransform(float sx, float sy, MatrixOrder order);
+        public void SetBlendTriangularShape(float focus);
+        public void SetBlendTriangularShape(float focus, float scale);
+        public void SetSigmaBellShape(float focus);
+        public void SetSigmaBellShape(float focus, float scale);
+        public void TranslateTransform(float dx, float dy);
+        public void TranslateTransform(float dx, float dy, MatrixOrder order);
+    }
+    public enum PathPointType {
+        Bezier = 3,
+        Bezier3 = 3,
+        CloseSubpath = 128,
+        DashMode = 16,
+        Line = 1,
+        PathMarker = 32,
+        PathTypeMask = 7,
+        Start = 0,
+    }
+    public enum PenAlignment {
+        Center = 0,
+        Inset = 1,
+        Left = 3,
+        Outset = 2,
+        Right = 4,
+    }
+    public enum PenType {
+        HatchFill = 1,
+        LinearGradient = 4,
+        PathGradient = 3,
+        SolidColor = 0,
+        TextureFill = 2,
+    }
+    public enum PixelOffsetMode {
+        Default = 0,
+        Half = 4,
+        HighQuality = 2,
+        HighSpeed = 1,
+        Invalid = -1,
+        None = 3,
+    }
+    public enum QualityMode {
+        Default = 0,
+        High = 2,
+        Invalid = -1,
+        Low = 1,
+    }
+    public sealed class RegionData {
+        public byte[] Data { get; set; }
+    }
+    public enum SmoothingMode {
+        AntiAlias = 4,
+        Default = 0,
+        HighQuality = 2,
+        HighSpeed = 1,
+        Invalid = -1,
+        None = 3,
+    }
+    public enum WarpMode {
+        Bilinear = 1,
+        Perspective = 0,
+    }
+    public enum WrapMode {
+        Clamp = 4,
+        Tile = 0,
+        TileFlipX = 1,
+        TileFlipXY = 3,
+        TileFlipY = 2,
+    }
+}
+namespace System.Drawing.Imaging {
+    public sealed class BitmapData {
+        public BitmapData();
+        public int Height { get; set; }
+        public PixelFormat PixelFormat { get; set; }
+        public int Reserved { get; set; }
+        public IntPtr Scan0 { get; set; }
+        public int Stride { get; set; }
+        public int Width { get; set; }
+    }
+    public enum ColorAdjustType {
+        Any = 6,
+        Bitmap = 1,
+        Brush = 2,
+        Count = 5,
+        Default = 0,
+        Pen = 3,
+        Text = 4,
+    }
+    public enum ColorChannelFlag {
+        ColorChannelC = 0,
+        ColorChannelK = 3,
+        ColorChannelLast = 4,
+        ColorChannelM = 1,
+        ColorChannelY = 2,
+    }
+    public sealed class ColorMap {
+        public ColorMap();
+        public Color NewColor { get; set; }
+        public Color OldColor { get; set; }
+    }
+    public enum ColorMapType {
+        Brush = 1,
+        Default = 0,
+    }
+    public sealed class ColorMatrix {
+        public ColorMatrix();
+        public ColorMatrix(float[][] newColorMatrix);
+        public float this[int row, int column] { get; set; }
+        public float Matrix00 { get; set; }
+        public float Matrix01 { get; set; }
+        public float Matrix02 { get; set; }
+        public float Matrix03 { get; set; }
+        public float Matrix04 { get; set; }
+        public float Matrix10 { get; set; }
+        public float Matrix11 { get; set; }
+        public float Matrix12 { get; set; }
+        public float Matrix13 { get; set; }
+        public float Matrix14 { get; set; }
+        public float Matrix20 { get; set; }
+        public float Matrix21 { get; set; }
+        public float Matrix22 { get; set; }
+        public float Matrix23 { get; set; }
+        public float Matrix24 { get; set; }
+        public float Matrix30 { get; set; }
+        public float Matrix31 { get; set; }
+        public float Matrix32 { get; set; }
+        public float Matrix33 { get; set; }
+        public float Matrix34 { get; set; }
+        public float Matrix40 { get; set; }
+        public float Matrix41 { get; set; }
+        public float Matrix42 { get; set; }
+        public float Matrix43 { get; set; }
+        public float Matrix44 { get; set; }
+    }
+    public enum ColorMatrixFlag {
+        AltGrays = 2,
+        Default = 0,
+        SkipGrays = 1,
+    }
+    public enum ColorMode {
+        Argb32Mode = 0,
+        Argb64Mode = 1,
+    }
+    public sealed class ColorPalette {
+        public Color[] Entries { get; }
+        public int Flags { get; }
+    }
+    public enum EmfPlusRecordType {
+        BeginContainer = 16423,
+        BeginContainerNoParams = 16424,
+        Clear = 16393,
+        Comment = 16387,
+        DrawArc = 16402,
+        DrawBeziers = 16409,
+        DrawClosedCurve = 16407,
+        DrawCurve = 16408,
+        DrawDriverString = 16438,
+        DrawEllipse = 16399,
+        DrawImage = 16410,
+        DrawImagePoints = 16411,
+        DrawLines = 16397,
+        DrawPath = 16405,
+        DrawPie = 16401,
+        DrawRects = 16395,
+        DrawString = 16412,
+        EmfAbortPath = 68,
+        EmfAlphaBlend = 114,
+        EmfAngleArc = 41,
+        EmfArcTo = 55,
+        EmfBeginPath = 59,
+        EmfBitBlt = 76,
+        EmfChord = 46,
+        EmfCloseFigure = 61,
+        EmfColorCorrectPalette = 111,
+        EmfColorMatchToTargetW = 121,
+        EmfCreateBrushIndirect = 39,
+        EmfCreateColorSpace = 99,
+        EmfCreateColorSpaceW = 122,
+        EmfCreateDibPatternBrushPt = 94,
+        EmfCreateMonoBrush = 93,
+        EmfCreatePalette = 49,
+        EmfCreatePen = 38,
+        EmfDeleteColorSpace = 101,
+        EmfDeleteObject = 40,
+        EmfDrawEscape = 105,
+        EmfEllipse = 42,
+        EmfEndPath = 60,
+        EmfEof = 14,
+        EmfExcludeClipRect = 29,
+        EmfExtCreateFontIndirect = 82,
+        EmfExtCreatePen = 95,
+        EmfExtEscape = 106,
+        EmfExtFloodFill = 53,
+        EmfExtSelectClipRgn = 75,
+        EmfExtTextOutA = 83,
+        EmfExtTextOutW = 84,
+        EmfFillPath = 62,
+        EmfFillRgn = 71,
+        EmfFlattenPath = 65,
+        EmfForceUfiMapping = 109,
+        EmfFrameRgn = 72,
+        EmfGdiComment = 70,
+        EmfGlsBoundedRecord = 103,
+        EmfGlsRecord = 102,
+        EmfGradientFill = 118,
+        EmfHeader = 1,
+        EmfIntersectClipRect = 30,
+        EmfInvertRgn = 73,
+        EmfLineTo = 54,
+        EmfMaskBlt = 78,
+        EmfMax = 122,
+        EmfMin = 1,
+        EmfModifyWorldTransform = 36,
+        EmfMoveToEx = 27,
+        EmfNamedEscpae = 110,
+        EmfOffsetClipRgn = 26,
+        EmfPaintRgn = 74,
+        EmfPie = 47,
+        EmfPixelFormat = 104,
+        EmfPlgBlt = 79,
+        EmfPlusRecordBase = 16384,
+        EmfPolyBezier = 2,
+        EmfPolyBezier16 = 85,
+        EmfPolyBezierTo = 5,
+        EmfPolyBezierTo16 = 88,
+        EmfPolyDraw = 56,
+        EmfPolyDraw16 = 92,
+        EmfPolygon = 3,
+        EmfPolygon16 = 86,
+        EmfPolyline = 4,
+        EmfPolyline16 = 87,
+        EmfPolyLineTo = 6,
+        EmfPolylineTo16 = 89,
+        EmfPolyPolygon = 8,
+        EmfPolyPolygon16 = 91,
+        EmfPolyPolyline = 7,
+        EmfPolyPolyline16 = 90,
+        EmfPolyTextOutA = 96,
+        EmfPolyTextOutW = 97,
+        EmfRealizePalette = 52,
+        EmfRectangle = 43,
+        EmfReserved069 = 69,
+        EmfReserved117 = 117,
+        EmfResizePalette = 51,
+        EmfRestoreDC = 34,
+        EmfRoundArc = 45,
+        EmfRoundRect = 44,
+        EmfSaveDC = 33,
+        EmfScaleViewportExtEx = 31,
+        EmfScaleWindowExtEx = 32,
+        EmfSelectClipPath = 67,
+        EmfSelectObject = 37,
+        EmfSelectPalette = 48,
+        EmfSetArcDirection = 57,
+        EmfSetBkColor = 25,
+        EmfSetBkMode = 18,
+        EmfSetBrushOrgEx = 13,
+        EmfSetColorAdjustment = 23,
+        EmfSetColorSpace = 100,
+        EmfSetDIBitsToDevice = 80,
+        EmfSetIcmMode = 98,
+        EmfSetIcmProfileA = 112,
+        EmfSetIcmProfileW = 113,
+        EmfSetLayout = 115,
+        EmfSetLinkedUfis = 119,
+        EmfSetMapMode = 17,
+        EmfSetMapperFlags = 16,
+        EmfSetMetaRgn = 28,
+        EmfSetMiterLimit = 58,
+        EmfSetPaletteEntries = 50,
+        EmfSetPixelV = 15,
+        EmfSetPolyFillMode = 19,
+        EmfSetROP2 = 20,
+        EmfSetStretchBltMode = 21,
+        EmfSetTextAlign = 22,
+        EmfSetTextColor = 24,
+        EmfSetTextJustification = 120,
+        EmfSetViewportExtEx = 11,
+        EmfSetViewportOrgEx = 12,
+        EmfSetWindowExtEx = 9,
+        EmfSetWindowOrgEx = 10,
+        EmfSetWorldTransform = 35,
+        EmfSmallTextOut = 108,
+        EmfStartDoc = 107,
+        EmfStretchBlt = 77,
+        EmfStretchDIBits = 81,
+        EmfStrokeAndFillPath = 63,
+        EmfStrokePath = 64,
+        EmfTransparentBlt = 116,
+        EmfWidenPath = 66,
+        EndContainer = 16425,
+        EndOfFile = 16386,
+        FillClosedCurve = 16406,
+        FillEllipse = 16398,
+        FillPath = 16404,
+        FillPie = 16400,
+        FillPolygon = 16396,
+        FillRects = 16394,
+        FillRegion = 16403,
+        GetDC = 16388,
+        Header = 16385,
+        Invalid = 16384,
+        Max = 16438,
+        Min = 16385,
+        MultiFormatEnd = 16391,
+        MultiFormatSection = 16390,
+        MultiFormatStart = 16389,
+        MultiplyWorldTransform = 16428,
+        Object = 16392,
+        OffsetClip = 16437,
+        ResetClip = 16433,
+        ResetWorldTransform = 16427,
+        Restore = 16422,
+        RotateWorldTransform = 16431,
+        Save = 16421,
+        ScaleWorldTransform = 16430,
+        SetAntiAliasMode = 16414,
+        SetClipPath = 16435,
+        SetClipRect = 16434,
+        SetClipRegion = 16436,
+        SetCompositingMode = 16419,
+        SetCompositingQuality = 16420,
+        SetInterpolationMode = 16417,
+        SetPageTransform = 16432,
+        SetPixelOffsetMode = 16418,
+        SetRenderingOrigin = 16413,
+        SetTextContrast = 16416,
+        SetTextRenderingHint = 16415,
+        SetWorldTransform = 16426,
+        Total = 16439,
+        TranslateWorldTransform = 16429,
+        WmfAnimatePalette = 66614,
+        WmfArc = 67607,
+        WmfBitBlt = 67874,
+        WmfChord = 67632,
+        WmfCreateBrushIndirect = 66300,
+        WmfCreateFontIndirect = 66299,
+        WmfCreatePalette = 65783,
+        WmfCreatePatternBrush = 66041,
+        WmfCreatePenIndirect = 66298,
+        WmfCreateRegion = 67327,
+        WmfDeleteObject = 66032,
+        WmfDibBitBlt = 67904,
+        WmfDibCreatePatternBrush = 65858,
+        WmfDibStretchBlt = 68417,
+        WmfEllipse = 66584,
+        WmfEscape = 67110,
+        WmfExcludeClipRect = 66581,
+        WmfExtFloodFill = 66888,
+        WmfExtTextOut = 68146,
+        WmfFillRegion = 66088,
+        WmfFloodFill = 66585,
+        WmfFrameRegion = 66601,
+        WmfIntersectClipRect = 66582,
+        WmfInvertRegion = 65834,
+        WmfLineTo = 66067,
+        WmfMoveTo = 66068,
+        WmfOffsetCilpRgn = 66080,
+        WmfOffsetViewportOrg = 66065,
+        WmfOffsetWindowOrg = 66063,
+        WmfPaintRegion = 65835,
+        WmfPatBlt = 67101,
+        WmfPie = 67610,
+        WmfPolygon = 66340,
+        WmfPolyline = 66341,
+        WmfPolyPolygon = 66872,
+        WmfRealizePalette = 65589,
+        WmfRecordBase = 65536,
+        WmfRectangle = 66587,
+        WmfResizePalette = 65849,
+        WmfRestoreDC = 65831,
+        WmfRoundRect = 67100,
+        WmfSaveDC = 65566,
+        WmfScaleViewportExt = 66578,
+        WmfScaleWindowExt = 66576,
+        WmfSelectClipRegion = 65836,
+        WmfSelectObject = 65837,
+        WmfSelectPalette = 66100,
+        WmfSetBkColor = 66049,
+        WmfSetBkMode = 65794,
+        WmfSetDibToDev = 68915,
+        WmfSetLayout = 65865,
+        WmfSetMapMode = 65795,
+        WmfSetMapperFlags = 66097,
+        WmfSetPalEntries = 65591,
+        WmfSetPixel = 66591,
+        WmfSetPolyFillMode = 65798,
+        WmfSetRelAbs = 65797,
+        WmfSetROP2 = 65796,
+        WmfSetStretchBltMode = 65799,
+        WmfSetTextAlign = 65838,
+        WmfSetTextCharExtra = 65800,
+        WmfSetTextColor = 66057,
+        WmfSetTextJustification = 66058,
+        WmfSetViewportExt = 66062,
+        WmfSetViewportOrg = 66061,
+        WmfSetWindowExt = 66060,
+        WmfSetWindowOrg = 66059,
+        WmfStretchBlt = 68387,
+        WmfStretchDib = 69443,
+        WmfTextOut = 66849,
+    }
+    public enum EmfType {
+        EmfOnly = 3,
+        EmfPlusDual = 5,
+        EmfPlusOnly = 4,
+    }
+    public sealed class Encoder {
+        public static readonly Encoder ChrominanceTable;
+        public static readonly Encoder ColorDepth;
+        public static readonly Encoder Compression;
+        public static readonly Encoder LuminanceTable;
+        public static readonly Encoder Quality;
+        public static readonly Encoder RenderMethod;
+        public static readonly Encoder SaveFlag;
+        public static readonly Encoder ScanMethod;
+        public static readonly Encoder Transformation;
+        public static readonly Encoder Version;
+        public Encoder(Guid guid);
+        public Guid Guid { get; }
+    }
+    public sealed class EncoderParameter : IDisposable {
+        public EncoderParameter(Encoder encoder, byte value);
+        public EncoderParameter(Encoder encoder, byte value, bool undefined);
+        public EncoderParameter(Encoder encoder, byte[] value);
+        public EncoderParameter(Encoder encoder, byte[] value, bool undefined);
+        public EncoderParameter(Encoder encoder, short value);
+        public EncoderParameter(Encoder encoder, short[] value);
+        public EncoderParameter(Encoder encoder, int numberValues, EncoderParameterValueType type, IntPtr value);
+        public EncoderParameter(Encoder encoder, int numerator, int denominator);
+        public EncoderParameter(Encoder encoder, int NumberOfValues, int Type, int Value);
+        public EncoderParameter(Encoder encoder, int numerator1, int demoninator1, int numerator2, int demoninator2);
+        public EncoderParameter(Encoder encoder, int[] numerator, int[] denominator);
+        public EncoderParameter(Encoder encoder, int[] numerator1, int[] denominator1, int[] numerator2, int[] denominator2);
+        public EncoderParameter(Encoder encoder, long value);
+        public EncoderParameter(Encoder encoder, long rangebegin, long rangeend);
+        public EncoderParameter(Encoder encoder, long[] value);
+        public EncoderParameter(Encoder encoder, long[] rangebegin, long[] rangeend);
+        public EncoderParameter(Encoder encoder, string value);
+        public Encoder Encoder { get; set; }
+        public int NumberOfValues { get; }
+        public EncoderParameterValueType Type { get; }
+        public EncoderParameterValueType ValueType { get; }
+        public void Dispose();
+    }
+    public sealed class EncoderParameters : IDisposable {
+        public EncoderParameters();
+        public EncoderParameters(int count);
+        public EncoderParameter[] Param { get; set; }
+        public void Dispose();
+    }
+    public enum EncoderParameterValueType {
+        ValueTypeAscii = 2,
+        ValueTypeByte = 1,
+        ValueTypeLong = 4,
+        ValueTypeLongRange = 6,
+        ValueTypeRational = 5,
+        ValueTypeRationalRange = 8,
+        ValueTypeShort = 3,
+        ValueTypeUndefined = 7,
+    }
+    public enum EncoderValue {
+        ColorTypeCMYK = 0,
+        ColorTypeYCCK = 1,
+        CompressionCCITT3 = 3,
+        CompressionCCITT4 = 4,
+        CompressionLZW = 2,
+        CompressionNone = 6,
+        CompressionRle = 5,
+        Flush = 20,
+        FrameDimensionPage = 23,
+        FrameDimensionResolution = 22,
+        FrameDimensionTime = 21,
+        LastFrame = 19,
+        MultiFrame = 18,
+        RenderNonProgressive = 12,
+        RenderProgressive = 11,
+        ScanMethodInterlaced = 7,
+        ScanMethodNonInterlaced = 8,
+        TransformFlipHorizontal = 16,
+        TransformFlipVertical = 17,
+        TransformRotate180 = 14,
+        TransformRotate270 = 15,
+        TransformRotate90 = 13,
+        VersionGif87 = 9,
+        VersionGif89 = 10,
+    }
+    public sealed class FrameDimension {
+        public FrameDimension(Guid guid);
+        public Guid Guid { get; }
+        public static FrameDimension Page { get; }
+        public static FrameDimension Resolution { get; }
+        public static FrameDimension Time { get; }
+        public override bool Equals(object o);
+        public override int GetHashCode();
+        public override string ToString();
+    }
+    public sealed class ImageAttributes : ICloneable, IDisposable {
+        public ImageAttributes();
+        public void ClearBrushRemapTable();
+        public void ClearColorKey();
+        public void ClearColorKey(ColorAdjustType type);
+        public void ClearColorMatrix();
+        public void ClearColorMatrix(ColorAdjustType type);
+        public void ClearGamma();
+        public void ClearGamma(ColorAdjustType type);
+        public void ClearNoOp();
+        public void ClearNoOp(ColorAdjustType type);
+        public void ClearOutputChannel();
+        public void ClearOutputChannel(ColorAdjustType type);
+        public void ClearOutputChannelColorProfile();
+        public void ClearOutputChannelColorProfile(ColorAdjustType type);
+        public void ClearRemapTable();
+        public void ClearRemapTable(ColorAdjustType type);
+        public void ClearThreshold();
+        public void ClearThreshold(ColorAdjustType type);
+        public object Clone();
+        public void Dispose();
+        public void GetAdjustedPalette(ColorPalette palette, ColorAdjustType type);
+        public void SetBrushRemapTable(ColorMap[] map);
+        public void SetColorKey(Color colorLow, Color colorHigh);
+        public void SetColorKey(Color colorLow, Color colorHigh, ColorAdjustType type);
+        public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix);
+        public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix, ColorMatrixFlag flags);
+        public void SetColorMatrices(ColorMatrix newColorMatrix, ColorMatrix grayMatrix, ColorMatrixFlag mode, ColorAdjustType type);
+        public void SetColorMatrix(ColorMatrix newColorMatrix);
+        public void SetColorMatrix(ColorMatrix newColorMatrix, ColorMatrixFlag flags);
+        public void SetColorMatrix(ColorMatrix newColorMatrix, ColorMatrixFlag mode, ColorAdjustType type);
+        public void SetGamma(float gamma);
+        public void SetGamma(float gamma, ColorAdjustType type);
+        public void SetNoOp();
+        public void SetNoOp(ColorAdjustType type);
+        public void SetOutputChannel(ColorChannelFlag flags);
+        public void SetOutputChannel(ColorChannelFlag flags, ColorAdjustType type);
+        public void SetOutputChannelColorProfile(string colorProfileFilename);
+        public void SetOutputChannelColorProfile(string colorProfileFilename, ColorAdjustType type);
+        public void SetRemapTable(ColorMap[] map);
+        public void SetRemapTable(ColorMap[] map, ColorAdjustType type);
+        public void SetThreshold(float threshold);
+        public void SetThreshold(float threshold, ColorAdjustType type);
+        public void SetWrapMode(WrapMode mode);
+        public void SetWrapMode(WrapMode mode, Color color);
+        public void SetWrapMode(WrapMode mode, Color color, bool clamp);
+    }
+    public enum ImageCodecFlags {
+        BlockingDecode = 32,
+        Builtin = 65536,
+        Decoder = 2,
+        Encoder = 1,
+        SeekableEncode = 16,
+        SupportBitmap = 4,
+        SupportVector = 8,
+        System = 131072,
+        User = 262144,
+    }
+    public sealed class ImageCodecInfo {
+        public Guid Clsid { get; set; }
+        public string CodecName { get; set; }
+        public string DllName { get; set; }
+        public string FilenameExtension { get; set; }
+        public ImageCodecFlags Flags { get; set; }
+        public string FormatDescription { get; set; }
+        public Guid FormatID { get; set; }
+        public string MimeType { get; set; }
+        public byte[][] SignatureMasks { get; set; }
+        public byte[][] SignaturePatterns { get; set; }
+        public int Version { get; set; }
+        public static ImageCodecInfo[] GetImageDecoders();
+        public static ImageCodecInfo[] GetImageEncoders();
+    }
+    public enum ImageFlags {
+        Caching = 131072,
+        ColorSpaceCmyk = 32,
+        ColorSpaceGray = 64,
+        ColorSpaceRgb = 16,
+        ColorSpaceYcbcr = 128,
+        ColorSpaceYcck = 256,
+        HasAlpha = 2,
+        HasRealDpi = 4096,
+        HasRealPixelSize = 8192,
+        HasTranslucent = 4,
+        None = 0,
+        PartiallyScalable = 8,
+        ReadOnly = 65536,
+        Scalable = 1,
+    }
+    public sealed class ImageFormat {
+        public ImageFormat(Guid guid);
+        public static ImageFormat Bmp { get; }
+        public static ImageFormat Emf { get; }
+        public static ImageFormat Exif { get; }
+        public static ImageFormat Gif { get; }
+        public Guid Guid { get; }
+        public static ImageFormat Icon { get; }
+        public static ImageFormat Jpeg { get; }
+        public static ImageFormat MemoryBmp { get; }
+        public static ImageFormat Png { get; }
+        public static ImageFormat Tiff { get; }
+        public static ImageFormat Wmf { get; }
+        public override bool Equals(object o);
+        public override int GetHashCode();
+        public override string ToString();
+    }
+    public enum ImageLockMode {
+        ReadOnly = 1,
+        ReadWrite = 3,
+        UserInputBuffer = 4,
+        WriteOnly = 2,
+    }
+    public sealed class Metafile : Image {
+        public Metafile(IntPtr henhmetafile, bool deleteEmf);
+        public Metafile(IntPtr referenceHdc, EmfType emfType);
+        public Metafile(IntPtr referenceHdc, EmfType emfType, string description);
+        public Metafile(IntPtr referenceHdc, Rectangle frameRect);
+        public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit);
+        public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type);
+        public Metafile(IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type, string desc);
+        public Metafile(IntPtr referenceHdc, RectangleF frameRect);
+        public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit);
+        public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type);
+        public Metafile(IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type, string description);
+        public Metafile(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader);
+        public Metafile(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader, bool deleteWmf);
+        public Metafile(Stream stream);
+        public Metafile(Stream stream, IntPtr referenceHdc);
+        public Metafile(Stream stream, IntPtr referenceHdc, EmfType type);
+        public Metafile(Stream stream, IntPtr referenceHdc, EmfType type, string description);
+        public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect);
+        public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit);
+        public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type);
+        public Metafile(Stream stream, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type, string description);
+        public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect);
+        public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit);
+        public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type);
+        public Metafile(Stream stream, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type, string description);
+        public Metafile(string filename);
+        public Metafile(string fileName, IntPtr referenceHdc);
+        public Metafile(string fileName, IntPtr referenceHdc, EmfType type);
+        public Metafile(string fileName, IntPtr referenceHdc, EmfType type, string description);
+        public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect);
+        public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit);
+        public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type);
+        public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, EmfType type, string description);
+        public Metafile(string fileName, IntPtr referenceHdc, Rectangle frameRect, MetafileFrameUnit frameUnit, string description);
+        public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect);
+        public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit);
+        public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type);
+        public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, EmfType type, string description);
+        public Metafile(string fileName, IntPtr referenceHdc, RectangleF frameRect, MetafileFrameUnit frameUnit, string desc);
+        public IntPtr GetHenhmetafile();
+        public MetafileHeader GetMetafileHeader();
+        public static MetafileHeader GetMetafileHeader(IntPtr henhmetafile);
+        public static MetafileHeader GetMetafileHeader(IntPtr hmetafile, WmfPlaceableFileHeader wmfHeader);
+        public static MetafileHeader GetMetafileHeader(Stream stream);
+        public static MetafileHeader GetMetafileHeader(string fileName);
+        public void PlayRecord(EmfPlusRecordType recordType, int flags, int dataSize, byte[] data);
+    }
+    public enum MetafileFrameUnit {
+        Document = 5,
+        GdiCompatible = 7,
+        Inch = 4,
+        Millimeter = 6,
+        Pixel = 2,
+        Point = 3,
+    }
+    public sealed class MetafileHeader {
+        public Rectangle Bounds { get; }
+        public float DpiX { get; }
+        public float DpiY { get; }
+        public int EmfPlusHeaderSize { get; }
+        public int LogicalDpiX { get; }
+        public int LogicalDpiY { get; }
+        public int MetafileSize { get; }
+        public MetafileType Type { get; }
+        public int Version { get; }
+        public MetaHeader WmfHeader { get; }
+        public bool IsDisplay();
+        public bool IsEmf();
+        public bool IsEmfOrEmfPlus();
+        public bool IsEmfPlus();
+        public bool IsEmfPlusDual();
+        public bool IsEmfPlusOnly();
+        public bool IsWmf();
+        public bool IsWmfPlaceable();
+    }
+    public enum MetafileType {
+        Emf = 3,
+        EmfPlusDual = 5,
+        EmfPlusOnly = 4,
+        Invalid = 0,
+        Wmf = 1,
+        WmfPlaceable = 2,
+    }
+    public sealed class MetaHeader {
+        public MetaHeader();
+        public short HeaderSize { get; set; }
+        public int MaxRecord { get; set; }
+        public short NoObjects { get; set; }
+        public short NoParameters { get; set; }
+        public int Size { get; set; }
+        public short Type { get; set; }
+        public short Version { get; set; }
+    }
+    public enum PaletteFlags {
+        GrayScale = 2,
+        Halftone = 4,
+        HasAlpha = 1,
+    }
+    public enum PixelFormat {
+        Alpha = 262144,
+        Canonical = 2097152,
+        DontCare = 0,
+        Extended = 1048576,
+        Format16bppArgb1555 = 397319,
+        Format16bppGrayScale = 1052676,
+        Format16bppRgb555 = 135173,
+        Format16bppRgb565 = 135174,
+        Format1bppIndexed = 196865,
+        Format24bppRgb = 137224,
+        Format32bppArgb = 2498570,
+        Format32bppPArgb = 925707,
+        Format32bppRgb = 139273,
+        Format48bppRgb = 1060876,
+        Format4bppIndexed = 197634,
+        Format64bppArgb = 3424269,
+        Format64bppPArgb = 1851406,
+        Format8bppIndexed = 198659,
+        Gdi = 131072,
+        Indexed = 65536,
+        Max = 15,
+        PAlpha = 524288,
+        Undefined = 0,
+    }
+    public delegate void PlayRecordCallback(EmfPlusRecordType recordType, int flags, int dataSize, IntPtr recordData); {
+        public PlayRecordCallback(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(EmfPlusRecordType recordType, int flags, int dataSize, IntPtr recordData, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(EmfPlusRecordType recordType, int flags, int dataSize, IntPtr recordData);
+    }
+    public sealed class PropertyItem {
+        public int Id { get; set; }
+        public int Len { get; set; }
+        public short Type { get; set; }
+        public byte[] Value { get; set; }
+    }
+    public sealed class WmfPlaceableFileHeader {
+        public WmfPlaceableFileHeader();
+        public short BboxBottom { get; set; }
+        public short BboxLeft { get; set; }
+        public short BboxRight { get; set; }
+        public short BboxTop { get; set; }
+        public short Checksum { get; set; }
+        public short Hmf { get; set; }
+        public short Inch { get; set; }
+        public int Key { get; set; }
+        public int Reserved { get; set; }
+    }
+}
+namespace System.Drawing.Printing {
+    public enum Duplex {
+        Default = -1,
+        Horizontal = 3,
+        Simplex = 1,
+        Vertical = 2,
+    }
+    public class InvalidPrinterException : SystemException {
+        public InvalidPrinterException(PrinterSettings settings);
+        protected InvalidPrinterException(SerializationInfo info, StreamingContext context);
+        public override void GetObjectData(SerializationInfo info, StreamingContext context);
+    }
+    public class Margins : ICloneable {
+        public Margins();
+        public Margins(int left, int right, int top, int bottom);
+        public int Bottom { get; set; }
+        public int Left { get; set; }
+        public int Right { get; set; }
+        public int Top { get; set; }
+        public object Clone();
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static bool operator ==(Margins m1, Margins m2);
+        public static bool operator !=(Margins m1, Margins m2);
+        public override string ToString();
+    }
+    public class PageSettings : ICloneable {
+        public PageSettings();
+        public PageSettings(PrinterSettings printerSettings);
+        public Rectangle Bounds { get; }
+        public bool Color { get; set; }
+        public float HardMarginX { get; }
+        public float HardMarginY { get; }
+        public bool Landscape { get; set; }
+        public Margins Margins { get; set; }
+        public PaperSize PaperSize { get; set; }
+        public PaperSource PaperSource { get; set; }
+        public RectangleF PrintableArea { get; }
+        public PrinterResolution PrinterResolution { get; set; }
+        public PrinterSettings PrinterSettings { get; set; }
+        public object Clone();
+        public void CopyToHdevmode(IntPtr hdevmode);
+        public void SetHdevmode(IntPtr hdevmode);
+        public override string ToString();
+    }
+    public enum PaperKind {
+        A2 = 66,
+        A3 = 8,
+        A3Extra = 63,
+        A3ExtraTransverse = 68,
+        A3Rotated = 76,
+        A3Transverse = 67,
+        A4 = 9,
+        A4Extra = 53,
+        A4Plus = 60,
+        A4Rotated = 77,
+        A4Small = 10,
+        A4Transverse = 55,
+        A5 = 11,
+        A5Extra = 64,
+        A5Rotated = 78,
+        A5Transverse = 61,
+        A6 = 70,
+        A6Rotated = 83,
+        APlus = 57,
+        B4 = 12,
+        B4Envelope = 33,
+        B4JisRotated = 79,
+        B5 = 13,
+        B5Envelope = 34,
+        B5Extra = 65,
+        B5JisRotated = 80,
+        B5Transverse = 62,
+        B6Envelope = 35,
+        B6Jis = 88,
+        B6JisRotated = 89,
+        BPlus = 58,
+        C3Envelope = 29,
+        C4Envelope = 30,
+        C5Envelope = 28,
+        C65Envelope = 32,
+        C6Envelope = 31,
+        CSheet = 24,
+        Custom = 0,
+        DLEnvelope = 27,
+        DSheet = 25,
+        ESheet = 26,
+        Executive = 7,
+        Folio = 14,
+        GermanLegalFanfold = 41,
+        GermanStandardFanfold = 40,
+        InviteEnvelope = 47,
+        IsoB4 = 42,
+        ItalyEnvelope = 36,
+        JapaneseDoublePostcard = 69,
+        JapaneseDoublePostcardRotated = 82,
+        JapaneseEnvelopeChouNumber3 = 73,
+        JapaneseEnvelopeChouNumber3Rotated = 86,
+        JapaneseEnvelopeChouNumber4 = 74,
+        JapaneseEnvelopeChouNumber4Rotated = 87,
+        JapaneseEnvelopeKakuNumber2 = 71,
+        JapaneseEnvelopeKakuNumber2Rotated = 84,
+        JapaneseEnvelopeKakuNumber3 = 72,
+        JapaneseEnvelopeKakuNumber3Rotated = 85,
+        JapaneseEnvelopeYouNumber4 = 91,
+        JapaneseEnvelopeYouNumber4Rotated = 92,
+        JapanesePostcard = 43,
+        JapanesePostcardRotated = 81,
+        Ledger = 4,
+        Legal = 5,
+        LegalExtra = 51,
+        Letter = 1,
+        LetterExtra = 50,
+        LetterExtraTransverse = 56,
+        LetterPlus = 59,
+        LetterRotated = 75,
+        LetterSmall = 2,
+        LetterTransverse = 54,
+        MonarchEnvelope = 37,
+        Note = 18,
+        Number10Envelope = 20,
+        Number11Envelope = 21,
+        Number12Envelope = 22,
+        Number14Envelope = 23,
+        Number9Envelope = 19,
+        PersonalEnvelope = 38,
+        Prc16K = 93,
+        Prc16KRotated = 106,
+        Prc32K = 94,
+        Prc32KBig = 95,
+        Prc32KBigRotated = 108,
+        Prc32KRotated = 107,
+        PrcEnvelopeNumber1 = 96,
+        PrcEnvelopeNumber10 = 105,
+        PrcEnvelopeNumber10Rotated = 118,
+        PrcEnvelopeNumber1Rotated = 109,
+        PrcEnvelopeNumber2 = 97,
+        PrcEnvelopeNumber2Rotated = 110,
+        PrcEnvelopeNumber3 = 98,
+        PrcEnvelopeNumber3Rotated = 111,
+        PrcEnvelopeNumber4 = 99,
+        PrcEnvelopeNumber4Rotated = 112,
+        PrcEnvelopeNumber5 = 100,
+        PrcEnvelopeNumber5Rotated = 113,
+        PrcEnvelopeNumber6 = 101,
+        PrcEnvelopeNumber6Rotated = 114,
+        PrcEnvelopeNumber7 = 102,
+        PrcEnvelopeNumber7Rotated = 115,
+        PrcEnvelopeNumber8 = 103,
+        PrcEnvelopeNumber8Rotated = 116,
+        PrcEnvelopeNumber9 = 104,
+        PrcEnvelopeNumber9Rotated = 117,
+        Quarto = 15,
+        Standard10x11 = 45,
+        Standard10x14 = 16,
+        Standard11x17 = 17,
+        Standard12x11 = 90,
+        Standard15x11 = 46,
+        Standard9x11 = 44,
+        Statement = 6,
+        Tabloid = 3,
+        TabloidExtra = 52,
+        USStandardFanfold = 39,
+    }
+    public class PaperSize {
+        public PaperSize();
+        public PaperSize(string name, int width, int height);
+        public int Height { get; set; }
+        public PaperKind Kind { get; }
+        public string PaperName { get; set; }
+        public int RawKind { get; set; }
+        public int Width { get; set; }
+        public override string ToString();
+    }
+    public class PaperSource {
+        public PaperSource();
+        public PaperSourceKind Kind { get; }
+        public int RawKind { get; set; }
+        public string SourceName { get; set; }
+        public override string ToString();
+    }
+    public enum PaperSourceKind {
+        AutomaticFeed = 7,
+        Cassette = 14,
+        Custom = 257,
+        Envelope = 5,
+        FormSource = 15,
+        LargeCapacity = 11,
+        LargeFormat = 10,
+        Lower = 2,
+        Manual = 4,
+        ManualFeed = 6,
+        Middle = 3,
+        SmallFormat = 9,
+        TractorFeed = 8,
+        Upper = 1,
+    }
+    public sealed class PreviewPageInfo {
+        public PreviewPageInfo(Image image, Size physicalSize);
+        public Image Image { get; }
+        public Size PhysicalSize { get; }
+    }
+    public class PreviewPrintController : PrintController {
+        public PreviewPrintController();
+        public override bool IsPreview { get; }
+        public virtual bool UseAntiAlias { get; set; }
+        public PreviewPageInfo[] GetPreviewPageInfo();
+        public override void OnEndPage(PrintDocument document, PrintPageEventArgs e);
+        public override void OnEndPrint(PrintDocument document, PrintEventArgs e);
+        public override Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e);
+        public override void OnStartPrint(PrintDocument document, PrintEventArgs e);
+    }
+    public enum PrintAction {
+        PrintToFile = 0,
+        PrintToPreview = 1,
+        PrintToPrinter = 2,
+    }
+    public abstract class PrintController {
+        protected PrintController();
+        public virtual bool IsPreview { get; }
+        public virtual void OnEndPage(PrintDocument document, PrintPageEventArgs e);
+        public virtual void OnEndPrint(PrintDocument document, PrintEventArgs e);
+        public virtual Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e);
+        public virtual void OnStartPrint(PrintDocument document, PrintEventArgs e);
+    }
+    public class PrintDocument : Component {
+        public PrintDocument();
+        public PageSettings DefaultPageSettings { get; set; }
+        public string DocumentName { get; set; }
+        public bool OriginAtMargins { get; set; }
+        public PrintController PrintController { get; set; }
+        public PrinterSettings PrinterSettings { get; set; }
+        protected virtual void OnBeginPrint(PrintEventArgs e);
+        protected virtual void OnEndPrint(PrintEventArgs e);
+        protected virtual void OnPrintPage(PrintPageEventArgs e);
+        protected virtual void OnQueryPageSettings(QueryPageSettingsEventArgs e);
+        public void Print();
+        public override string ToString();
+        public event PrintEventHandler BeginPrint;
+        public event PrintEventHandler EndPrint;
+        public event PrintPageEventHandler PrintPage;
+        public event QueryPageSettingsEventHandler QueryPageSettings;
+    }
+    public class PrinterResolution {
+        public PrinterResolution();
+        public PrinterResolutionKind Kind { get; set; }
+        public int X { get; set; }
+        public int Y { get; set; }
+        public override string ToString();
+    }
+    public enum PrinterResolutionKind {
+        Custom = 0,
+        Draft = -1,
+        High = -4,
+        Low = -2,
+        Medium = -3,
+    }
+    public class PrinterSettings : ICloneable {
+        public class PaperSizeCollection : ICollection, IEnumerable {
+            public PaperSizeCollection(PaperSize[] array);
+            public int Count { get; }
+            public virtual PaperSize this[int index] { get; }
+            int System.Collections.ICollection.Count { get; }
+            bool System.Collections.ICollection.IsSynchronized { get; }
+            object System.Collections.ICollection.SyncRoot { get; }
+            public int Add(PaperSize paperSize);
+            public void CopyTo(PaperSize[] paperSizes, int index);
+            public IEnumerator GetEnumerator();
+            void System.Collections.ICollection.CopyTo(Array array, int index);
+            get;
+            get;
+            get;
+            IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        }
+        public class PaperSourceCollection : ICollection, IEnumerable {
+            public PaperSourceCollection(PaperSource[] array);
+            public int Count { get; }
+            public virtual PaperSource this[int index] { get; }
+            int System.Collections.ICollection.Count { get; }
+            bool System.Collections.ICollection.IsSynchronized { get; }
+            object System.Collections.ICollection.SyncRoot { get; }
+            public int Add(PaperSource paperSource);
+            public void CopyTo(PaperSource[] paperSources, int index);
+            public IEnumerator GetEnumerator();
+            void System.Collections.ICollection.CopyTo(Array array, int index);
+            get;
+            get;
+            get;
+            IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        }
+        public class PrinterResolutionCollection : ICollection, IEnumerable {
+            public PrinterResolutionCollection(PrinterResolution[] array);
+            public int Count { get; }
+            public virtual PrinterResolution this[int index] { get; }
+            int System.Collections.ICollection.Count { get; }
+            bool System.Collections.ICollection.IsSynchronized { get; }
+            object System.Collections.ICollection.SyncRoot { get; }
+            public int Add(PrinterResolution printerResolution);
+            public void CopyTo(PrinterResolution[] printerResolutions, int index);
+            public IEnumerator GetEnumerator();
+            void System.Collections.ICollection.CopyTo(Array array, int index);
+            get;
+            get;
+            get;
+            IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        }
+        public class StringCollection : ICollection, IEnumerable {
+            public StringCollection(string[] array);
+            public int Count { get; }
+            public virtual string this[int index] { get; }
+            int System.Collections.ICollection.Count { get; }
+            bool System.Collections.ICollection.IsSynchronized { get; }
+            object System.Collections.ICollection.SyncRoot { get; }
+            public int Add(string value);
+            public void CopyTo(string[] strings, int index);
+            public IEnumerator GetEnumerator();
+            void System.Collections.ICollection.CopyTo(Array array, int index);
+            get;
+            get;
+            get;
+            IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        }
+        public PrinterSettings();
+        public bool CanDuplex { get; }
+        public bool Collate { get; set; }
+        public short Copies { get; set; }
+        public PageSettings DefaultPageSettings { get; }
+        public Duplex Duplex { get; set; }
+        public int FromPage { get; set; }
+        public static PrinterSettings.StringCollection InstalledPrinters { get; }
+        public bool IsDefaultPrinter { get; }
+        public bool IsPlotter { get; }
+        public bool IsValid { get; }
+        public int LandscapeAngle { get; }
+        public int MaximumCopies { get; }
+        public int MaximumPage { get; set; }
+        public int MinimumPage { get; set; }
+        public PrinterSettings.PaperSizeCollection PaperSizes { get; }
+        public PrinterSettings.PaperSourceCollection PaperSources { get; }
+        public string PrinterName { get; set; }
+        public PrinterSettings.PrinterResolutionCollection PrinterResolutions { get; }
+        public string PrintFileName { get; set; }
+        public PrintRange PrintRange { get; set; }
+        public bool PrintToFile { get; set; }
+        public bool SupportsColor { get; }
+        public int ToPage { get; set; }
+        public object Clone();
+        public Graphics CreateMeasurementGraphics();
+        public Graphics CreateMeasurementGraphics(bool honorOriginAtMargins);
+        public Graphics CreateMeasurementGraphics(PageSettings pageSettings);
+        public Graphics CreateMeasurementGraphics(PageSettings pageSettings, bool honorOriginAtMargins);
+        public IntPtr GetHdevmode();
+        public IntPtr GetHdevmode(PageSettings pageSettings);
+        public IntPtr GetHdevnames();
+        public bool IsDirectPrintingSupported(Image image);
+        public bool IsDirectPrintingSupported(ImageFormat imageFormat);
+        public void SetHdevmode(IntPtr hdevmode);
+        public void SetHdevnames(IntPtr hdevnames);
+        public override string ToString();
+    }
+    public enum PrinterUnit {
+        Display = 0,
+        HundredthsOfAMillimeter = 2,
+        TenthsOfAMillimeter = 3,
+        ThousandthsOfAnInch = 1,
+    }
+    public sealed class PrinterUnitConvert {
+        public static double Convert(double value, PrinterUnit fromUnit, PrinterUnit toUnit);
+        public static int Convert(int value, PrinterUnit fromUnit, PrinterUnit toUnit);
+        public static Margins Convert(Margins value, PrinterUnit fromUnit, PrinterUnit toUnit);
+        public static Point Convert(Point value, PrinterUnit fromUnit, PrinterUnit toUnit);
+        public static Rectangle Convert(Rectangle value, PrinterUnit fromUnit, PrinterUnit toUnit);
+        public static Size Convert(Size value, PrinterUnit fromUnit, PrinterUnit toUnit);
+    }
+    public class PrintEventArgs : CancelEventArgs {
+        public PrintEventArgs();
+        public PrintAction PrintAction { get; }
+    }
+    public delegate void PrintEventHandler(object sender, PrintEventArgs e); {
+        public PrintEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, PrintEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, PrintEventArgs e);
+    }
+    public sealed class PrintingPermission : CodeAccessPermission, IUnrestrictedPermission {
+        public PrintingPermission(PermissionState state);
+        public PrintingPermission(PrintingPermissionLevel printingLevel);
+        public PrintingPermissionLevel Level { get; set; }
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement element);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class PrintingPermissionAttribute : CodeAccessSecurityAttribute {
+        public PrintingPermissionAttribute(SecurityAction action);
+        public PrintingPermissionLevel Level { get; set; }
+        public override IPermission CreatePermission();
+    }
+    public enum PrintingPermissionLevel {
+        AllPrinting = 3,
+        DefaultPrinting = 2,
+        NoPrinting = 0,
+        SafePrinting = 1,
+    }
+    public class PrintPageEventArgs : EventArgs {
+        public PrintPageEventArgs(Graphics graphics, Rectangle marginBounds, Rectangle pageBounds, PageSettings pageSettings);
+        public bool Cancel { get; set; }
+        public Graphics Graphics { get; }
+        public bool HasMorePages { get; set; }
+        public Rectangle MarginBounds { get; }
+        public Rectangle PageBounds { get; }
+        public PageSettings PageSettings { get; }
+    }
+    public delegate void PrintPageEventHandler(object sender, PrintPageEventArgs e); {
+        public PrintPageEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, PrintPageEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, PrintPageEventArgs e);
+    }
+    public enum PrintRange {
+        AllPages = 0,
+        CurrentPage = 4194304,
+        Selection = 1,
+        SomePages = 2,
+    }
+    public class QueryPageSettingsEventArgs : PrintEventArgs {
+        public QueryPageSettingsEventArgs(PageSettings pageSettings);
+        public PageSettings PageSettings { get; set; }
+    }
+    public delegate void QueryPageSettingsEventHandler(object sender, QueryPageSettingsEventArgs e); {
+        public QueryPageSettingsEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, QueryPageSettingsEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, QueryPageSettingsEventArgs e);
+    }
+    public class StandardPrintController : PrintController {
+        public StandardPrintController();
+        public override void OnEndPage(PrintDocument document, PrintPageEventArgs e);
+        public override void OnEndPrint(PrintDocument document, PrintEventArgs e);
+        public override Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e);
+        public override void OnStartPrint(PrintDocument document, PrintEventArgs e);
+    }
+}
+namespace System.Drawing.Text {
+    public abstract class FontCollection : IDisposable {
+        public FontFamily[] Families { get; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        ~FontCollection();
+    }
+    public enum GenericFontFamilies {
+        Monospace = 2,
+        SansSerif = 1,
+        Serif = 0,
+    }
+    public enum HotkeyPrefix {
+        Hide = 2,
+        None = 0,
+        Show = 1,
+    }
+    public sealed class InstalledFontCollection : FontCollection {
+        public InstalledFontCollection();
+    }
+    public sealed class PrivateFontCollection : FontCollection {
+        public PrivateFontCollection();
+        public void AddFontFile(string filename);
+        public void AddMemoryFont(IntPtr memory, int length);
+    }
+    public enum TextRenderingHint {
+        AntiAlias = 4,
+        AntiAliasGridFit = 3,
+        ClearTypeGridFit = 5,
+        SingleBitPerPixel = 2,
+        SingleBitPerPixelGridFit = 1,
+        SystemDefault = 0,
+    }
+}
 namespace System.Globalization {
     public static class CharUnicodeInfo {
+        public static UnicodeCategory GetUnicodeCategory(int codePoint);
     }
-    public class CultureNotFoundException : ArgumentException, ISerializable {
+    public class CultureNotFoundException : ArgumentException {
     }
 }
 namespace System.IO {
     public class BinaryReader : IDisposable {
+        public virtual int Read(Span<char> buffer);
+        public virtual int Read(Span<byte> buffer);
     }
     public class BinaryWriter : IDisposable {
+        public virtual void Write(ReadOnlySpan<byte> buffer);
+        public virtual void Write(ReadOnlySpan<char> chars);
     }
     public static class Directory {
+        public static IEnumerable<string> EnumerateDirectories(string path, string searchPattern, EnumerationOptions enumerationOptions);
+        public static IEnumerable<string> EnumerateFiles(string path, string searchPattern, EnumerationOptions enumerationOptions);
+        public static IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, EnumerationOptions enumerationOptions);
+        public static string[] GetDirectories(string path, string searchPattern, EnumerationOptions enumerationOptions);
+        public static string[] GetFiles(string path, string searchPattern, EnumerationOptions enumerationOptions);
+        public static string[] GetFileSystemEntries(string path, string searchPattern, EnumerationOptions enumerationOptions);
     }
     public sealed class DirectoryInfo : FileSystemInfo {
+        public IEnumerable<DirectoryInfo> EnumerateDirectories(string searchPattern, EnumerationOptions enumerationOptions);
+        public IEnumerable<FileInfo> EnumerateFiles(string searchPattern, EnumerationOptions enumerationOptions);
+        public IEnumerable<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, EnumerationOptions enumerationOptions);
+        public DirectoryInfo[] GetDirectories(string searchPattern, EnumerationOptions enumerationOptions);
+        public FileInfo[] GetFiles(string searchPattern, EnumerationOptions enumerationOptions);
+        public FileSystemInfo[] GetFileSystemInfos(string searchPattern, EnumerationOptions enumerationOptions);
     }
+    public class EnumerationOptions {
+        public EnumerationOptions();
+        public FileAttributes AttributesToSkip { get; set; }
+        public int BufferSize { get; set; }
+        public bool IgnoreInaccessible { get; set; }
+        public MatchCasing MatchCasing { get; set; }
+        public MatchType MatchType { get; set; }
+        public bool RecurseSubdirectories { get; set; }
+        public bool ReturnSpecialDirectories { get; set; }
+    }
+    public abstract class FileCleanupTestBase : IDisposable {
+        protected FileCleanupTestBase();
+        protected string TestDirectory { get; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        ~FileCleanupTestBase();
+        protected string GetTestFileName(Nullable<int> index=default(Nullable<int>), string memberName=null, int lineNumber=0);
+        protected string GetTestFilePath(Nullable<int> index=default(Nullable<int>), string memberName=null, int lineNumber=0);
+    }
+    public class FileFormatException : FormatException {
+        public FileFormatException();
+        protected FileFormatException(SerializationInfo info, StreamingContext context);
+        public FileFormatException(string message);
+        public FileFormatException(string message, Exception innerException);
+        public FileFormatException(Uri sourceUri);
+        public FileFormatException(Uri sourceUri, Exception innerException);
+        public FileFormatException(Uri sourceUri, string message);
+        public FileFormatException(Uri sourceUri, string message, Exception innerException);
+        public Uri SourceUri { get; }
+        public override void GetObjectData(SerializationInfo info, StreamingContext context);
+    }
     public class FileStream : Stream {
-        public string Name { get; }
+        public virtual string Name { get; }
-        public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state);
+        public override IAsyncResult BeginRead(byte[] array, int offset, int numBytes, AsyncCallback callback, object state);
-        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state);
+        public override IAsyncResult BeginWrite(byte[] array, int offset, int numBytes, AsyncCallback callback, object state);
     }
+    public static class FileSystemAclExtensions {
+        public static DirectorySecurity GetAccessControl(this DirectoryInfo directoryInfo);
+        public static DirectorySecurity GetAccessControl(this DirectoryInfo directoryInfo, AccessControlSections includeSections);
+        public static FileSecurity GetAccessControl(this FileInfo fileInfo);
+        public static FileSecurity GetAccessControl(this FileInfo fileInfo, AccessControlSections includeSections);
+        public static FileSecurity GetAccessControl(this FileStream fileStream);
+        public static void SetAccessControl(this DirectoryInfo directoryInfo, DirectorySecurity directorySecurity);
+        public static void SetAccessControl(this FileInfo fileInfo, FileSecurity fileSecurity);
+        public static void SetAccessControl(this FileStream fileStream, FileSecurity fileSecurity);
+    }
+    public enum MatchCasing {
+        CaseInsensitive = 2,
+        CaseSensitive = 1,
+        PlatformDefault = 0,
+    }
+    public enum MatchType {
+        Simple = 0,
+        Win32 = 1,
+    }
     public class MemoryStream : Stream {
+        public override int Read(Span<byte> destination);
+        public override ValueTask<int> ReadAsync(Memory<byte> destination, CancellationToken cancellationToken=default(CancellationToken));
+        public override void Write(ReadOnlySpan<byte> source);
+        public override ValueTask WriteAsync(ReadOnlyMemory<byte> source, CancellationToken cancellationToken=default(CancellationToken));
     }
     public static class Path {
+        public static ReadOnlySpan<char> GetDirectoryName(ReadOnlySpan<char> path);
+        public static ReadOnlySpan<char> GetExtension(ReadOnlySpan<char> path);
+        public static ReadOnlySpan<char> GetFileName(ReadOnlySpan<char> path);
+        public static ReadOnlySpan<char> GetFileNameWithoutExtension(ReadOnlySpan<char> path);
+        public static ReadOnlySpan<char> GetPathRoot(ReadOnlySpan<char> path);
+        public static bool HasExtension(ReadOnlySpan<char> path);
+        public static bool IsPathFullyQualified(ReadOnlySpan<char> path);
+        public static bool IsPathFullyQualified(string path);
+        public static bool IsPathRooted(ReadOnlySpan<char> path);
+        public static string Join(ReadOnlySpan<char> path1, ReadOnlySpan<char> path2);
+        public static string Join(ReadOnlySpan<char> path1, ReadOnlySpan<char> path2, ReadOnlySpan<char> path3);
+        public static bool TryJoin(ReadOnlySpan<char> path1, ReadOnlySpan<char> path2, Span<char> destination, out int charsWritten);
+        public static bool TryJoin(ReadOnlySpan<char> path1, ReadOnlySpan<char> path2, ReadOnlySpan<char> path3, Span<char> destination, out int charsWritten);
     }
     public abstract class Stream : MarshalByRefObject, IDisposable {
+        public Task CopyToAsync(Stream destination, CancellationToken cancellationToken);
+        public virtual int Read(Span<byte> destination);
+        public virtual ValueTask<int> ReadAsync(Memory<byte> destination, CancellationToken cancellationToken=default(CancellationToken));
+        public virtual void Write(ReadOnlySpan<byte> source);
+        public virtual ValueTask WriteAsync(ReadOnlyMemory<byte> source, CancellationToken cancellationToken=default(CancellationToken));
     }
     public class StreamReader : TextReader {
+        public override int Read(Span<char> buffer);
+        public override ValueTask<int> ReadAsync(Memory<char> buffer, CancellationToken cancellationToken=default(CancellationToken));
+        public override int ReadBlock(Span<char> buffer);
+        public override ValueTask<int> ReadBlockAsync(Memory<char> buffer, CancellationToken cancellationToken=default(CancellationToken));
     }
     public class StreamWriter : TextWriter {
+        public override void Write(ReadOnlySpan<char> buffer);
+        public override Task WriteAsync(ReadOnlyMemory<char> buffer, CancellationToken cancellationToken=default(CancellationToken));
+        public override void WriteLine(ReadOnlySpan<char> buffer);
+        public override void WriteLine(string value);
+        public override Task WriteLineAsync(ReadOnlyMemory<char> buffer, CancellationToken cancellationToken=default(CancellationToken));
     }
     public class StringReader : TextReader {
+        public override int Read(Span<char> buffer);
+        public override ValueTask<int> ReadAsync(Memory<char> buffer, CancellationToken cancellationToken=default(CancellationToken));
+        public override int ReadBlock(Span<char> buffer);
+        public override ValueTask<int> ReadBlockAsync(Memory<char> buffer, CancellationToken cancellationToken=default(CancellationToken));
     }
     public class StringWriter : TextWriter {
+        public override void Write(ReadOnlySpan<char> buffer);
+        public override Task WriteAsync(ReadOnlyMemory<char> buffer, CancellationToken cancellationToken=default(CancellationToken));
+        public override void WriteLine(ReadOnlySpan<char> buffer);
+        public override Task WriteLineAsync(ReadOnlyMemory<char> buffer, CancellationToken cancellationToken=default(CancellationToken));
     }
     public abstract class TextReader : MarshalByRefObject, IDisposable {
+        public virtual int Read(Span<char> buffer);
+        public virtual ValueTask<int> ReadAsync(Memory<char> buffer, CancellationToken cancellationToken=default(CancellationToken));
+        public virtual int ReadBlock(Span<char> buffer);
+        public virtual ValueTask<int> ReadBlockAsync(Memory<char> buffer, CancellationToken cancellationToken=default(CancellationToken));
     }
     public abstract class TextWriter : MarshalByRefObject, IDisposable {
+        public virtual void Write(ReadOnlySpan<char> buffer);
+        public virtual Task WriteAsync(ReadOnlyMemory<char> buffer, CancellationToken cancellationToken=default(CancellationToken));
+        public virtual void WriteLine(ReadOnlySpan<char> buffer);
+        public virtual Task WriteLineAsync(ReadOnlyMemory<char> buffer, CancellationToken cancellationToken=default(CancellationToken));
     }
     public class UnmanagedMemoryStream : Stream {
+        public override int Read(Span<byte> destination);
+        public override void Write(ReadOnlySpan<byte> source);
     }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
-    public struct WaitForChangedResult {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct WaitForChangedResult {
     }
 }
 namespace System.IO.Compression {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
+    public struct BrotliDecoder : IDisposable {
+        public OperationStatus Decompress(ReadOnlySpan<byte> source, Span<byte> destination, out int bytesConsumed, out int bytesWritten);
+        public void Dispose();
+        public static bool TryDecompress(ReadOnlySpan<byte> source, Span<byte> destination, out int bytesWritten);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
+    public struct BrotliEncoder : IDisposable {
+        public BrotliEncoder(int quality, int window);
+        public OperationStatus Compress(ReadOnlySpan<byte> source, Span<byte> destination, out int bytesConsumed, out int bytesWritten, bool isFinalBlock);
+        public void Dispose();
+        public OperationStatus Flush(Span<byte> destination, out int bytesWritten);
+        public static int GetMaxCompressedLength(int inputSize);
+        public static bool TryCompress(ReadOnlySpan<byte> source, Span<byte> destination, out int bytesWritten);
+        public static bool TryCompress(ReadOnlySpan<byte> source, Span<byte> destination, out int bytesWritten, int quality, int window);
+    }
+    public sealed class BrotliStream : Stream {
+        public BrotliStream(Stream stream, CompressionLevel compressionLevel);
+        public BrotliStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen);
+        public BrotliStream(Stream stream, CompressionMode mode);
+        public BrotliStream(Stream stream, CompressionMode mode, bool leaveOpen);
+        public Stream BaseStream { get; }
+        public override bool CanRead { get; }
+        public override bool CanSeek { get; }
+        public override bool CanWrite { get; }
+        public override long Length { get; }
+        public override long Position { get; set; }
+        public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
+        public override IAsyncResult BeginWrite(byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState);
+        public override int EndRead(IAsyncResult asyncResult);
+        public override void EndWrite(IAsyncResult asyncResult);
+        public override void Flush();
+        public override int Read(byte[] array, int offset, int count);
+        public override Task<int> ReadAsync(byte[] array, int offset, int count, CancellationToken cancellationToken);
+        public override long Seek(long offset, SeekOrigin origin);
+        public override void SetLength(long value);
+        public override void Write(byte[] array, int offset, int count);
+        public override Task WriteAsync(byte[] array, int offset, int count, CancellationToken cancellationToken);
+    }
     public class ZipArchiveEntry {
+        public uint Crc32 { get; }
     }
 }
+namespace System.IO.Enumeration {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
+    public struct FileSystemEntry {
+        public FileAttributes Attributes { get; }
+        public DateTimeOffset CreationTimeUtc { get; }
+        public ReadOnlySpan<char> Directory { get; }
+        public ReadOnlySpan<char> FileName { get; }
+        public bool IsDirectory { get; }
+        public bool IsHidden { get; }
+        public DateTimeOffset LastAccessTimeUtc { get; }
+        public DateTimeOffset LastWriteTimeUtc { get; }
+        public long Length { get; }
+        public ReadOnlySpan<char> OriginalRootDirectory { get; }
+        public ReadOnlySpan<char> RootDirectory { get; }
+        public FileSystemInfo ToFileSystemInfo();
+        public string ToFullPath();
+        public string ToSpecifiedFullPath();
+    }
+    public class FileSystemEnumerable<TResult> : IEnumerable, IEnumerable<TResult> {
+        public delegate bool FindPredicate(ref FileSystemEntry entry); {
+            public FindPredicate(object @object, IntPtr method);
+            public virtual IAsyncResult BeginInvoke(ref FileSystemEntry entry, AsyncCallback callback, object @object);
+            public virtual bool EndInvoke(ref FileSystemEntry entry, IAsyncResult result);
+            public virtual bool Invoke(ref FileSystemEntry entry);
+        }
+        public delegate TResult FindTransform(ref FileSystemEntry entry); {
+            public FindTransform(object @object, IntPtr method);
+            public virtual IAsyncResult BeginInvoke(ref FileSystemEntry entry, AsyncCallback callback, object @object);
+            public virtual TResult EndInvoke(ref FileSystemEntry entry, IAsyncResult result);
+            public virtual TResult Invoke(ref FileSystemEntry entry);
+        }
+        public FileSystemEnumerable(string directory, FileSystemEnumerable<TResult>.FindTransform transform, EnumerationOptions options=null);
+        public FileSystemEnumerable<TResult>.FindPredicate ShouldIncludePredicate { get; set; }
+        public FileSystemEnumerable<TResult>.FindPredicate ShouldRecursePredicate { get; set; }
+        public IEnumerator<TResult> GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public abstract class FileSystemEnumerator<TResult> : CriticalFinalizerObject, IDisposable, IEnumerator, IEnumerator<TResult> {
+        public FileSystemEnumerator(string directory, EnumerationOptions options=null);
+        public TResult Current { get; }
+        object System.Collections.IEnumerator.Current { get; }
+        protected virtual bool ContinueOnError(int error);
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public bool MoveNext();
+        protected virtual void OnDirectoryFinished(ReadOnlySpan<char> directory);
+        public void Reset();
+        protected virtual bool ShouldIncludeEntry(ref FileSystemEntry entry);
+        protected virtual bool ShouldRecurseIntoEntry(ref FileSystemEntry entry);
+        protected abstract TResult TransformEntry(ref FileSystemEntry entry);
+    }
+    public static class FileSystemName {
+        public static bool MatchesSimpleExpression(ReadOnlySpan<char> expression, ReadOnlySpan<char> name, bool ignoreCase=true);
+        public static bool MatchesWin32Expression(ReadOnlySpan<char> expression, ReadOnlySpan<char> name, bool ignoreCase=true);
+        public static string TranslateWin32Expression(string expression);
+    }
+}
+namespace System.IO.Packaging {
+    public enum CompressionOption {
+        Fast = 2,
+        Maximum = 1,
+        Normal = 0,
+        NotCompressed = -1,
+        SuperFast = 3,
+    }
+    public enum EncryptionOption {
+        None = 0,
+        RightsManagement = 1,
+    }
+    public abstract class Package : IDisposable {
+        protected Package(FileAccess openFileAccess);
+        public FileAccess FileOpenAccess { get; }
+        public PackageProperties PackageProperties { get; }
+        public void Close();
+        public PackagePart CreatePart(Uri partUri, string contentType);
+        public PackagePart CreatePart(Uri partUri, string contentType, CompressionOption compressionOption);
+        protected abstract PackagePart CreatePartCore(Uri partUri, string contentType, CompressionOption compressionOption);
+        public PackageRelationship CreateRelationship(Uri targetUri, TargetMode targetMode, string relationshipType);
+        public PackageRelationship CreateRelationship(Uri targetUri, TargetMode targetMode, string relationshipType, string id);
+        public void DeletePart(Uri partUri);
+        protected abstract void DeletePartCore(Uri partUri);
+        public void DeleteRelationship(string id);
+        protected virtual void Dispose(bool disposing);
+        public void Flush();
+        protected abstract void FlushCore();
+        public PackagePart GetPart(Uri partUri);
+        protected abstract PackagePart GetPartCore(Uri partUri);
+        public PackagePartCollection GetParts();
+        protected abstract PackagePart[] GetPartsCore();
+        public PackageRelationship GetRelationship(string id);
+        public PackageRelationshipCollection GetRelationships();
+        public PackageRelationshipCollection GetRelationshipsByType(string relationshipType);
+        public static Package Open(Stream stream);
+        public static Package Open(Stream stream, FileMode packageMode);
+        public static Package Open(Stream stream, FileMode packageMode, FileAccess packageAccess);
+        public static Package Open(string path);
+        public static Package Open(string path, FileMode packageMode);
+        public static Package Open(string path, FileMode packageMode, FileAccess packageAccess);
+        public static Package Open(string path, FileMode packageMode, FileAccess packageAccess, FileShare packageShare);
+        public virtual bool PartExists(Uri partUri);
+        public bool RelationshipExists(string id);
+        void System.IDisposable.Dispose();
+    }
+    public abstract class PackagePart {
+        protected PackagePart(Package package, Uri partUri);
+        protected PackagePart(Package package, Uri partUri, string contentType);
+        protected PackagePart(Package package, Uri partUri, string contentType, CompressionOption compressionOption);
+        public CompressionOption CompressionOption { get; }
+        public string ContentType { get; }
+        public Package Package { get; }
+        public Uri Uri { get; }
+        public PackageRelationship CreateRelationship(Uri targetUri, TargetMode targetMode, string relationshipType);
+        public PackageRelationship CreateRelationship(Uri targetUri, TargetMode targetMode, string relationshipType, string id);
+        public void DeleteRelationship(string id);
+        protected virtual string GetContentTypeCore();
+        public PackageRelationship GetRelationship(string id);
+        public PackageRelationshipCollection GetRelationships();
+        public PackageRelationshipCollection GetRelationshipsByType(string relationshipType);
+        public Stream GetStream();
+        public Stream GetStream(FileMode mode);
+        public Stream GetStream(FileMode mode, FileAccess access);
+        protected abstract Stream GetStreamCore(FileMode mode, FileAccess access);
+        public bool RelationshipExists(string id);
+    }
+    public class PackagePartCollection : IEnumerable, IEnumerable<PackagePart> {
+        public IEnumerator<PackagePart> GetEnumerator();
+        IEnumerator<PackagePart> System.Collections.Generic.IEnumerable<System.IO.Packaging.PackagePart>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public abstract class PackageProperties : IDisposable {
+        protected PackageProperties();
+        public abstract string Category { get; set; }
+        public abstract string ContentStatus { get; set; }
+        public abstract string ContentType { get; set; }
+        public abstract Nullable<DateTime> Created { get; set; }
+        public abstract string Creator { get; set; }
+        public abstract string Description { get; set; }
+        public abstract string Identifier { get; set; }
+        public abstract string Keywords { get; set; }
+        public abstract string Language { get; set; }
+        public abstract string LastModifiedBy { get; set; }
+        public abstract Nullable<DateTime> LastPrinted { get; set; }
+        public abstract Nullable<DateTime> Modified { get; set; }
+        public abstract string Revision { get; set; }
+        public abstract string Subject { get; set; }
+        public abstract string Title { get; set; }
+        public abstract string Version { get; set; }
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+    }
+    public class PackageRelationship {
+        public string Id { get; }
+        public Package Package { get; }
+        public string RelationshipType { get; }
+        public Uri SourceUri { get; }
+        public TargetMode TargetMode { get; }
+        public Uri TargetUri { get; }
+    }
+    public class PackageRelationshipCollection : IEnumerable, IEnumerable<PackageRelationship> {
+        public IEnumerator<PackageRelationship> GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public sealed class PackageRelationshipSelector {
+        public PackageRelationshipSelector(Uri sourceUri, PackageRelationshipSelectorType selectorType, string selectionCriteria);
+        public string SelectionCriteria { get; }
+        public PackageRelationshipSelectorType SelectorType { get; }
+        public Uri SourceUri { get; }
+        public List<PackageRelationship> Select(Package package);
+    }
+    public enum PackageRelationshipSelectorType {
+        Id = 0,
+        Type = 1,
+    }
+    public static class PackUriHelper {
+        public static readonly string UriSchemePack;
+        public static int ComparePartUri(Uri firstPartUri, Uri secondPartUri);
+        public static Uri CreatePartUri(Uri partUri);
+        public static Uri GetNormalizedPartUri(Uri partUri);
+        public static Uri GetRelationshipPartUri(Uri partUri);
+        public static Uri GetRelativeUri(Uri sourcePartUri, Uri targetPartUri);
+        public static Uri GetSourcePartUriFromRelationshipPartUri(Uri relationshipPartUri);
+        public static bool IsRelationshipPartUri(Uri partUri);
+        public static Uri ResolvePartUri(Uri sourcePartUri, Uri targetUri);
+    }
+    public enum TargetMode {
+        External = 1,
+        Internal = 0,
+    }
+    public sealed class ZipPackage : Package
+    public sealed class ZipPackagePart : PackagePart
+}
+namespace System.IO.Pipelines {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct FlushResult {
+        public FlushResult(bool isCanceled, bool isCompleted);
+        public bool IsCanceled { get; }
+        public bool IsCompleted { get; }
+    }
+    public interface IDuplexPipe {
+        PipeReader Input { get; }
+        PipeWriter Output { get; }
+    }
+    public sealed class Pipe {
+        public Pipe();
+        public Pipe(PipeOptions options);
+        public PipeReader Reader { get; }
+        public PipeWriter Writer { get; }
+        public void Reset();
+    }
+    public class PipeOptions {
+        public PipeOptions(MemoryPool<byte> pool=null, PipeScheduler readerScheduler=null, PipeScheduler writerScheduler=null, long pauseWriterThreshold=(long)0, long resumeWriterThreshold=(long)0, int minimumSegmentSize=2048, bool useSynchronizationContext=true);
+        public static PipeOptions Default { get; }
+        public int MinimumSegmentSize { get; }
+        public long PauseWriterThreshold { get; }
+        public MemoryPool<byte> Pool { get; }
+        public PipeScheduler ReaderScheduler { get; }
+        public long ResumeWriterThreshold { get; }
+        public bool UseSynchronizationContext { get; }
+        public PipeScheduler WriterScheduler { get; }
+    }
+    public abstract class PipeReader {
+        protected PipeReader();
+        public abstract void AdvanceTo(SequencePosition consumed);
+        public abstract void AdvanceTo(SequencePosition consumed, SequencePosition examined);
+        public abstract void CancelPendingRead();
+        public abstract void Complete(Exception exception=null);
+        public abstract void OnWriterCompleted(Action<Exception, object> callback, object state);
+        public abstract ValueTask<ReadResult> ReadAsync(CancellationToken cancellationToken=default(CancellationToken));
+        public abstract bool TryRead(out ReadResult result);
+    }
+    public abstract class PipeScheduler {
+        protected PipeScheduler();
+        public static PipeScheduler Inline { get; }
+        public static PipeScheduler ThreadPool { get; }
+        public abstract void Schedule<TState>(Action<TState> action, TState state);
+    }
+    public abstract class PipeWriter : IBufferWriter<byte> {
+        protected PipeWriter();
+        public abstract void Advance(int bytes);
+        public abstract void CancelPendingFlush();
+        public abstract void Complete(Exception exception=null);
+        public abstract ValueTask<FlushResult> FlushAsync(CancellationToken cancellationToken=default(CancellationToken));
+        public abstract Memory<byte> GetMemory(int sizeHint=0);
+        public abstract Span<byte> GetSpan(int sizeHint=0);
+        public abstract void OnReaderCompleted(Action<Exception, object> callback, object state);
+        public virtual ValueTask<FlushResult> WriteAsync(ReadOnlyMemory<byte> source, CancellationToken cancellationToken=default(CancellationToken));
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ReadResult {
+        public ReadResult(ReadOnlySequence<byte> buffer, bool isCanceled, bool isCompleted);
+        public ReadOnlySequence<byte> Buffer { get; }
+        public bool IsCanceled { get; }
+        public bool IsCompleted { get; }
+    }
+}
 namespace System.IO.Pipes {
+    public enum PipeAccessRights {
+        AccessSystemSecurity = 16777216,
+        ChangePermissions = 262144,
+        CreateNewInstance = 4,
+        Delete = 65536,
+        FullControl = 2032031,
+        Read = 131209,
+        ReadAttributes = 128,
+        ReadData = 1,
+        ReadExtendedAttributes = 8,
+        ReadPermissions = 131072,
+        ReadWrite = 131483,
+        Synchronize = 1048576,
+        TakeOwnership = 524288,
+        Write = 274,
+        WriteAttributes = 256,
+        WriteData = 2,
+        WriteExtendedAttributes = 16,
+    }
+    public sealed class PipeAccessRule : AccessRule {
+        public PipeAccessRule(IdentityReference identity, PipeAccessRights rights, AccessControlType type);
+        public PipeAccessRule(string identity, PipeAccessRights rights, AccessControlType type);
+        public PipeAccessRights PipeAccessRights { get; }
+    }
+    public sealed class PipeAuditRule : AuditRule {
+        public PipeAuditRule(IdentityReference identity, PipeAccessRights rights, AuditFlags flags);
+        public PipeAuditRule(string identity, PipeAccessRights rights, AuditFlags flags);
+        public PipeAccessRights PipeAccessRights { get; }
+    }
     public enum PipeOptions {
+        CurrentUserOnly = 536870912,
     }
+    public static class PipesAclExtensions {
+        public static PipeSecurity GetAccessControl(this PipeStream stream);
+        public static void SetAccessControl(this PipeStream stream, PipeSecurity pipeSecurity);
+    }
+    public class PipeSecurity : NativeObjectSecurity {
+        public PipeSecurity();
+        public override Type AccessRightType { get; }
+        public override Type AccessRuleType { get; }
+        public override Type AuditRuleType { get; }
+        public override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public void AddAccessRule(PipeAccessRule rule);
+        public void AddAuditRule(PipeAuditRule rule);
+        public sealed override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        protected internal void Persist(SafeHandle handle);
+        protected internal void Persist(string name);
+        public bool RemoveAccessRule(PipeAccessRule rule);
+        public void RemoveAccessRuleSpecific(PipeAccessRule rule);
+        public bool RemoveAuditRule(PipeAuditRule rule);
+        public void RemoveAuditRuleAll(PipeAuditRule rule);
+        public void RemoveAuditRuleSpecific(PipeAuditRule rule);
+        public void ResetAccessRule(PipeAccessRule rule);
+        public void SetAccessRule(PipeAccessRule rule);
+        public void SetAuditRule(PipeAuditRule rule);
+    }
 }
+namespace System.IO.Ports {
+    public enum Handshake {
+        None = 0,
+        RequestToSend = 2,
+        RequestToSendXOnXOff = 3,
+        XOnXOff = 1,
+    }
+    public enum Parity {
+        Even = 2,
+        Mark = 3,
+        None = 0,
+        Odd = 1,
+        Space = 4,
+    }
+    public enum SerialData {
+        Chars = 1,
+        Eof = 2,
+    }
+    public class SerialDataReceivedEventArgs : EventArgs {
+        public SerialData EventType { get; }
+    }
+    public delegate void SerialDataReceivedEventHandler(object sender, SerialDataReceivedEventArgs e); {
+        public SerialDataReceivedEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, SerialDataReceivedEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, SerialDataReceivedEventArgs e);
+    }
+    public enum SerialError {
+        Frame = 8,
+        Overrun = 2,
+        RXOver = 1,
+        RXParity = 4,
+        TXFull = 256,
+    }
+    public class SerialErrorReceivedEventArgs : EventArgs {
+        public SerialError EventType { get; }
+    }
+    public delegate void SerialErrorReceivedEventHandler(object sender, SerialErrorReceivedEventArgs e); {
+        public SerialErrorReceivedEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, SerialErrorReceivedEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, SerialErrorReceivedEventArgs e);
+    }
+    public enum SerialPinChange {
+        Break = 64,
+        CDChanged = 32,
+        CtsChanged = 8,
+        DsrChanged = 16,
+        Ring = 256,
+    }
+    public class SerialPinChangedEventArgs : EventArgs {
+        public SerialPinChange EventType { get; }
+    }
+    public delegate void SerialPinChangedEventHandler(object sender, SerialPinChangedEventArgs e); {
+        public SerialPinChangedEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, SerialPinChangedEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, SerialPinChangedEventArgs e);
+    }
+    public class SerialPort : Component {
+        public const int InfiniteTimeout = -1;
+        public SerialPort();
+        public SerialPort(IContainer container);
+        public SerialPort(string portName);
+        public SerialPort(string portName, int baudRate);
+        public SerialPort(string portName, int baudRate, Parity parity);
+        public SerialPort(string portName, int baudRate, Parity parity, int dataBits);
+        public SerialPort(string portName, int baudRate, Parity parity, int dataBits, StopBits stopBits);
+        public Stream BaseStream { get; }
+        public int BaudRate { get; set; }
+        public bool BreakState { get; set; }
+        public int BytesToRead { get; }
+        public int BytesToWrite { get; }
+        public bool CDHolding { get; }
+        public bool CtsHolding { get; }
+        public int DataBits { get; set; }
+        public bool DiscardNull { get; set; }
+        public bool DsrHolding { get; }
+        public bool DtrEnable { get; set; }
+        public Encoding Encoding { get; set; }
+        public Handshake Handshake { get; set; }
+        public bool IsOpen { get; }
+        public string NewLine { get; set; }
+        public Parity Parity { get; set; }
+        public byte ParityReplace { get; set; }
+        public string PortName { get; set; }
+        public int ReadBufferSize { get; set; }
+        public int ReadTimeout { get; set; }
+        public int ReceivedBytesThreshold { get; set; }
+        public bool RtsEnable { get; set; }
+        public StopBits StopBits { get; set; }
+        public int WriteBufferSize { get; set; }
+        public int WriteTimeout { get; set; }
+        public void Close();
+        public void DiscardInBuffer();
+        public void DiscardOutBuffer();
+        protected override void Dispose(bool disposing);
+        public static string[] GetPortNames();
+        public void Open();
+        public int Read(byte[] buffer, int offset, int count);
+        public int Read(char[] buffer, int offset, int count);
+        public int ReadByte();
+        public int ReadChar();
+        public string ReadExisting();
+        public string ReadLine();
+        public string ReadTo(string value);
+        public void Write(byte[] buffer, int offset, int count);
+        public void Write(char[] buffer, int offset, int count);
+        public void Write(string text);
+        public void WriteLine(string text);
+        public event SerialDataReceivedEventHandler DataReceived;
+        public event SerialErrorReceivedEventHandler ErrorReceived;
+        public event SerialPinChangedEventHandler PinChanged;
+    }
+    public enum StopBits {
+        None = 0,
+        One = 1,
+        OnePointFive = 3,
+        Two = 2,
+    }
+}
+namespace System.Json {
+    public class JsonArray : JsonValue, ICollection<JsonValue>, IEnumerable, IEnumerable<JsonValue>, IList<JsonValue> {
+        public JsonArray(IEnumerable<JsonValue> items);
+        public JsonArray(params JsonValue[] items);
+        public override int Count { get; }
+        public bool IsReadOnly { get; }
+        public sealed override JsonValue this[int index] { get; set; }
+        public override JsonType JsonType { get; }
+        public void Add(JsonValue item);
+        public void AddRange(IEnumerable<JsonValue> items);
+        public void AddRange(params JsonValue[] items);
+        public void Clear();
+        public bool Contains(JsonValue item);
+        public void CopyTo(JsonValue[] array, int arrayIndex);
+        public int IndexOf(JsonValue item);
+        public void Insert(int index, JsonValue item);
+        public bool Remove(JsonValue item);
+        public void RemoveAt(int index);
+        public override void Save(Stream stream);
+        IEnumerator<JsonValue> System.Collections.Generic.IEnumerable<System.Json.JsonValue>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public class JsonObject : JsonValue, ICollection<KeyValuePair<string, JsonValue>>, IDictionary<string, JsonValue>, IEnumerable, IEnumerable<KeyValuePair<string, JsonValue>> {
+        public JsonObject(IEnumerable<KeyValuePair<string, JsonValue>> items);
+        public JsonObject(params KeyValuePair<string, JsonValue>[] items);
+        public override int Count { get; }
+        public sealed override JsonValue this[string key] { get; set; }
+        public override JsonType JsonType { get; }
+        public ICollection<string> Keys { get; }
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Json.JsonValue>>.IsReadOnly { get; }
+        public ICollection<JsonValue> Values { get; }
+        public void Add(KeyValuePair<string, JsonValue> pair);
+        public void Add(string key, JsonValue value);
+        public void AddRange(IEnumerable<KeyValuePair<string, JsonValue>> items);
+        public void AddRange(params KeyValuePair<string, JsonValue>[] items);
+        public void Clear();
+        public override bool ContainsKey(string key);
+        public void CopyTo(KeyValuePair<string, JsonValue>[] array, int arrayIndex);
+        public IEnumerator<KeyValuePair<string, JsonValue>> GetEnumerator();
+        public bool Remove(string key);
+        public override void Save(Stream stream);
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Json.JsonValue>>.Remove(KeyValuePair<string, JsonValue> item);
+        bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Json.JsonValue>>.Contains(KeyValuePair<string, JsonValue> item);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public bool TryGetValue(string key, out JsonValue value);
+    }
+    public class JsonPrimitive : JsonValue {
+        public JsonPrimitive(bool value);
+        public JsonPrimitive(byte value);
+        public JsonPrimitive(char value);
+        public JsonPrimitive(DateTime value);
+        public JsonPrimitive(DateTimeOffset value);
+        public JsonPrimitive(decimal value);
+        public JsonPrimitive(double value);
+        public JsonPrimitive(Guid value);
+        public JsonPrimitive(short value);
+        public JsonPrimitive(int value);
+        public JsonPrimitive(long value);
+        public JsonPrimitive(sbyte value);
+        public JsonPrimitive(float value);
+        public JsonPrimitive(string value);
+        public JsonPrimitive(TimeSpan value);
+        public JsonPrimitive(ushort value);
+        public JsonPrimitive(uint value);
+        public JsonPrimitive(ulong value);
+        public JsonPrimitive(Uri value);
+        public override JsonType JsonType { get; }
+        public override void Save(Stream stream);
+    }
+    public enum JsonType {
+        Array = 3,
+        Boolean = 4,
+        Number = 1,
+        Object = 2,
+        String = 0,
+    }
+    public abstract class JsonValue : IEnumerable {
+        protected JsonValue();
+        public virtual int Count { get; }
+        public virtual JsonValue this[int index] { get; set; }
+        public virtual JsonValue this[string key] { get; set; }
+        public abstract JsonType JsonType { get; }
+        public virtual bool ContainsKey(string key);
+        public static JsonValue Load(Stream stream);
+        public static JsonValue Load(TextReader textReader);
+        public static implicit operator JsonValue (bool value);
+        public static implicit operator JsonValue (byte value);
+        public static implicit operator JsonValue (char value);
+        public static implicit operator JsonValue (DateTime value);
+        public static implicit operator JsonValue (DateTimeOffset value);
+        public static implicit operator JsonValue (decimal value);
+        public static implicit operator JsonValue (double value);
+        public static implicit operator JsonValue (Guid value);
+        public static implicit operator JsonValue (short value);
+        public static implicit operator JsonValue (int value);
+        public static implicit operator JsonValue (long value);
+        public static implicit operator bool (JsonValue value);
+        public static implicit operator byte (JsonValue value);
+        public static implicit operator char (JsonValue value);
+        public static implicit operator decimal (JsonValue value);
+        public static implicit operator double (JsonValue value);
+        public static implicit operator float (JsonValue value);
+        public static implicit operator int (JsonValue value);
+        public static implicit operator long (JsonValue value);
+        public static implicit operator sbyte (JsonValue value);
+        public static implicit operator short (JsonValue value);
+        public static implicit operator string (JsonValue value);
+        public static implicit operator uint (JsonValue value);
+        public static implicit operator ulong (JsonValue value);
+        public static implicit operator ushort (JsonValue value);
+        public static implicit operator DateTime (JsonValue value);
+        public static implicit operator DateTimeOffset (JsonValue value);
+        public static implicit operator TimeSpan (JsonValue value);
+        public static implicit operator Guid (JsonValue value);
+        public static implicit operator Uri (JsonValue value);
+        public static implicit operator JsonValue (sbyte value);
+        public static implicit operator JsonValue (float value);
+        public static implicit operator JsonValue (string value);
+        public static implicit operator JsonValue (TimeSpan value);
+        public static implicit operator JsonValue (ushort value);
+        public static implicit operator JsonValue (uint value);
+        public static implicit operator JsonValue (ulong value);
+        public static implicit operator JsonValue (Uri value);
+        public static JsonValue Parse(string jsonString);
+        public virtual void Save(Stream stream);
+        public virtual void Save(TextWriter textWriter);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public override string ToString();
+    }
+}
+namespace System.Management {
+    public enum AuthenticationLevel {
+        Call = 3,
+        Connect = 2,
+        Default = 0,
+        None = 1,
+        Packet = 4,
+        PacketIntegrity = 5,
+        PacketPrivacy = 6,
+        Unchanged = -1,
+    }
+    public enum CimType {
+        Boolean = 11,
+        Char16 = 103,
+        DateTime = 101,
+        None = 0,
+        Object = 13,
+        Real32 = 4,
+        Real64 = 5,
+        Reference = 102,
+        SInt16 = 2,
+        SInt32 = 3,
+        SInt64 = 20,
+        SInt8 = 16,
+        String = 8,
+        UInt16 = 18,
+        UInt32 = 19,
+        UInt64 = 21,
+        UInt8 = 17,
+    }
+    public enum CodeLanguage {
+        CSharp = 0,
+        JScript = 1,
+        Mcpp = 4,
+        VB = 2,
+        VJSharp = 3,
+    }
+    public enum ComparisonSettings {
+        IgnoreCase = 16,
+        IgnoreClass = 8,
+        IgnoreDefaultValues = 4,
+        IgnoreFlavor = 32,
+        IgnoreObjectSource = 2,
+        IgnoreQualifiers = 1,
+        IncludeAll = 0,
+    }
+    public class CompletedEventArgs : ManagementEventArgs {
+        public ManagementStatus Status { get; }
+        public ManagementBaseObject StatusObject { get; }
+    }
+    public delegate void CompletedEventHandler(object sender, CompletedEventArgs e); {
+        public CompletedEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, CompletedEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, CompletedEventArgs e);
+    }
+    public class ConnectionOptions : ManagementOptions {
+        public ConnectionOptions();
+        public ConnectionOptions(string locale, string username, SecureString password, string authority, ImpersonationLevel impersonation, AuthenticationLevel authentication, bool enablePrivileges, ManagementNamedValueCollection context, TimeSpan timeout);
+        public ConnectionOptions(string locale, string username, string password, string authority, ImpersonationLevel impersonation, AuthenticationLevel authentication, bool enablePrivileges, ManagementNamedValueCollection context, TimeSpan timeout);
+        public AuthenticationLevel Authentication { get; set; }
+        public string Authority { get; set; }
+        public bool EnablePrivileges { get; set; }
+        public ImpersonationLevel Impersonation { get; set; }
+        public string Locale { get; set; }
+        public string Password { set; }
+        public SecureString SecurePassword { set; }
+        public string Username { get; set; }
+        public override object Clone();
+    }
+    public class DeleteOptions : ManagementOptions {
+        public DeleteOptions();
+        public DeleteOptions(ManagementNamedValueCollection context, TimeSpan timeout);
+        public override object Clone();
+    }
+    public class EnumerationOptions : ManagementOptions {
+        public EnumerationOptions();
+        public EnumerationOptions(ManagementNamedValueCollection context, TimeSpan timeout, int blockSize, bool rewindable, bool returnImmediatley, bool useAmendedQualifiers, bool ensureLocatable, bool prototypeOnly, bool directRead, bool enumerateDeep);
+        public int BlockSize { get; set; }
+        public bool DirectRead { get; set; }
+        public bool EnsureLocatable { get; set; }
+        public bool EnumerateDeep { get; set; }
+        public bool PrototypeOnly { get; set; }
+        public bool ReturnImmediately { get; set; }
+        public bool Rewindable { get; set; }
+        public bool UseAmendedQualifiers { get; set; }
+        public override object Clone();
+    }
+    public class EventArrivedEventArgs : ManagementEventArgs {
+        public ManagementBaseObject NewEvent { get; }
+    }
+    public delegate void EventArrivedEventHandler(object sender, EventArrivedEventArgs e); {
+        public EventArrivedEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, EventArrivedEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, EventArrivedEventArgs e);
+    }
+    public class EventQuery : ManagementQuery {
+        public EventQuery();
+        public EventQuery(string query);
+        public EventQuery(string language, string query);
+        public override object Clone();
+    }
+    public class EventWatcherOptions : ManagementOptions {
+        public EventWatcherOptions();
+        public EventWatcherOptions(ManagementNamedValueCollection context, TimeSpan timeout, int blockSize);
+        public int BlockSize { get; set; }
+        public override object Clone();
+    }
+    public enum ImpersonationLevel {
+        Anonymous = 1,
+        Default = 0,
+        Delegate = 4,
+        Identify = 2,
+        Impersonate = 3,
+    }
+    public class InvokeMethodOptions : ManagementOptions {
+        public InvokeMethodOptions();
+        public InvokeMethodOptions(ManagementNamedValueCollection context, TimeSpan timeout);
+        public override object Clone();
+    }
+    public class ManagementBaseObject : Component, ICloneable, ISerializable {
+        protected ManagementBaseObject(SerializationInfo info, StreamingContext context);
+        public virtual ManagementPath ClassPath { get; }
+        public object this[string propertyName] { get; set; }
+        public virtual PropertyDataCollection Properties { get; }
+        public virtual QualifierDataCollection Qualifiers { get; }
+        public virtual PropertyDataCollection SystemProperties { get; }
+        public virtual object Clone();
+        public bool CompareTo(ManagementBaseObject otherObject, ComparisonSettings settings);
+        public void Dispose();
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        protected virtual void GetObjectData(SerializationInfo info, StreamingContext context);
+        public object GetPropertyQualifierValue(string propertyName, string qualifierName);
+        public object GetPropertyValue(string propertyName);
+        public object GetQualifierValue(string qualifierName);
+        public string GetText(TextFormat format);
+        public static explicit operator IntPtr (ManagementBaseObject managementObject);
+        public void SetPropertyQualifierValue(string propertyName, string qualifierName, object qualifierValue);
+        public void SetPropertyValue(string propertyName, object propertyValue);
+        public void SetQualifierValue(string qualifierName, object qualifierValue);
+        void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
+    }
+    public class ManagementClass : ManagementObject {
+        public ManagementClass();
+        public ManagementClass(ManagementPath path);
+        public ManagementClass(ManagementPath path, ObjectGetOptions options);
+        public ManagementClass(ManagementScope scope, ManagementPath path, ObjectGetOptions options);
+        protected ManagementClass(SerializationInfo info, StreamingContext context);
+        public ManagementClass(string path);
+        public ManagementClass(string path, ObjectGetOptions options);
+        public ManagementClass(string scope, string path, ObjectGetOptions options);
+        public StringCollection Derivation { get; }
+        public MethodDataCollection Methods { get; }
+        public override ManagementPath Path { get; set; }
+        public override object Clone();
+        public ManagementObject CreateInstance();
+        public ManagementClass Derive(string newClassName);
+        public ManagementObjectCollection GetInstances();
+        public ManagementObjectCollection GetInstances(EnumerationOptions options);
+        public void GetInstances(ManagementOperationObserver watcher);
+        public void GetInstances(ManagementOperationObserver watcher, EnumerationOptions options);
+        protected override void GetObjectData(SerializationInfo info, StreamingContext context);
+        public ManagementObjectCollection GetRelatedClasses();
+        public void GetRelatedClasses(ManagementOperationObserver watcher);
+        public void GetRelatedClasses(ManagementOperationObserver watcher, string relatedClass);
+        public void GetRelatedClasses(ManagementOperationObserver watcher, string relatedClass, string relationshipClass, string relationshipQualifier, string relatedQualifier, string relatedRole, string thisRole, EnumerationOptions options);
+        public ManagementObjectCollection GetRelatedClasses(string relatedClass);
+        public ManagementObjectCollection GetRelatedClasses(string relatedClass, string relationshipClass, string relationshipQualifier, string relatedQualifier, string relatedRole, string thisRole, EnumerationOptions options);
+        public ManagementObjectCollection GetRelationshipClasses();
+        public void GetRelationshipClasses(ManagementOperationObserver watcher);
+        public void GetRelationshipClasses(ManagementOperationObserver watcher, string relationshipClass);
+        public void GetRelationshipClasses(ManagementOperationObserver watcher, string relationshipClass, string relationshipQualifier, string thisRole, EnumerationOptions options);
+        public ManagementObjectCollection GetRelationshipClasses(string relationshipClass);
+        public ManagementObjectCollection GetRelationshipClasses(string relationshipClass, string relationshipQualifier, string thisRole, EnumerationOptions options);
+        public CodeTypeDeclaration GetStronglyTypedClassCode(bool includeSystemClassInClassDef, bool systemPropertyClass);
+        public bool GetStronglyTypedClassCode(CodeLanguage lang, string filePath, string classNamespace);
+        public ManagementObjectCollection GetSubclasses();
+        public ManagementObjectCollection GetSubclasses(EnumerationOptions options);
+        public void GetSubclasses(ManagementOperationObserver watcher);
+        public void GetSubclasses(ManagementOperationObserver watcher, EnumerationOptions options);
+    }
+    public sealed class ManagementDateTimeConverter {
+        public static DateTime ToDateTime(string dmtfDate);
+        public static string ToDmtfDateTime(DateTime date);
+        public static string ToDmtfTimeInterval(TimeSpan timespan);
+        public static TimeSpan ToTimeSpan(string dmtfTimespan);
+    }
+    public abstract class ManagementEventArgs : EventArgs {
+        public object Context { get; }
+    }
+    public class ManagementEventWatcher : Component {
+        public ManagementEventWatcher();
+        public ManagementEventWatcher(EventQuery query);
+        public ManagementEventWatcher(ManagementScope scope, EventQuery query);
+        public ManagementEventWatcher(ManagementScope scope, EventQuery query, EventWatcherOptions options);
+        public ManagementEventWatcher(string query);
+        public ManagementEventWatcher(string scope, string query);
+        public ManagementEventWatcher(string scope, string query, EventWatcherOptions options);
+        public EventWatcherOptions Options { get; set; }
+        public EventQuery Query { get; set; }
+        public ManagementScope Scope { get; set; }
+        ~ManagementEventWatcher();
+        public void Start();
+        public void Stop();
+        public ManagementBaseObject WaitForNextEvent();
+        public event EventArrivedEventHandler EventArrived;
+        public event StoppedEventHandler Stopped;
+    }
+    public class ManagementException : SystemException {
+        public ManagementException();
+        protected ManagementException(SerializationInfo info, StreamingContext context);
+        public ManagementException(string message);
+        public ManagementException(string message, Exception innerException);
+        public ManagementStatus ErrorCode { get; }
+        public ManagementBaseObject ErrorInformation { get; }
+        public override void GetObjectData(SerializationInfo info, StreamingContext context);
+    }
+    public class ManagementNamedValueCollection : NameObjectCollectionBase {
+        public ManagementNamedValueCollection();
+        protected ManagementNamedValueCollection(SerializationInfo info, StreamingContext context);
+        public object this[string name] { get; }
+        public void Add(string name, object value);
+        public ManagementNamedValueCollection Clone();
+        public void Remove(string name);
+        public void RemoveAll();
+    }
+    public class ManagementObject : ManagementBaseObject, ICloneable {
+        public ManagementObject();
+        public ManagementObject(ManagementPath path);
+        public ManagementObject(ManagementPath path, ObjectGetOptions options);
+        public ManagementObject(ManagementScope scope, ManagementPath path, ObjectGetOptions options);
+        protected ManagementObject(SerializationInfo info, StreamingContext context);
+        public ManagementObject(string path);
+        public ManagementObject(string path, ObjectGetOptions options);
+        public ManagementObject(string scopeString, string pathString, ObjectGetOptions options);
+        public override ManagementPath ClassPath { get; }
+        public ObjectGetOptions Options { get; set; }
+        public virtual ManagementPath Path { get; set; }
+        public ManagementScope Scope { get; set; }
+        public override object Clone();
+        public void CopyTo(ManagementOperationObserver watcher, ManagementPath path);
+        public void CopyTo(ManagementOperationObserver watcher, ManagementPath path, PutOptions options);
+        public void CopyTo(ManagementOperationObserver watcher, string path);
+        public void CopyTo(ManagementOperationObserver watcher, string path, PutOptions options);
+        public ManagementPath CopyTo(ManagementPath path);
+        public ManagementPath CopyTo(ManagementPath path, PutOptions options);
+        public ManagementPath CopyTo(string path);
+        public ManagementPath CopyTo(string path, PutOptions options);
+        public void Delete();
+        public void Delete(DeleteOptions options);
+        public void Delete(ManagementOperationObserver watcher);
+        public void Delete(ManagementOperationObserver watcher, DeleteOptions options);
+        public new void Dispose();
+        public void Get();
+        public void Get(ManagementOperationObserver watcher);
+        public ManagementBaseObject GetMethodParameters(string methodName);
+        protected override void GetObjectData(SerializationInfo info, StreamingContext context);
+        public ManagementObjectCollection GetRelated();
+        public void GetRelated(ManagementOperationObserver watcher);
+        public void GetRelated(ManagementOperationObserver watcher, string relatedClass);
+        public void GetRelated(ManagementOperationObserver watcher, string relatedClass, string relationshipClass, string relationshipQualifier, string relatedQualifier, string relatedRole, string thisRole, bool classDefinitionsOnly, EnumerationOptions options);
+        public ManagementObjectCollection GetRelated(string relatedClass);
+        public ManagementObjectCollection GetRelated(string relatedClass, string relationshipClass, string relationshipQualifier, string relatedQualifier, string relatedRole, string thisRole, bool classDefinitionsOnly, EnumerationOptions options);
+        public ManagementObjectCollection GetRelationships();
+        public void GetRelationships(ManagementOperationObserver watcher);
+        public void GetRelationships(ManagementOperationObserver watcher, string relationshipClass);
+        public void GetRelationships(ManagementOperationObserver watcher, string relationshipClass, string relationshipQualifier, string thisRole, bool classDefinitionsOnly, EnumerationOptions options);
+        public ManagementObjectCollection GetRelationships(string relationshipClass);
+        public ManagementObjectCollection GetRelationships(string relationshipClass, string relationshipQualifier, string thisRole, bool classDefinitionsOnly, EnumerationOptions options);
+        public void InvokeMethod(ManagementOperationObserver watcher, string methodName, ManagementBaseObject inParameters, InvokeMethodOptions options);
+        public void InvokeMethod(ManagementOperationObserver watcher, string methodName, object[] args);
+        public ManagementBaseObject InvokeMethod(string methodName, ManagementBaseObject inParameters, InvokeMethodOptions options);
+        public object InvokeMethod(string methodName, object[] args);
+        public ManagementPath Put();
+        public void Put(ManagementOperationObserver watcher);
+        public void Put(ManagementOperationObserver watcher, PutOptions options);
+        public ManagementPath Put(PutOptions options);
+        public override string ToString();
+    }
+    public class ManagementObjectCollection : ICollection, IDisposable, IEnumerable {
+        public class ManagementObjectEnumerator : IDisposable, IEnumerator {
+            public ManagementBaseObject Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public void Dispose();
+            ~ManagementObjectEnumerator();
+            public bool MoveNext();
+            public void Reset();
+        }
+        public int Count { get; }
+        public bool IsSynchronized { get; }
+        public object SyncRoot { get; }
+        public void CopyTo(Array array, int index);
+        public void CopyTo(ManagementBaseObject[] objectCollection, int index);
+        public void Dispose();
+        ~ManagementObjectCollection();
+        public ManagementObjectCollection.ManagementObjectEnumerator GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public class ManagementObjectSearcher : Component {
+        public ManagementObjectSearcher();
+        public ManagementObjectSearcher(ManagementScope scope, ObjectQuery query);
+        public ManagementObjectSearcher(ManagementScope scope, ObjectQuery query, EnumerationOptions options);
+        public ManagementObjectSearcher(ObjectQuery query);
+        public ManagementObjectSearcher(string queryString);
+        public ManagementObjectSearcher(string scope, string queryString);
+        public ManagementObjectSearcher(string scope, string queryString, EnumerationOptions options);
+        public EnumerationOptions Options { get; set; }
+        public ObjectQuery Query { get; set; }
+        public ManagementScope Scope { get; set; }
+        public ManagementObjectCollection Get();
+        public void Get(ManagementOperationObserver watcher);
+    }
+    public class ManagementOperationObserver {
+        public ManagementOperationObserver();
+        public void Cancel();
+        public event CompletedEventHandler Completed;
+        public event ObjectPutEventHandler ObjectPut;
+        public event ObjectReadyEventHandler ObjectReady;
+        public event ProgressEventHandler Progress;
+    }
+    public abstract class ManagementOptions : ICloneable {
+        public static readonly TimeSpan InfiniteTimeout;
+        public ManagementNamedValueCollection Context { get; set; }
+        public TimeSpan Timeout { get; set; }
+        public abstract object Clone();
+    }
+    public class ManagementPath : ICloneable {
+        public ManagementPath();
+        public ManagementPath(string path);
+        public string ClassName { get; set; }
+        public static ManagementPath DefaultPath { get; set; }
+        public bool IsClass { get; }
+        public bool IsInstance { get; }
+        public bool IsSingleton { get; }
+        public string NamespacePath { get; set; }
+        public string Path { get; set; }
+        public string RelativePath { get; set; }
+        public string Server { get; set; }
+        public ManagementPath Clone();
+        public void SetAsClass();
+        public void SetAsSingleton();
+        object System.ICloneable.Clone();
+        public override string ToString();
+    }
+    public abstract class ManagementQuery : ICloneable {
+        public virtual string QueryLanguage { get; set; }
+        public virtual string QueryString { get; set; }
+        public abstract object Clone();
+        protected internal virtual void ParseQuery(string query);
+    }
+    public class ManagementScope : ICloneable {
+        public ManagementScope();
+        public ManagementScope(ManagementPath path);
+        public ManagementScope(ManagementPath path, ConnectionOptions options);
+        public ManagementScope(string path);
+        public ManagementScope(string path, ConnectionOptions options);
+        public bool IsConnected { get; }
+        public ConnectionOptions Options { get; set; }
+        public ManagementPath Path { get; set; }
+        public ManagementScope Clone();
+        public void Connect();
+        object System.ICloneable.Clone();
+    }
+    public enum ManagementStatus {
+        AccessDenied = -2147217405,
+        AggregatingByObject = -2147217315,
+        AlreadyExists = -2147217383,
+        AmendedObject = -2147217306,
+        BackupRestoreWinmgmtRunning = -2147217312,
+        BufferTooSmall = -2147217348,
+        CallCanceled = -2147217358,
+        CannotBeAbstract = -2147217307,
+        CannotBeKey = -2147217377,
+        CannotBeSingleton = -2147217364,
+        CannotChangeIndexInheritance = -2147217328,
+        CannotChangeKeyInheritance = -2147217335,
+        CircularReference = -2147217337,
+        ClassHasChildren = -2147217371,
+        ClassHasInstances = -2147217370,
+        ClientTooSlow = -2147217305,
+        CriticalError = -2147217398,
+        Different = 262147,
+        DuplicateObjects = 262152,
+        Failed = -2147217407,
+        False = 1,
+        IllegalNull = -2147217368,
+        IllegalOperation = -2147217378,
+        IncompleteClass = -2147217376,
+        InitializationFailure = -2147217388,
+        InvalidCimType = -2147217363,
+        InvalidClass = -2147217392,
+        InvalidContext = -2147217401,
+        InvalidDuplicateParameter = -2147217341,
+        InvalidFlavor = -2147217338,
+        InvalidMethod = -2147217362,
+        InvalidMethodParameters = -2147217361,
+        InvalidNamespace = -2147217394,
+        InvalidObject = -2147217393,
+        InvalidObjectPath = -2147217350,
+        InvalidOperation = -2147217386,
+        InvalidOperator = -2147217309,
+        InvalidParameter = -2147217400,
+        InvalidParameterID = -2147217353,
+        InvalidProperty = -2147217359,
+        InvalidPropertyType = -2147217366,
+        InvalidProviderRegistration = -2147217390,
+        InvalidQualifier = -2147217342,
+        InvalidQualifierType = -2147217367,
+        InvalidQuery = -2147217385,
+        InvalidQueryType = -2147217384,
+        InvalidStream = -2147217397,
+        InvalidSuperclass = -2147217395,
+        InvalidSyntax = -2147217375,
+        LocalCredentials = -2147217308,
+        MarshalInvalidSignature = -2147217343,
+        MarshalVersionMismatch = -2147217344,
+        MethodDisabled = -2147217322,
+        MethodNotImplemented = -2147217323,
+        MissingAggregationList = -2147217317,
+        MissingGroupWithin = -2147217318,
+        MissingParameterID = -2147217354,
+        NoError = 0,
+        NoMoreData = 262149,
+        NonconsecutiveParameterIDs = -2147217352,
+        NondecoratedObject = -2147217374,
+        NotAvailable = -2147217399,
+        NotEventClass = -2147217319,
+        NotFound = -2147217406,
+        NotSupported = -2147217396,
+        OperationCanceled = 262150,
+        OutOfDiskSpace = -2147217349,
+        OutOfMemory = -2147217402,
+        OverrideNotAllowed = -2147217382,
+        ParameterIDOnRetval = -2147217351,
+        PartialResults = 262160,
+        Pending = 262151,
+        PrivilegeNotHeld = -2147217310,
+        PropagatedMethod = -2147217356,
+        PropagatedProperty = -2147217380,
+        PropagatedQualifier = -2147217381,
+        PropertyNotAnObject = -2147217316,
+        ProviderFailure = -2147217404,
+        ProviderLoadFailure = -2147217389,
+        ProviderNotCapable = -2147217372,
+        ProviderNotFound = -2147217391,
+        QueryNotImplemented = -2147217369,
+        QueueOverflow = -2147217311,
+        ReadOnly = -2147217373,
+        RefresherBusy = -2147217321,
+        RegistrationTooBroad = -2147213311,
+        RegistrationTooPrecise = -2147213310,
+        ResetToDefault = 262146,
+        ServerTooBusy = -2147217339,
+        ShuttingDown = -2147217357,
+        SystemProperty = -2147217360,
+        Timedout = 262148,
+        TooManyProperties = -2147217327,
+        TooMuchData = -2147217340,
+        TransportFailure = -2147217387,
+        TypeMismatch = -2147217403,
+        Unexpected = -2147217379,
+        UninterpretableProviderQuery = -2147217313,
+        UnknownObjectType = -2147217346,
+        UnknownPacketType = -2147217345,
+        UnparsableQuery = -2147217320,
+        UnsupportedClassUpdate = -2147217336,
+        UnsupportedParameter = -2147217355,
+        UnsupportedPutExtension = -2147217347,
+        UpdateOverrideNotAllowed = -2147217325,
+        UpdatePropagatedMethod = -2147217324,
+        UpdateTypeMismatch = -2147217326,
+        ValueOutOfRange = -2147217365,
+    }
+    public class MethodData {
+        public ManagementBaseObject InParameters { get; }
+        public string Name { get; }
+        public string Origin { get; }
+        public ManagementBaseObject OutParameters { get; }
+        public QualifierDataCollection Qualifiers { get; }
+    }
+    public class MethodDataCollection : ICollection, IEnumerable {
+        public class MethodDataEnumerator : IEnumerator {
+            public MethodData Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            public void Reset();
+        }
+        public int Count { get; }
+        public bool IsSynchronized { get; }
+        public virtual MethodData this[string methodName] { get; }
+        public object SyncRoot { get; }
+        public virtual void Add(string methodName);
+        public virtual void Add(string methodName, ManagementBaseObject inParameters, ManagementBaseObject outParameters);
+        public void CopyTo(Array array, int index);
+        public void CopyTo(MethodData[] methodArray, int index);
+        public MethodDataCollection.MethodDataEnumerator GetEnumerator();
+        public virtual void Remove(string methodName);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public class ObjectGetOptions : ManagementOptions {
+        public ObjectGetOptions();
+        public ObjectGetOptions(ManagementNamedValueCollection context);
+        public ObjectGetOptions(ManagementNamedValueCollection context, TimeSpan timeout, bool useAmendedQualifiers);
+        public bool UseAmendedQualifiers { get; set; }
+        public override object Clone();
+    }
+    public class ObjectPutEventArgs : ManagementEventArgs {
+        public ManagementPath Path { get; }
+    }
+    public delegate void ObjectPutEventHandler(object sender, ObjectPutEventArgs e); {
+        public ObjectPutEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, ObjectPutEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, ObjectPutEventArgs e);
+    }
+    public class ObjectQuery : ManagementQuery {
+        public ObjectQuery();
+        public ObjectQuery(string query);
+        public ObjectQuery(string language, string query);
+        public override object Clone();
+    }
+    public class ObjectReadyEventArgs : ManagementEventArgs {
+        public ManagementBaseObject NewObject { get; }
+    }
+    public delegate void ObjectReadyEventHandler(object sender, ObjectReadyEventArgs e); {
+        public ObjectReadyEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, ObjectReadyEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, ObjectReadyEventArgs e);
+    }
+    public class ProgressEventArgs : ManagementEventArgs {
+        public int Current { get; }
+        public string Message { get; }
+        public int UpperBound { get; }
+    }
+    public delegate void ProgressEventHandler(object sender, ProgressEventArgs e); {
+        public ProgressEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, ProgressEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, ProgressEventArgs e);
+    }
+    public class PropertyData {
+        public bool IsArray { get; }
+        public bool IsLocal { get; }
+        public string Name { get; }
+        public string Origin { get; }
+        public QualifierDataCollection Qualifiers { get; }
+        public CimType Type { get; }
+        public object Value { get; set; }
+    }
+    public class PropertyDataCollection : ICollection, IEnumerable {
+        public class PropertyDataEnumerator : IEnumerator {
+            public PropertyData Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            public void Reset();
+        }
+        public int Count { get; }
+        public bool IsSynchronized { get; }
+        public virtual PropertyData this[string propertyName] { get; }
+        public object SyncRoot { get; }
+        public void Add(string propertyName, CimType propertyType, bool isArray);
+        public virtual void Add(string propertyName, object propertyValue);
+        public void Add(string propertyName, object propertyValue, CimType propertyType);
+        public void CopyTo(Array array, int index);
+        public void CopyTo(PropertyData[] propertyArray, int index);
+        public PropertyDataCollection.PropertyDataEnumerator GetEnumerator();
+        public virtual void Remove(string propertyName);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public class PutOptions : ManagementOptions {
+        public PutOptions();
+        public PutOptions(ManagementNamedValueCollection context);
+        public PutOptions(ManagementNamedValueCollection context, TimeSpan timeout, bool useAmendedQualifiers, PutType putType);
+        public PutType Type { get; set; }
+        public bool UseAmendedQualifiers { get; set; }
+        public override object Clone();
+    }
+    public enum PutType {
+        CreateOnly = 2,
+        None = 0,
+        UpdateOnly = 1,
+        UpdateOrCreate = 3,
+    }
+    public class QualifierData {
+        public bool IsAmended { get; set; }
+        public bool IsLocal { get; }
+        public bool IsOverridable { get; set; }
+        public string Name { get; }
+        public bool PropagatesToInstance { get; set; }
+        public bool PropagatesToSubclass { get; set; }
+        public object Value { get; set; }
+    }
+    public class QualifierDataCollection : ICollection, IEnumerable {
+        public class QualifierDataEnumerator : IEnumerator {
+            public QualifierData Current { get; }
+            object System.Collections.IEnumerator.Current { get; }
+            public bool MoveNext();
+            public void Reset();
+        }
+        public int Count { get; }
+        public bool IsSynchronized { get; }
+        public virtual QualifierData this[string qualifierName] { get; }
+        public object SyncRoot { get; }
+        public virtual void Add(string qualifierName, object qualifierValue);
+        public virtual void Add(string qualifierName, object qualifierValue, bool isAmended, bool propagatesToInstance, bool propagatesToSubclass, bool isOverridable);
+        public void CopyTo(Array array, int index);
+        public void CopyTo(QualifierData[] qualifierArray, int index);
+        public QualifierDataCollection.QualifierDataEnumerator GetEnumerator();
+        public virtual void Remove(string qualifierName);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public class RelatedObjectQuery : WqlObjectQuery {
+        public RelatedObjectQuery();
+        public RelatedObjectQuery(bool isSchemaQuery, string sourceObject, string relatedClass, string relationshipClass, string relatedQualifier, string relationshipQualifier, string relatedRole, string thisRole);
+        public RelatedObjectQuery(string queryOrSourceObject);
+        public RelatedObjectQuery(string sourceObject, string relatedClass);
+        public RelatedObjectQuery(string sourceObject, string relatedClass, string relationshipClass, string relatedQualifier, string relationshipQualifier, string relatedRole, string thisRole, bool classDefinitionsOnly);
+        public bool ClassDefinitionsOnly { get; set; }
+        public bool IsSchemaQuery { get; set; }
+        public string RelatedClass { get; set; }
+        public string RelatedQualifier { get; set; }
+        public string RelatedRole { get; set; }
+        public string RelationshipClass { get; set; }
+        public string RelationshipQualifier { get; set; }
+        public string SourceObject { get; set; }
+        public string ThisRole { get; set; }
+        protected internal void BuildQuery();
+        public override object Clone();
+        protected internal override void ParseQuery(string query);
+    }
+    public class RelationshipQuery : WqlObjectQuery {
+        public RelationshipQuery();
+        public RelationshipQuery(bool isSchemaQuery, string sourceObject, string relationshipClass, string relationshipQualifier, string thisRole);
+        public RelationshipQuery(string queryOrSourceObject);
+        public RelationshipQuery(string sourceObject, string relationshipClass);
+        public RelationshipQuery(string sourceObject, string relationshipClass, string relationshipQualifier, string thisRole, bool classDefinitionsOnly);
+        public bool ClassDefinitionsOnly { get; set; }
+        public bool IsSchemaQuery { get; set; }
+        public string RelationshipClass { get; set; }
+        public string RelationshipQualifier { get; set; }
+        public string SourceObject { get; set; }
+        public string ThisRole { get; set; }
+        protected internal void BuildQuery();
+        public override object Clone();
+        protected internal override void ParseQuery(string query);
+    }
+    public class SelectQuery : WqlObjectQuery {
+        public SelectQuery();
+        public SelectQuery(bool isSchemaQuery, string condition);
+        public SelectQuery(string queryOrClassName);
+        public SelectQuery(string className, string condition);
+        public SelectQuery(string className, string condition, string[] selectedProperties);
+        public string ClassName { get; set; }
+        public string Condition { get; set; }
+        public bool IsSchemaQuery { get; set; }
+        public override string QueryString { get; set; }
+        public StringCollection SelectedProperties { get; set; }
+        protected internal void BuildQuery();
+        public override object Clone();
+        protected internal override void ParseQuery(string query);
+    }
+    public class StoppedEventArgs : ManagementEventArgs {
+        public ManagementStatus Status { get; }
+    }
+    public delegate void StoppedEventHandler(object sender, StoppedEventArgs e); {
+        public StoppedEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, StoppedEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, StoppedEventArgs e);
+    }
+    public enum TextFormat {
+        CimDtd20 = 1,
+        Mof = 0,
+        WmiDtd20 = 2,
+    }
+    public class WqlEventQuery : EventQuery {
+        public WqlEventQuery();
+        public WqlEventQuery(string queryOrEventClassName);
+        public WqlEventQuery(string eventClassName, string condition);
+        public WqlEventQuery(string eventClassName, string condition, TimeSpan groupWithinInterval);
+        public WqlEventQuery(string eventClassName, string condition, TimeSpan groupWithinInterval, string[] groupByPropertyList);
+        public WqlEventQuery(string eventClassName, TimeSpan withinInterval);
+        public WqlEventQuery(string eventClassName, TimeSpan withinInterval, string condition);
+        public WqlEventQuery(string eventClassName, TimeSpan withinInterval, string condition, TimeSpan groupWithinInterval, string[] groupByPropertyList, string havingCondition);
+        public string Condition { get; set; }
+        public string EventClassName { get; set; }
+        public StringCollection GroupByPropertyList { get; set; }
+        public TimeSpan GroupWithinInterval { get; set; }
+        public string HavingCondition { get; set; }
+        public override string QueryLanguage { get; }
+        public override string QueryString { get; set; }
+        public TimeSpan WithinInterval { get; set; }
+        protected internal void BuildQuery();
+        public override object Clone();
+        protected internal override void ParseQuery(string query);
+    }
+    public class WqlObjectQuery : ObjectQuery {
+        public WqlObjectQuery();
+        public WqlObjectQuery(string query);
+        public override string QueryLanguage { get; }
+        public override object Clone();
+    }
+}
 namespace System.Net {
+    public sealed class DnsPermission : CodeAccessPermission, IUnrestrictedPermission {
+        public DnsPermission(PermissionState state);
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement securityElement);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class DnsPermissionAttribute : CodeAccessSecurityAttribute {
+        public DnsPermissionAttribute(SecurityAction action);
+        public override IPermission CreatePermission();
+    }
+    public class EndpointPermission {
+        public string Hostname { get; }
+        public int Port { get; }
+        public TransportType Transport { get; }
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+    }
     public enum HttpStatusCode {
+        AlreadyReported = 208,
+        EarlyHints = 103,
+        FailedDependency = 424,
+        IMUsed = 226,
+        InsufficientStorage = 507,
+        Locked = 423,
+        LoopDetected = 508,
+        MisdirectedRequest = 421,
+        MultiStatus = 207,
+        NetworkAuthenticationRequired = 511,
+        NotExtended = 510,
+        PermanentRedirect = 308,
+        PreconditionRequired = 428,
+        Processing = 102,
+        RequestHeaderFieldsTooLarge = 431,
+        TooManyRequests = 429,
+        UnavailableForLegalReasons = 451,
+        UnprocessableEntity = 422,
+        VariantAlsoNegotiates = 506,
     }
     public class IPAddress {
+        public IPAddress(ReadOnlySpan<byte> address);
+        public IPAddress(ReadOnlySpan<byte> address, long scopeid);
+        public static IPAddress Parse(ReadOnlySpan<char> ipString);
+        public bool TryFormat(Span<char> destination, out int charsWritten);
+        public static bool TryParse(ReadOnlySpan<char> ipString, out IPAddress address);
+        public bool TryWriteBytes(Span<byte> destination, out int bytesWritten);
     }
+    public enum NetworkAccess {
+        Accept = 128,
+        Connect = 64,
+    }
+    public sealed class SocketPermission : CodeAccessPermission, IUnrestrictedPermission {
+        public const int AllPorts = -1;
+        public SocketPermission(NetworkAccess access, TransportType transport, string hostName, int portNumber);
+        public SocketPermission(PermissionState state);
+        public IEnumerator AcceptList { get; }
+        public IEnumerator ConnectList { get; }
+        public void AddPermission(NetworkAccess access, TransportType transport, string hostName, int portNumber);
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement securityElement);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class SocketPermissionAttribute : CodeAccessSecurityAttribute {
+        public SocketPermissionAttribute(SecurityAction action);
+        public string Access { get; set; }
+        public string Host { get; set; }
+        public string Port { get; set; }
+        public string Transport { get; set; }
+        public override IPermission CreatePermission();
+    }
+    public enum TransportType {
+        All = 3,
+        Connectionless = 1,
+        ConnectionOriented = 2,
+        Tcp = 2,
+        Udp = 1,
+    }
+    public sealed class WebPermission : CodeAccessPermission, IUnrestrictedPermission {
+        public WebPermission();
+        public WebPermission(NetworkAccess access, Regex uriRegex);
+        public WebPermission(NetworkAccess access, string uriString);
+        public WebPermission(PermissionState state);
+        public IEnumerator AcceptList { get; }
+        public IEnumerator ConnectList { get; }
+        public void AddPermission(NetworkAccess access, Regex uriRegex);
+        public void AddPermission(NetworkAccess access, string uriString);
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement securityElement);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class WebPermissionAttribute : CodeAccessSecurityAttribute {
+        public WebPermissionAttribute(SecurityAction action);
+        public string Accept { get; set; }
+        public string AcceptPattern { get; set; }
+        public string Connect { get; set; }
+        public string ConnectPattern { get; set; }
+        public override IPermission CreatePermission();
+    }
 }
 namespace System.Net.Http {
+    public enum CookieUsePolicy {
+        IgnoreCookies = 0,
+        UseInternalCookieStoreOnly = 1,
+        UseSpecifiedCookieContainer = 2,
+    }
     public class HttpClient : HttpMessageInvoker {
+        public Task<HttpResponseMessage> PatchAsync(string requestUri, HttpContent content);
+        public Task<HttpResponseMessage> PatchAsync(string requestUri, HttpContent content, CancellationToken cancellationToken);
+        public Task<HttpResponseMessage> PatchAsync(Uri requestUri, HttpContent content);
+        public Task<HttpResponseMessage> PatchAsync(Uri requestUri, HttpContent content, CancellationToken cancellationToken);
     }
     public class HttpMethod : IEquatable<HttpMethod> {
+        public static HttpMethod Patch { get; }
     }
+    public sealed class ReadOnlyMemoryContent : HttpContent {
+        public ReadOnlyMemoryContent(ReadOnlyMemory<byte> content);
+    }
+    public static class RtcRequestFactory {
+        public static HttpRequestMessage Create(HttpMethod method, Uri uri);
+    }
+    public sealed class SocketsHttpHandler : HttpMessageHandler {
+        public SocketsHttpHandler();
+        public bool AllowAutoRedirect { get; set; }
+        public DecompressionMethods AutomaticDecompression { get; set; }
+        public TimeSpan ConnectTimeout { get; set; }
+        public CookieContainer CookieContainer { get; set; }
+        public ICredentials Credentials { get; set; }
+        public ICredentials DefaultProxyCredentials { get; set; }
+        public TimeSpan Expect100ContinueTimeout { get; set; }
+        public int MaxAutomaticRedirections { get; set; }
+        public int MaxConnectionsPerServer { get; set; }
+        public int MaxResponseDrainSize { get; set; }
+        public int MaxResponseHeadersLength { get; set; }
+        public TimeSpan PooledConnectionIdleTimeout { get; set; }
+        public TimeSpan PooledConnectionLifetime { get; set; }
+        public bool PreAuthenticate { get; set; }
+        public IDictionary<string, object> Properties { get; }
+        public IWebProxy Proxy { get; set; }
+        public SslClientAuthenticationOptions SslOptions { get; set; }
+        public bool UseCookies { get; set; }
+        public bool UseProxy { get; set; }
+    }
+    public enum WindowsProxyUsePolicy {
+        DoNotUseProxy = 0,
+        UseCustomProxy = 3,
+        UseWinHttpProxy = 1,
+        UseWinInetProxy = 2,
+    }
+    public class WinHttpHandler : HttpMessageHandler {
+        public WinHttpHandler();
+        public DecompressionMethods AutomaticDecompression { get; set; }
+        public bool AutomaticRedirection { get; set; }
+        public bool CheckCertificateRevocationList { get; set; }
+        public ClientCertificateOption ClientCertificateOption { get; set; }
+        public X509Certificate2Collection ClientCertificates { get; }
+        public CookieContainer CookieContainer { get; set; }
+        public CookieUsePolicy CookieUsePolicy { get; set; }
+        public ICredentials DefaultProxyCredentials { get; set; }
+        public int MaxAutomaticRedirections { get; set; }
+        public int MaxConnectionsPerServer { get; set; }
+        public int MaxResponseDrainSize { get; set; }
+        public int MaxResponseHeadersLength { get; set; }
+        public bool PreAuthenticate { get; set; }
+        public IDictionary<string, object> Properties { get; }
+        public IWebProxy Proxy { get; set; }
+        public TimeSpan ReceiveDataTimeout { get; set; }
+        public TimeSpan ReceiveHeadersTimeout { get; set; }
+        public TimeSpan SendTimeout { get; set; }
+        public Func<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> ServerCertificateValidationCallback { get; set; }
+        public ICredentials ServerCredentials { get; set; }
+        public SslProtocols SslProtocols { get; set; }
+        public WindowsProxyUsePolicy WindowsProxyUsePolicy { get; set; }
+        protected override void Dispose(bool disposing);
+        protected override Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
+    }
 }
 namespace System.Net.Mail {
+    public enum SmtpAccess {
+        Connect = 1,
+        ConnectToUnrestrictedPort = 2,
+        None = 0,
+    }
+    public sealed class SmtpPermission : CodeAccessPermission, IUnrestrictedPermission {
+        public SmtpPermission(bool unrestricted);
+        public SmtpPermission(PermissionState state);
+        public SmtpPermission(SmtpAccess access);
+        public SmtpAccess Access { get; }
+        public void AddPermission(SmtpAccess access);
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement securityElement);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class SmtpPermissionAttribute : CodeAccessSecurityAttribute {
+        public SmtpPermissionAttribute(SecurityAction action);
+        public string Access { get; set; }
+        public override IPermission CreatePermission();
+    }
 }
 namespace System.Net.Mime {
     public static class MediaTypeNames {
         public static class Application {
+            public const string Json = "application/json";
+            public const string Xml = "application/xml";
         }
     }
 }
 namespace System.Net.NetworkInformation {
+    public enum NetworkInformationAccess {
+        None = 0,
+        Ping = 4,
+        Read = 1,
+    }
+    public sealed class NetworkInformationPermission : CodeAccessPermission, IUnrestrictedPermission {
+        public NetworkInformationPermission(NetworkInformationAccess access);
+        public NetworkInformationPermission(PermissionState state);
+        public NetworkInformationAccess Access { get; }
+        public void AddPermission(NetworkInformationAccess access);
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement securityElement);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class NetworkInformationPermissionAttribute : CodeAccessSecurityAttribute {
+        public NetworkInformationPermissionAttribute(SecurityAction action);
+        public string Access { get; set; }
+        public override IPermission CreatePermission();
+    }
 }
+namespace System.Net.PeerToPeer {
+    public sealed class PnrpPermission : CodeAccessPermission, IUnrestrictedPermission {
+        public PnrpPermission(PermissionState state);
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement e);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class PnrpPermissionAttribute : CodeAccessSecurityAttribute {
+        public PnrpPermissionAttribute(SecurityAction action);
+        public override IPermission CreatePermission();
+    }
+    public enum PnrpScope {
+        All = 0,
+        Global = 1,
+        LinkLocal = 3,
+        SiteLocal = 2,
+    }
+}
+namespace System.Net.PeerToPeer.Collaboration {
+    public sealed class PeerCollaborationPermission : CodeAccessPermission, IUnrestrictedPermission {
+        public PeerCollaborationPermission(PermissionState state);
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement e);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class PeerCollaborationPermissionAttribute : CodeAccessSecurityAttribute {
+        public PeerCollaborationPermissionAttribute(SecurityAction action);
+        public override IPermission CreatePermission();
+    }
+}
 namespace System.Net.Security {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SslApplicationProtocol : IEquatable<SslApplicationProtocol> {
+        public static readonly SslApplicationProtocol Http11;
+        public static readonly SslApplicationProtocol Http2;
+        public SslApplicationProtocol(byte[] protocol);
+        public SslApplicationProtocol(string protocol);
+        public ReadOnlyMemory<byte> Protocol { get; }
+        public override bool Equals(object obj);
+        public bool Equals(SslApplicationProtocol other);
+        public override int GetHashCode();
+        public static bool operator ==(SslApplicationProtocol left, SslApplicationProtocol right);
+        public static bool operator !=(SslApplicationProtocol left, SslApplicationProtocol right);
+        public override string ToString();
+    }
+    public class SslClientAuthenticationOptions {
+        public SslClientAuthenticationOptions();
+        public bool AllowRenegotiation { get; set; }
+        public List<SslApplicationProtocol> ApplicationProtocols { get; set; }
+        public X509RevocationMode CertificateRevocationCheckMode { get; set; }
+        public X509CertificateCollection ClientCertificates { get; set; }
+        public SslProtocols EnabledSslProtocols { get; set; }
+        public EncryptionPolicy EncryptionPolicy { get; set; }
+        public LocalCertificateSelectionCallback LocalCertificateSelectionCallback { get; set; }
+        public RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; set; }
+        public string TargetHost { get; set; }
+    }
+    public class SslServerAuthenticationOptions {
+        public SslServerAuthenticationOptions();
+        public bool AllowRenegotiation { get; set; }
+        public List<SslApplicationProtocol> ApplicationProtocols { get; set; }
+        public X509RevocationMode CertificateRevocationCheckMode { get; set; }
+        public bool ClientCertificateRequired { get; set; }
+        public SslProtocols EnabledSslProtocols { get; set; }
+        public EncryptionPolicy EncryptionPolicy { get; set; }
+        public RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; set; }
+        public X509Certificate ServerCertificate { get; set; }
+    }
     public class SslStream : AuthenticatedStream {
+        public SslApplicationProtocol NegotiatedApplicationProtocol { get; }
+        public Task AuthenticateAsClientAsync(SslClientAuthenticationOptions sslClientAuthenticationOptions, CancellationToken cancellationToken);
+        public Task AuthenticateAsServerAsync(SslServerAuthenticationOptions sslServerAuthenticationOptions, CancellationToken cancellationToken);
     }
 }
 namespace System.Net.Sockets {
     public class Socket : IDisposable {
+        public int Receive(Span<byte> buffer);
+        public int Receive(Span<byte> buffer, SocketFlags socketFlags);
+        public int Receive(Span<byte> buffer, SocketFlags socketFlags, out SocketError errorCode);
+        public int Send(ReadOnlySpan<byte> buffer);
+        public int Send(ReadOnlySpan<byte> buffer, SocketFlags socketFlags);
+        public int Send(ReadOnlySpan<byte> buffer, SocketFlags socketFlags, out SocketError errorCode);
     }
     public class SocketAsyncEventArgs : EventArgs, IDisposable {
+        public Memory<byte> MemoryBuffer { get; }
+        public void SetBuffer(Memory<byte> buffer);
     }
     public static class SocketTaskExtensions {
+        public static ValueTask<int> ReceiveAsync(this Socket socket, Memory<byte> buffer, SocketFlags socketFlags, CancellationToken cancellationToken=default(CancellationToken));
+        public static ValueTask<int> SendAsync(this Socket socket, ReadOnlyMemory<byte> buffer, SocketFlags socketFlags, CancellationToken cancellationToken=default(CancellationToken));
     }
+    public sealed class UnixDomainSocketEndPoint : EndPoint {
+        public UnixDomainSocketEndPoint(string path);
+    }
 }
 namespace System.Net.WebSockets {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ValueWebSocketReceiveResult {
+        public ValueWebSocketReceiveResult(int count, WebSocketMessageType messageType, bool endOfMessage);
+        public int Count { get; }
+        public bool EndOfMessage { get; }
+        public WebSocketMessageType MessageType { get; }
+    }
     public abstract class WebSocket : IDisposable {
+        public static WebSocket CreateFromStream(Stream stream, bool isServer, string subProtocol, TimeSpan keepAliveInterval, Memory<byte> buffer=default(Memory<byte>));
+        public virtual ValueTask<ValueWebSocketReceiveResult> ReceiveAsync(Memory<byte> buffer, CancellationToken cancellationToken);
+        public virtual ValueTask SendAsync(ReadOnlyMemory<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
     }
+    public static class WebSocketProtocol {
+        public static WebSocket CreateFromStream(Stream stream, bool isServer, string subProtocol, TimeSpan keepAliveInterval, Memory<byte> buffer=default(Memory<byte>));
+    }
 }
 namespace System.Numerics {
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct BigInteger : IComparable, IComparable<BigInteger>, IEquatable<BigInteger>, IFormattable {
+        public BigInteger(ReadOnlySpan<byte> value, bool isUnsigned=false, bool isBigEndian=false);
+        public int GetByteCount(bool isUnsigned=false);
+        public static BigInteger Parse(ReadOnlySpan<char> value, NumberStyles style=7, IFormatProvider provider=null);
+        public byte[] ToByteArray(bool isUnsigned=false, bool isBigEndian=false);
+        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format=default(ReadOnlySpan<char>), IFormatProvider provider=null);
+        public static bool TryParse(ReadOnlySpan<char> value, out BigInteger result);
+        public static bool TryParse(ReadOnlySpan<char> value, NumberStyles style, IFormatProvider provider, out BigInteger result);
+        public bool TryWriteBytes(Span<byte> destination, out int bytesWritten, bool isUnsigned=false, bool isBigEndian=false);
     }
 }
 namespace System.Reflection {
     public abstract class Assembly : ICustomAttributeProvider, ISerializable {
+        public virtual Type[] GetForwardedTypes();
     }
     public enum BindingFlags {
+        DoNotWrapExceptions = 33554432,
     }
     public abstract class MemberInfo : ICustomAttributeProvider {
+        public virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
     }
     public abstract class MethodBase : MemberInfo {
+        public virtual bool IsConstructedGenericMethod { get; }
     }
     public class TypeDelegator : TypeInfo {
+        public override bool IsByRefLike { get; }
+        public override bool IsGenericMethodParameter { get; }
+        public override bool IsGenericTypeParameter { get; }
     }
 }
+namespace System.Reflection.Context {
+    public abstract class CustomReflectionContext : ReflectionContext {
+        protected CustomReflectionContext();
+        protected CustomReflectionContext(ReflectionContext source);
+        protected virtual IEnumerable<PropertyInfo> AddProperties(Type type);
+        protected PropertyInfo CreateProperty(Type propertyType, string name, Func<object, object> getter, Action<object, object> setter);
+        protected PropertyInfo CreateProperty(Type propertyType, string name, Func<object, object> getter, Action<object, object> setter, IEnumerable<Attribute> propertyCustomAttributes, IEnumerable<Attribute> getterCustomAttributes, IEnumerable<Attribute> setterCustomAttributes);
+        protected virtual IEnumerable<object> GetCustomAttributes(MemberInfo member, IEnumerable<object> declaredAttributes);
+        protected virtual IEnumerable<object> GetCustomAttributes(ParameterInfo parameter, IEnumerable<object> declaredAttributes);
+        public override Assembly MapAssembly(Assembly assembly);
+        public override TypeInfo MapType(TypeInfo type);
+    }
+}
 namespace System.Reflection.Emit {
     public sealed class EnumBuilder : Type {
+        public override bool IsByRefLike { get; }
     }
     public sealed class GenericTypeParameterBuilder : Type {
+        public override bool IsByRefLike { get; }
     }
     public class ILGenerator {
+        public virtual void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);
     }
     public sealed class MethodBuilder : MethodInfo {
+        public override bool IsConstructedGenericMethod { get; }
     }
     public sealed class TypeBuilder : Type {
+        public override bool IsByRefLike { get; }
     }
 }
 namespace System.Reflection.Metadata {
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct AssemblyDefinition {
+        public AssemblyName GetAssemblyName();
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct AssemblyReference {
+        public AssemblyName GetAssemblyName();
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct EventAccessors {
+        public ImmutableArray<MethodDefinitionHandle> Others { get; }
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct ModuleDefinition {
+        public CustomAttributeHandleCollection GetCustomAttributes();
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct PropertyAccessors {
+        public ImmutableArray<MethodDefinitionHandle> Others { get; }
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct TypeDefinition {
+        public bool IsNested { get; }
     }
 }
+namespace System.Runtime.Caching {
+    public abstract class CacheEntryChangeMonitor : ChangeMonitor {
+        protected CacheEntryChangeMonitor();
+        public abstract ReadOnlyCollection<string> CacheKeys { get; }
+        public abstract DateTimeOffset LastModified { get; }
+        public abstract string RegionName { get; }
+    }
+    public class CacheEntryRemovedArguments {
+        public CacheEntryRemovedArguments(ObjectCache source, CacheEntryRemovedReason reason, CacheItem cacheItem);
+        public CacheItem CacheItem { get; }
+        public CacheEntryRemovedReason RemovedReason { get; }
+        public ObjectCache Source { get; }
+    }
+    public delegate void CacheEntryRemovedCallback(CacheEntryRemovedArguments arguments); {
+        public CacheEntryRemovedCallback(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(CacheEntryRemovedArguments arguments, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(CacheEntryRemovedArguments arguments);
+    }
+    public enum CacheEntryRemovedReason {
+        CacheSpecificEviction = 4,
+        ChangeMonitorChanged = 3,
+        Evicted = 2,
+        Expired = 1,
+        Removed = 0,
+    }
+    public class CacheEntryUpdateArguments {
+        public CacheEntryUpdateArguments(ObjectCache source, CacheEntryRemovedReason reason, string key, string regionName);
+        public string Key { get; }
+        public string RegionName { get; }
+        public CacheEntryRemovedReason RemovedReason { get; }
+        public ObjectCache Source { get; }
+        public CacheItem UpdatedCacheItem { get; set; }
+        public CacheItemPolicy UpdatedCacheItemPolicy { get; set; }
+    }
+    public delegate void CacheEntryUpdateCallback(CacheEntryUpdateArguments arguments); {
+        public CacheEntryUpdateCallback(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(CacheEntryUpdateArguments arguments, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(CacheEntryUpdateArguments arguments);
+    }
+    public class CacheItem {
+        public CacheItem(string key);
+        public CacheItem(string key, object value);
+        public CacheItem(string key, object value, string regionName);
+        public string Key { get; set; }
+        public string RegionName { get; set; }
+        public object Value { get; set; }
+    }
+    public class CacheItemPolicy {
+        public CacheItemPolicy();
+        public DateTimeOffset AbsoluteExpiration { get; set; }
+        public Collection<ChangeMonitor> ChangeMonitors { get; }
+        public CacheItemPriority Priority { get; set; }
+        public CacheEntryRemovedCallback RemovedCallback { get; set; }
+        public TimeSpan SlidingExpiration { get; set; }
+        public CacheEntryUpdateCallback UpdateCallback { get; set; }
+    }
+    public enum CacheItemPriority {
+        Default = 0,
+        NotRemovable = 1,
+    }
+    public abstract class ChangeMonitor : IDisposable {
+        protected ChangeMonitor();
+        public bool HasChanged { get; }
+        public bool IsDisposed { get; }
+        public abstract string UniqueId { get; }
+        public void Dispose();
+        protected abstract void Dispose(bool disposing);
+        protected void InitializationComplete();
+        public void NotifyOnChanged(OnChangedCallback onChangedCallback);
+        protected void OnChanged(object state);
+    }
+    public enum DefaultCacheCapabilities {
+        AbsoluteExpirations = 8,
+        CacheEntryChangeMonitors = 4,
+        CacheEntryRemovedCallback = 64,
+        CacheEntryUpdateCallback = 32,
+        CacheRegions = 128,
+        InMemoryProvider = 1,
+        None = 0,
+        OutOfProcessProvider = 2,
+        SlidingExpirations = 16,
+    }
+    public abstract class FileChangeMonitor : ChangeMonitor {
+        protected FileChangeMonitor();
+        public abstract ReadOnlyCollection<string> FilePaths { get; }
+        public abstract DateTimeOffset LastModified { get; }
+    }
+    public sealed class HostFileChangeMonitor : FileChangeMonitor {
+        public HostFileChangeMonitor(IList<string> filePaths);
+        public override ReadOnlyCollection<string> FilePaths { get; }
+        public override DateTimeOffset LastModified { get; }
+        public override string UniqueId { get; }
+    }
+    public class MemoryCache : ObjectCache, IDisposable, IEnumerable {
+        public MemoryCache(string name, NameValueCollection config=null);
+        public MemoryCache(string name, NameValueCollection config, bool ignoreConfigSection);
+        public long CacheMemoryLimit { get; }
+        public static MemoryCache Default { get; }
+        public override DefaultCacheCapabilities DefaultCacheCapabilities { get; }
+        public override object this[string key] { get; set; }
+        public override string Name { get; }
+        public long PhysicalMemoryLimit { get; }
+        public TimeSpan PollingInterval { get; }
+        public override bool Add(CacheItem item, CacheItemPolicy policy);
+        public override CacheItem AddOrGetExisting(CacheItem item, CacheItemPolicy policy);
+        public override object AddOrGetExisting(string key, object value, CacheItemPolicy policy, string regionName=null);
+        public override object AddOrGetExisting(string key, object value, DateTimeOffset absoluteExpiration, string regionName=null);
+        public override bool Contains(string key, string regionName=null);
+        public override CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(IEnumerable<string> keys, string regionName=null);
+        public void Dispose();
+        public override object Get(string key, string regionName=null);
+        public override CacheItem GetCacheItem(string key, string regionName=null);
+        public override long GetCount(string regionName=null);
+        protected override IEnumerator<KeyValuePair<string, object>> GetEnumerator();
+        public long GetLastSize(string regionName=null);
+        public override IDictionary<string, object> GetValues(IEnumerable<string> keys, string regionName=null);
+        public object Remove(string key, CacheEntryRemovedReason reason, string regionName=null);
+        public override object Remove(string key, string regionName=null);
+        public override void Set(CacheItem item, CacheItemPolicy policy);
+        public override void Set(string key, object value, CacheItemPolicy policy, string regionName=null);
+        public override void Set(string key, object value, DateTimeOffset absoluteExpiration, string regionName=null);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public long Trim(int percent);
+    }
+    public abstract class ObjectCache : IEnumerable, IEnumerable<KeyValuePair<string, object>> {
+        public static readonly DateTimeOffset InfiniteAbsoluteExpiration;
+        public static readonly TimeSpan NoSlidingExpiration;
+        protected ObjectCache();
+        public abstract DefaultCacheCapabilities DefaultCacheCapabilities { get; }
+        public static IServiceProvider Host { get; set; }
+        public abstract object this[string key] { get; set; }
+        public abstract string Name { get; }
+        public virtual bool Add(CacheItem item, CacheItemPolicy policy);
+        public virtual bool Add(string key, object value, CacheItemPolicy policy, string regionName=null);
+        public virtual bool Add(string key, object value, DateTimeOffset absoluteExpiration, string regionName=null);
+        public abstract CacheItem AddOrGetExisting(CacheItem value, CacheItemPolicy policy);
+        public abstract object AddOrGetExisting(string key, object value, CacheItemPolicy policy, string regionName=null);
+        public abstract object AddOrGetExisting(string key, object value, DateTimeOffset absoluteExpiration, string regionName=null);
+        public abstract bool Contains(string key, string regionName=null);
+        public abstract CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(IEnumerable<string> keys, string regionName=null);
+        public abstract object Get(string key, string regionName=null);
+        public abstract CacheItem GetCacheItem(string key, string regionName=null);
+        public abstract long GetCount(string regionName=null);
+        protected abstract IEnumerator<KeyValuePair<string, object>> GetEnumerator();
+        public abstract IDictionary<string, object> GetValues(IEnumerable<string> keys, string regionName=null);
+        public virtual IDictionary<string, object> GetValues(string regionName, params string[] keys);
+        public abstract object Remove(string key, string regionName=null);
+        public abstract void Set(CacheItem item, CacheItemPolicy policy);
+        public abstract void Set(string key, object value, CacheItemPolicy policy, string regionName=null);
+        public abstract void Set(string key, object value, DateTimeOffset absoluteExpiration, string regionName=null);
+        IEnumerator<KeyValuePair<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public delegate void OnChangedCallback(object state); {
+        public OnChangedCallback(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object state);
+    }
+}
+namespace System.Runtime.Caching.Hosting {
+    public interface IApplicationIdentifier {
+        string GetApplicationId();
+    }
+    public interface IFileChangeNotificationSystem {
+        void StartMonitoring(string filePath, OnChangedCallback onChangedCallback, out object state, out DateTimeOffset lastWriteTime, out long fileSize);
+        void StopMonitoring(string filePath, object state);
+    }
+    public interface IMemoryCacheManager {
+        void ReleaseCache(MemoryCache cache);
+        void UpdateCacheSize(long size, MemoryCache cache);
+    }
+}
 namespace System.Runtime.CompilerServices {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct AsyncValueTaskMethodBuilder {
+        public ValueTask Task { get; }
+        public void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : INotifyCompletion where TStateMachine : IAsyncStateMachine;
+        public void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine) where TAwaiter : ICriticalNotifyCompletion where TStateMachine : IAsyncStateMachine;
+        public static AsyncValueTaskMethodBuilder Create();
+        public void SetException(Exception exception);
+        public void SetResult();
+        public void SetStateMachine(IAsyncStateMachine stateMachine);
+        public void Start<TStateMachine>(ref TStateMachine stateMachine) where TStateMachine : IAsyncStateMachine;
+    }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
-    public struct AsyncValueTaskMethodBuilder<TResult> {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct AsyncValueTaskMethodBuilder<TResult> {
     }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ConfiguredValueTaskAwaitable {
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct ConfiguredValueTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion {
+            public bool IsCompleted { get; }
+            public void GetResult();
+            public void OnCompleted(Action continuation);
+            public void UnsafeOnCompleted(Action continuation);
+        }
+        public ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter GetAwaiter();
+    }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
-    public struct ConfiguredValueTaskAwaitable<TResult> {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ConfiguredValueTaskAwaitable<TResult> {
-        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
-        public struct ConfiguredValueTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion {
+        [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+        public struct ConfiguredValueTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion {
         }
     }
     public static class RuntimeFeature {
+        public const string DefaultImplementationsOfInterfaces = "DefaultImplementationsOfInterfaces";
+        public const string PortablePdb = "PortablePdb";
     }
     public sealed class RuntimeWrappedException : Exception {
+        public RuntimeWrappedException(object thrownObject);
     }
+    public static class Unsafe {
+        public static ref T Add<T>(ref T source, int elementOffset);
+        public static ref T Add<T>(ref T source, IntPtr elementOffset);
+        public unsafe static void* Add<T>(void* source, int elementOffset);
+        public static ref T AddByteOffset<T>(ref T source, IntPtr byteOffset);
+        public static bool AreSame<T>(ref T left, ref T right);
+        public static T As<T>(object o) where T : class;
+        public static ref TTo As<TFrom, TTo>(ref TFrom source);
+        public unsafe static void* AsPointer<T>(ref T value);
+        public static ref T AsRef<T>(ref T source);
+        public unsafe static ref T AsRef<T>(void* source);
+        public static IntPtr ByteOffset<T>(ref T origin, ref T target);
+        public unsafe static void Copy<T>(void* destination, ref T source);
+        public unsafe static void Copy<T>(ref T destination, void* source);
+        public static void CopyBlock(ref byte destination, ref byte source, uint byteCount);
+        public unsafe static void CopyBlock(void* destination, void* source, uint byteCount);
+        public static void CopyBlockUnaligned(ref byte destination, ref byte source, uint byteCount);
+        public unsafe static void CopyBlockUnaligned(void* destination, void* source, uint byteCount);
+        public static void InitBlock(ref byte startAddress, byte value, uint byteCount);
+        public unsafe static void InitBlock(void* startAddress, byte value, uint byteCount);
+        public static void InitBlockUnaligned(ref byte startAddress, byte value, uint byteCount);
+        public unsafe static void InitBlockUnaligned(void* startAddress, byte value, uint byteCount);
+        public static bool IsAddressGreaterThan<T>(ref T left, ref T right);
+        public static bool IsAddressLessThan<T>(ref T left, ref T right);
+        public unsafe static T Read<T>(void* source);
+        public static T ReadUnaligned<T>(ref byte source);
+        public unsafe static T ReadUnaligned<T>(void* source);
+        public static int SizeOf<T>();
+        public static ref T Subtract<T>(ref T source, int elementOffset);
+        public static ref T Subtract<T>(ref T source, IntPtr elementOffset);
+        public unsafe static void* Subtract<T>(void* source, int elementOffset);
+        public static ref T SubtractByteOffset<T>(ref T source, IntPtr byteOffset);
+        public unsafe static void Write<T>(void* destination, T value);
+        public static void WriteUnaligned<T>(ref byte destination, T value);
+        public unsafe static void WriteUnaligned<T>(void* destination, T value);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ValueTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion {
+        public bool IsCompleted { get; }
+        public void GetResult();
+        public void OnCompleted(Action continuation);
+        public void UnsafeOnCompleted(Action continuation);
+    }
 }
 namespace System.Runtime.InteropServices {
+    public static class MemoryMarshal {
+        public static Memory<T> AsMemory<T>(ReadOnlyMemory<T> readOnlyMemory);
+        public static Span<TTo> Cast<TFrom, TTo>(Span<TFrom> source) where TFrom : struct where TTo : struct;
+        public static ReadOnlySpan<TTo> Cast<TFrom, TTo>(ReadOnlySpan<TFrom> source) where TFrom : struct where TTo : struct;
+        public static ReadOnlySpan<T> CreateReadOnlySpan<T>(ref T reference, int length);
+        public static Span<T> CreateSpan<T>(ref T reference, int length);
+        public static ref T GetReference<T>(Span<T> span);
+        public static ref T GetReference<T>(ReadOnlySpan<T> span);
+        public static IEnumerable<T> ToEnumerable<T>(ReadOnlyMemory<T> memory);
+        public static bool TryGetArray<T>(ReadOnlyMemory<T> readOnlyMemory, out ArraySegment<T> arraySegment);
+        public static bool TryGetOwnedMemory<T, TOwner>(ReadOnlyMemory<T> readOnlyMemory, out TOwner ownedMemory) where TOwner : OwnedMemory<T>;
+        public static bool TryGetOwnedMemory<T, TOwner>(ReadOnlyMemory<T> readOnlyMemory, out TOwner ownedMemory, out int index, out int length) where TOwner : OwnedMemory<T>;
+        public static bool TryGetString(ReadOnlyMemory<char> readOnlyMemory, out string text, out int start, out int length);
+    }
+    public static class SequenceMarshal {
+        public static bool TryGetArray<T>(ReadOnlySequence<T> sequence, out ArraySegment<T> arraySegment);
+        public static bool TryGetOwnedMemory<T>(ReadOnlySequence<T> sequence, out OwnedMemory<T> ownedMemory, out int start, out int length);
+        public static bool TryGetReadOnlyMemory<T>(ReadOnlySequence<T> sequence, out ReadOnlyMemory<T> readOnlyMemory);
+        public static bool TryGetReadOnlySequenceSegment<T>(ReadOnlySequence<T> sequence, out ReadOnlySequenceSegment<T> startSegment, out int startIndex, out ReadOnlySequenceSegment<T> endSegment, out int endIndex);
+    }
 }
+namespace System.Runtime.Intrinsics {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=16)]
+    public struct Vector128<T> where T : struct
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=32)]
+    public struct Vector256<T> where T : struct
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=8)]
+    public struct Vector64<T> where T : struct
+}
+namespace System.Runtime.Intrinsics.Arm.Arm64 {
+    public static class Aes {
+        public static bool IsSupported { get; }
+        public static Vector128<byte> Decrypt(Vector128<byte> value, Vector128<byte> roundKey);
+        public static Vector128<byte> Encrypt(Vector128<byte> value, Vector128<byte> roundKey);
+        public static Vector128<byte> InverseMixColumns(Vector128<byte> value);
+        public static Vector128<byte> MixColumns(Vector128<byte> value);
+    }
+    public static class Sha1 {
+        public static bool IsSupported { get; }
+        public static uint FixedRotate(uint hash_e);
+        public static Vector128<uint> HashChoose(Vector128<uint> hash_abcd, uint hash_e, Vector128<uint> wk);
+        public static Vector128<uint> HashMajority(Vector128<uint> hash_abcd, uint hash_e, Vector128<uint> wk);
+        public static Vector128<uint> HashParity(Vector128<uint> hash_abcd, uint hash_e, Vector128<uint> wk);
+        public static Vector128<uint> SchedulePart1(Vector128<uint> w0_3, Vector128<uint> w4_7, Vector128<uint> w8_11);
+        public static Vector128<uint> SchedulePart2(Vector128<uint> tw0_3, Vector128<uint> w12_15);
+    }
+    public static class Sha256 {
+        public static bool IsSupported { get; }
+        public static Vector128<uint> HashLower(Vector128<uint> hash_abcd, Vector128<uint> hash_efgh, Vector128<uint> wk);
+        public static Vector128<uint> HashUpper(Vector128<uint> hash_efgh, Vector128<uint> hash_abcd, Vector128<uint> wk);
+        public static Vector128<uint> SchedulePart1(Vector128<uint> w0_3, Vector128<uint> w4_7);
+        public static Vector128<uint> SchedulePart2(Vector128<uint> w0_3, Vector128<uint> w8_11, Vector128<uint> w12_15);
+    }
+    public static class Simd {
+        public static bool IsSupported { get; }
+        public static Vector128<byte> Abs(Vector128<sbyte> value);
+        public static Vector128<ushort> Abs(Vector128<short> value);
+        public static Vector128<uint> Abs(Vector128<int> value);
+        public static Vector128<ulong> Abs(Vector128<long> value);
+        public static Vector128<float> Abs(Vector128<float> value);
+        public static Vector128<double> Abs(Vector128<double> value);
+        public static Vector64<byte> Abs(Vector64<sbyte> value);
+        public static Vector64<ushort> Abs(Vector64<short> value);
+        public static Vector64<uint> Abs(Vector64<int> value);
+        public static Vector64<float> Abs(Vector64<float> value);
+        public static Vector64<T> Add<T>(Vector64<T> left, Vector64<T> right) where T : struct;
+        public static Vector128<T> Add<T>(Vector128<T> left, Vector128<T> right) where T : struct;
+        public static Vector64<T> And<T>(Vector64<T> left, Vector64<T> right) where T : struct;
+        public static Vector128<T> And<T>(Vector128<T> left, Vector128<T> right) where T : struct;
+        public static Vector64<T> AndNot<T>(Vector64<T> left, Vector64<T> right) where T : struct;
+        public static Vector128<T> AndNot<T>(Vector128<T> left, Vector128<T> right) where T : struct;
+        public static Vector64<T> BitwiseSelect<T>(Vector64<T> sel, Vector64<T> left, Vector64<T> right) where T : struct;
+        public static Vector128<T> BitwiseSelect<T>(Vector128<T> sel, Vector128<T> left, Vector128<T> right) where T : struct;
+        public static Vector64<T> CompareEqual<T>(Vector64<T> left, Vector64<T> right) where T : struct;
+        public static Vector128<T> CompareEqual<T>(Vector128<T> left, Vector128<T> right) where T : struct;
+        public static Vector64<T> CompareEqualZero<T>(Vector64<T> value) where T : struct;
+        public static Vector128<T> CompareEqualZero<T>(Vector128<T> value) where T : struct;
+        public static Vector64<T> CompareGreaterThan<T>(Vector64<T> left, Vector64<T> right) where T : struct;
+        public static Vector128<T> CompareGreaterThan<T>(Vector128<T> left, Vector128<T> right) where T : struct;
+        public static Vector64<T> CompareGreaterThanOrEqual<T>(Vector64<T> left, Vector64<T> right) where T : struct;
+        public static Vector128<T> CompareGreaterThanOrEqual<T>(Vector128<T> left, Vector128<T> right) where T : struct;
+        public static Vector64<T> CompareGreaterThanOrEqualZero<T>(Vector64<T> value) where T : struct;
+        public static Vector128<T> CompareGreaterThanOrEqualZero<T>(Vector128<T> value) where T : struct;
+        public static Vector64<T> CompareGreaterThanZero<T>(Vector64<T> value) where T : struct;
+        public static Vector128<T> CompareGreaterThanZero<T>(Vector128<T> value) where T : struct;
+        public static Vector64<T> CompareLessThanOrEqualZero<T>(Vector64<T> value) where T : struct;
+        public static Vector128<T> CompareLessThanOrEqualZero<T>(Vector128<T> value) where T : struct;
+        public static Vector64<T> CompareLessThanZero<T>(Vector64<T> value) where T : struct;
+        public static Vector128<T> CompareLessThanZero<T>(Vector128<T> value) where T : struct;
+        public static Vector64<T> CompareTest<T>(Vector64<T> left, Vector64<T> right) where T : struct;
+        public static Vector128<T> CompareTest<T>(Vector128<T> left, Vector128<T> right) where T : struct;
+        public static Vector128<float> Divide(Vector128<float> left, Vector128<float> right);
+        public static Vector128<double> Divide(Vector128<double> left, Vector128<double> right);
+        public static Vector64<float> Divide(Vector64<float> left, Vector64<float> right);
+        public static T Extract<T>(Vector64<T> vector, byte index) where T : struct;
+        public static T Extract<T>(Vector128<T> vector, byte index) where T : struct;
+        public static Vector64<T> Insert<T>(Vector64<T> vector, byte index, T data) where T : struct;
+        public static Vector128<T> Insert<T>(Vector128<T> vector, byte index, T data) where T : struct;
+        public static Vector128<sbyte> LeadingSignCount(Vector128<sbyte> value);
+        public static Vector128<short> LeadingSignCount(Vector128<short> value);
+        public static Vector128<int> LeadingSignCount(Vector128<int> value);
+        public static Vector64<sbyte> LeadingSignCount(Vector64<sbyte> value);
+        public static Vector64<short> LeadingSignCount(Vector64<short> value);
+        public static Vector64<int> LeadingSignCount(Vector64<int> value);
+        public static Vector128<byte> LeadingZeroCount(Vector128<byte> value);
+        public static Vector128<sbyte> LeadingZeroCount(Vector128<sbyte> value);
+        public static Vector128<short> LeadingZeroCount(Vector128<short> value);
+        public static Vector128<int> LeadingZeroCount(Vector128<int> value);
+        public static Vector128<ushort> LeadingZeroCount(Vector128<ushort> value);
+        public static Vector128<uint> LeadingZeroCount(Vector128<uint> value);
+        public static Vector64<byte> LeadingZeroCount(Vector64<byte> value);
+        public static Vector64<sbyte> LeadingZeroCount(Vector64<sbyte> value);
+        public static Vector64<short> LeadingZeroCount(Vector64<short> value);
+        public static Vector64<int> LeadingZeroCount(Vector64<int> value);
+        public static Vector64<ushort> LeadingZeroCount(Vector64<ushort> value);
+        public static Vector64<uint> LeadingZeroCount(Vector64<uint> value);
+        public static Vector128<byte> Max(Vector128<byte> left, Vector128<byte> right);
+        public static Vector128<sbyte> Max(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static Vector128<short> Max(Vector128<short> left, Vector128<short> right);
+        public static Vector128<int> Max(Vector128<int> left, Vector128<int> right);
+        public static Vector128<ushort> Max(Vector128<ushort> left, Vector128<ushort> right);
+        public static Vector128<uint> Max(Vector128<uint> left, Vector128<uint> right);
+        public static Vector128<float> Max(Vector128<float> left, Vector128<float> right);
+        public static Vector128<double> Max(Vector128<double> left, Vector128<double> right);
+        public static Vector64<byte> Max(Vector64<byte> left, Vector64<byte> right);
+        public static Vector64<sbyte> Max(Vector64<sbyte> left, Vector64<sbyte> right);
+        public static Vector64<short> Max(Vector64<short> left, Vector64<short> right);
+        public static Vector64<int> Max(Vector64<int> left, Vector64<int> right);
+        public static Vector64<ushort> Max(Vector64<ushort> left, Vector64<ushort> right);
+        public static Vector64<uint> Max(Vector64<uint> left, Vector64<uint> right);
+        public static Vector64<float> Max(Vector64<float> left, Vector64<float> right);
+        public static Vector128<byte> Min(Vector128<byte> left, Vector128<byte> right);
+        public static Vector128<sbyte> Min(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static Vector128<short> Min(Vector128<short> left, Vector128<short> right);
+        public static Vector128<int> Min(Vector128<int> left, Vector128<int> right);
+        public static Vector128<ushort> Min(Vector128<ushort> left, Vector128<ushort> right);
+        public static Vector128<uint> Min(Vector128<uint> left, Vector128<uint> right);
+        public static Vector128<float> Min(Vector128<float> left, Vector128<float> right);
+        public static Vector128<double> Min(Vector128<double> left, Vector128<double> right);
+        public static Vector64<byte> Min(Vector64<byte> left, Vector64<byte> right);
+        public static Vector64<sbyte> Min(Vector64<sbyte> left, Vector64<sbyte> right);
+        public static Vector64<short> Min(Vector64<short> left, Vector64<short> right);
+        public static Vector64<int> Min(Vector64<int> left, Vector64<int> right);
+        public static Vector64<ushort> Min(Vector64<ushort> left, Vector64<ushort> right);
+        public static Vector64<uint> Min(Vector64<uint> left, Vector64<uint> right);
+        public static Vector64<float> Min(Vector64<float> left, Vector64<float> right);
+        public static Vector128<byte> Multiply(Vector128<byte> left, Vector128<byte> right);
+        public static Vector128<sbyte> Multiply(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static Vector128<short> Multiply(Vector128<short> left, Vector128<short> right);
+        public static Vector128<int> Multiply(Vector128<int> left, Vector128<int> right);
+        public static Vector128<ushort> Multiply(Vector128<ushort> left, Vector128<ushort> right);
+        public static Vector128<uint> Multiply(Vector128<uint> left, Vector128<uint> right);
+        public static Vector128<float> Multiply(Vector128<float> left, Vector128<float> right);
+        public static Vector128<double> Multiply(Vector128<double> left, Vector128<double> right);
+        public static Vector64<byte> Multiply(Vector64<byte> left, Vector64<byte> right);
+        public static Vector64<sbyte> Multiply(Vector64<sbyte> left, Vector64<sbyte> right);
+        public static Vector64<short> Multiply(Vector64<short> left, Vector64<short> right);
+        public static Vector64<int> Multiply(Vector64<int> left, Vector64<int> right);
+        public static Vector64<ushort> Multiply(Vector64<ushort> left, Vector64<ushort> right);
+        public static Vector64<uint> Multiply(Vector64<uint> left, Vector64<uint> right);
+        public static Vector64<float> Multiply(Vector64<float> left, Vector64<float> right);
+        public static Vector128<sbyte> Negate(Vector128<sbyte> value);
+        public static Vector128<short> Negate(Vector128<short> value);
+        public static Vector128<int> Negate(Vector128<int> value);
+        public static Vector128<long> Negate(Vector128<long> value);
+        public static Vector128<float> Negate(Vector128<float> value);
+        public static Vector128<double> Negate(Vector128<double> value);
+        public static Vector64<sbyte> Negate(Vector64<sbyte> value);
+        public static Vector64<short> Negate(Vector64<short> value);
+        public static Vector64<int> Negate(Vector64<int> value);
+        public static Vector64<float> Negate(Vector64<float> value);
+        public static Vector64<T> Not<T>(Vector64<T> value) where T : struct;
+        public static Vector128<T> Not<T>(Vector128<T> value) where T : struct;
+        public static Vector64<T> Or<T>(Vector64<T> left, Vector64<T> right) where T : struct;
+        public static Vector128<T> Or<T>(Vector128<T> left, Vector128<T> right) where T : struct;
+        public static Vector64<T> OrNot<T>(Vector64<T> left, Vector64<T> right) where T : struct;
+        public static Vector128<T> OrNot<T>(Vector128<T> left, Vector128<T> right) where T : struct;
+        public static Vector128<byte> PopCount(Vector128<byte> value);
+        public static Vector128<sbyte> PopCount(Vector128<sbyte> value);
+        public static Vector64<byte> PopCount(Vector64<byte> value);
+        public static Vector64<sbyte> PopCount(Vector64<sbyte> value);
+        public static Vector128<T> SetAllVector128<T>(T value) where T : struct;
+        public static Vector64<T> SetAllVector64<T>(T value) where T : struct;
+        public static Vector128<float> Sqrt(Vector128<float> value);
+        public static Vector128<double> Sqrt(Vector128<double> value);
+        public static Vector64<float> Sqrt(Vector64<float> value);
+        public static Vector64<T> Subtract<T>(Vector64<T> left, Vector64<T> right) where T : struct;
+        public static Vector128<T> Subtract<T>(Vector128<T> left, Vector128<T> right) where T : struct;
+        public static Vector64<T> Xor<T>(Vector64<T> left, Vector64<T> right) where T : struct;
+        public static Vector128<T> Xor<T>(Vector128<T> left, Vector128<T> right) where T : struct;
+    }
+}
+namespace System.Runtime.Intrinsics.X86 {
+    public static class Aes {
+        public static bool IsSupported { get; }
+        public static Vector128<byte> Decrypt(Vector128<byte> value, Vector128<byte> roundKey);
+        public static Vector128<sbyte> Decrypt(Vector128<sbyte> value, Vector128<sbyte> roundKey);
+        public static Vector128<byte> DecryptLast(Vector128<byte> value, Vector128<byte> roundKey);
+        public static Vector128<sbyte> DecryptLast(Vector128<sbyte> value, Vector128<sbyte> roundKey);
+        public static Vector128<byte> Encrypt(Vector128<byte> value, Vector128<byte> roundKey);
+        public static Vector128<sbyte> Encrypt(Vector128<sbyte> value, Vector128<sbyte> roundKey);
+        public static Vector128<byte> EncryptLast(Vector128<byte> value, Vector128<byte> roundKey);
+        public static Vector128<sbyte> EncryptLast(Vector128<sbyte> value, Vector128<sbyte> roundKey);
+        public static Vector128<byte> InvisibleMixColumn(Vector128<byte> value);
+        public static Vector128<sbyte> InvisibleMixColumn(Vector128<sbyte> value);
+        public static Vector128<byte> KeygenAssist(Vector128<byte> value, byte control);
+        public static Vector128<sbyte> KeygenAssist(Vector128<sbyte> value, byte control);
+    }
+    public static class Avx {
+        public static bool IsSupported { get; }
+        public static Vector256<float> Add(Vector256<float> left, Vector256<float> right);
+        public static Vector256<double> Add(Vector256<double> left, Vector256<double> right);
+        public static Vector256<float> AddSubtract(Vector256<float> left, Vector256<float> right);
+        public static Vector256<double> AddSubtract(Vector256<double> left, Vector256<double> right);
+        public static Vector256<float> And(Vector256<float> left, Vector256<float> right);
+        public static Vector256<double> And(Vector256<double> left, Vector256<double> right);
+        public static Vector256<float> AndNot(Vector256<float> left, Vector256<float> right);
+        public static Vector256<double> AndNot(Vector256<double> left, Vector256<double> right);
+        public static Vector256<float> Blend(Vector256<float> left, Vector256<float> right, byte control);
+        public static Vector256<double> Blend(Vector256<double> left, Vector256<double> right, byte control);
+        public static Vector256<float> BlendVariable(Vector256<float> left, Vector256<float> right, Vector256<float> mask);
+        public static Vector256<double> BlendVariable(Vector256<double> left, Vector256<double> right, Vector256<double> mask);
+        public unsafe static Vector128<float> BroadcastScalarToVector128(float* source);
+        public unsafe static Vector256<double> BroadcastScalarToVector256(double* source);
+        public unsafe static Vector256<float> BroadcastScalarToVector256(float* source);
+        public unsafe static Vector256<double> BroadcastVector128ToVector256(double* address);
+        public unsafe static Vector256<float> BroadcastVector128ToVector256(float* address);
+        public static Vector256<float> Ceiling(Vector256<float> value);
+        public static Vector256<double> Ceiling(Vector256<double> value);
+        public static Vector128<float> Compare(Vector128<float> left, Vector128<float> right, FloatComparisonMode mode);
+        public static Vector128<double> Compare(Vector128<double> left, Vector128<double> right, FloatComparisonMode mode);
+        public static Vector256<float> Compare(Vector256<float> left, Vector256<float> right, FloatComparisonMode mode);
+        public static Vector256<double> Compare(Vector256<double> left, Vector256<double> right, FloatComparisonMode mode);
+        public static Vector128<double> CompareScalar(Vector128<double> left, Vector128<double> right, FloatComparisonMode mode);
+        public static Vector128<float> CompareScalar(Vector128<float> left, Vector128<float> right, FloatComparisonMode mode);
+        public static float ConvertToSingle(Vector256<float> value);
+        public static Vector128<int> ConvertToVector128Int32(Vector256<double> value);
+        public static Vector128<int> ConvertToVector128Int32WithTruncation(Vector256<double> value);
+        public static Vector128<float> ConvertToVector128Single(Vector256<double> value);
+        public static Vector256<double> ConvertToVector256Double(Vector128<int> value);
+        public static Vector256<double> ConvertToVector256Double(Vector128<float> value);
+        public static Vector256<int> ConvertToVector256Int32(Vector256<float> value);
+        public static Vector256<int> ConvertToVector256Int32WithTruncation(Vector256<float> value);
+        public static Vector256<float> ConvertToVector256Single(Vector256<int> value);
+        public static Vector256<float> Divide(Vector256<float> left, Vector256<float> right);
+        public static Vector256<double> Divide(Vector256<double> left, Vector256<double> right);
+        public static Vector256<float> DotProduct(Vector256<float> left, Vector256<float> right, byte control);
+        public static Vector256<float> DuplicateEvenIndexed(Vector256<float> value);
+        public static Vector256<double> DuplicateEvenIndexed(Vector256<double> value);
+        public static Vector256<float> DuplicateOddIndexed(Vector256<float> value);
+        public static Vector256<T> ExtendToVector256<T>(Vector128<T> value) where T : struct;
+        public static byte Extract(Vector256<byte> value, byte index);
+        public static sbyte Extract(Vector256<sbyte> value, byte index);
+        public static short Extract(Vector256<short> value, byte index);
+        public static int Extract(Vector256<int> value, byte index);
+        public static long Extract(Vector256<long> value, byte index);
+        public static ushort Extract(Vector256<ushort> value, byte index);
+        public static uint Extract(Vector256<uint> value, byte index);
+        public static ulong Extract(Vector256<ulong> value, byte index);
+        public static Vector128<T> ExtractVector128<T>(Vector256<T> value, byte index) where T : struct;
+        public unsafe static void ExtractVector128(byte* address, Vector256<byte> value, byte index);
+        public unsafe static void ExtractVector128(double* address, Vector256<double> value, byte index);
+        public unsafe static void ExtractVector128(short* address, Vector256<short> value, byte index);
+        public unsafe static void ExtractVector128(int* address, Vector256<int> value, byte index);
+        public unsafe static void ExtractVector128(long* address, Vector256<long> value, byte index);
+        public unsafe static void ExtractVector128(sbyte* address, Vector256<sbyte> value, byte index);
+        public unsafe static void ExtractVector128(float* address, Vector256<float> value, byte index);
+        public unsafe static void ExtractVector128(ushort* address, Vector256<ushort> value, byte index);
+        public unsafe static void ExtractVector128(uint* address, Vector256<uint> value, byte index);
+        public unsafe static void ExtractVector128(ulong* address, Vector256<ulong> value, byte index);
+        public static Vector256<float> Floor(Vector256<float> value);
+        public static Vector256<double> Floor(Vector256<double> value);
+        public static Vector128<T> GetLowerHalf<T>(Vector256<T> value) where T : struct;
+        public static Vector256<float> HorizontalAdd(Vector256<float> left, Vector256<float> right);
+        public static Vector256<double> HorizontalAdd(Vector256<double> left, Vector256<double> right);
+        public static Vector256<float> HorizontalSubtract(Vector256<float> left, Vector256<float> right);
+        public static Vector256<double> HorizontalSubtract(Vector256<double> left, Vector256<double> right);
+        public static Vector256<T> Insert<T>(Vector256<T> value, Vector128<T> data, byte index) where T : struct;
+        public static Vector256<byte> Insert(Vector256<byte> value, byte data, byte index);
+        public unsafe static Vector256<byte> Insert(Vector256<byte> value, byte* address, byte index);
+        public static Vector256<sbyte> Insert(Vector256<sbyte> value, sbyte data, byte index);
+        public static Vector256<short> Insert(Vector256<short> value, short data, byte index);
+        public static Vector256<int> Insert(Vector256<int> value, int data, byte index);
+        public static Vector256<long> Insert(Vector256<long> value, long data, byte index);
+        public unsafe static Vector256<sbyte> Insert(Vector256<sbyte> value, sbyte* address, byte index);
+        public unsafe static Vector256<short> Insert(Vector256<short> value, short* address, byte index);
+        public unsafe static Vector256<int> Insert(Vector256<int> value, int* address, byte index);
+        public unsafe static Vector256<long> Insert(Vector256<long> value, long* address, byte index);
+        public static Vector256<ushort> Insert(Vector256<ushort> value, ushort data, byte index);
+        public static Vector256<uint> Insert(Vector256<uint> value, uint data, byte index);
+        public static Vector256<ulong> Insert(Vector256<ulong> value, ulong data, byte index);
+        public unsafe static Vector256<ushort> Insert(Vector256<ushort> value, ushort* address, byte index);
+        public unsafe static Vector256<uint> Insert(Vector256<uint> value, uint* address, byte index);
+        public unsafe static Vector256<ulong> Insert(Vector256<ulong> value, ulong* address, byte index);
+        public unsafe static Vector256<float> Insert(Vector256<float> value, float* address, byte index);
+        public unsafe static Vector256<double> Insert(Vector256<double> value, double* address, byte index);
+        public unsafe static Vector256<byte> LoadAlignedVector256(byte* address);
+        public unsafe static Vector256<double> LoadAlignedVector256(double* address);
+        public unsafe static Vector256<short> LoadAlignedVector256(short* address);
+        public unsafe static Vector256<int> LoadAlignedVector256(int* address);
+        public unsafe static Vector256<long> LoadAlignedVector256(long* address);
+        public unsafe static Vector256<sbyte> LoadAlignedVector256(sbyte* address);
+        public unsafe static Vector256<float> LoadAlignedVector256(float* address);
+        public unsafe static Vector256<ushort> LoadAlignedVector256(ushort* address);
+        public unsafe static Vector256<uint> LoadAlignedVector256(uint* address);
+        public unsafe static Vector256<ulong> LoadAlignedVector256(ulong* address);
+        public unsafe static Vector256<byte> LoadDquVector256(byte* address);
+        public unsafe static Vector256<short> LoadDquVector256(short* address);
+        public unsafe static Vector256<int> LoadDquVector256(int* address);
+        public unsafe static Vector256<long> LoadDquVector256(long* address);
+        public unsafe static Vector256<sbyte> LoadDquVector256(sbyte* address);
+        public unsafe static Vector256<ushort> LoadDquVector256(ushort* address);
+        public unsafe static Vector256<uint> LoadDquVector256(uint* address);
+        public unsafe static Vector256<ulong> LoadDquVector256(ulong* address);
+        public unsafe static Vector256<byte> LoadVector256(byte* address);
+        public unsafe static Vector256<double> LoadVector256(double* address);
+        public unsafe static Vector256<short> LoadVector256(short* address);
+        public unsafe static Vector256<int> LoadVector256(int* address);
+        public unsafe static Vector256<long> LoadVector256(long* address);
+        public unsafe static Vector256<sbyte> LoadVector256(sbyte* address);
+        public unsafe static Vector256<float> LoadVector256(float* address);
+        public unsafe static Vector256<ushort> LoadVector256(ushort* address);
+        public unsafe static Vector256<uint> LoadVector256(uint* address);
+        public unsafe static Vector256<ulong> LoadVector256(ulong* address);
+        public unsafe static Vector128<double> MaskLoad(double* address, Vector128<ulong> mask);
+        public unsafe static Vector256<double> MaskLoad(double* address, Vector256<ulong> mask);
+        public unsafe static Vector128<float> MaskLoad(float* address, Vector128<uint> mask);
+        public unsafe static Vector256<float> MaskLoad(float* address, Vector256<uint> mask);
+        public unsafe static void MaskStore(double* address, Vector128<double> mask, Vector128<ulong> source);
+        public unsafe static void MaskStore(double* address, Vector256<double> mask, Vector256<ulong> source);
+        public unsafe static void MaskStore(float* address, Vector128<float> mask, Vector128<uint> source);
+        public unsafe static void MaskStore(float* address, Vector256<float> mask, Vector256<uint> source);
+        public static Vector256<float> Max(Vector256<float> left, Vector256<float> right);
+        public static Vector256<double> Max(Vector256<double> left, Vector256<double> right);
+        public static Vector256<float> Min(Vector256<float> left, Vector256<float> right);
+        public static Vector256<double> Min(Vector256<double> left, Vector256<double> right);
+        public static int MoveMask(Vector256<float> value);
+        public static int MoveMask(Vector256<double> value);
+        public static Vector256<float> Multiply(Vector256<float> left, Vector256<float> right);
+        public static Vector256<double> Multiply(Vector256<double> left, Vector256<double> right);
+        public static Vector256<float> Or(Vector256<float> left, Vector256<float> right);
+        public static Vector256<double> Or(Vector256<double> left, Vector256<double> right);
+        public static Vector128<float> Permute(Vector128<float> value, byte control);
+        public static Vector128<double> Permute(Vector128<double> value, byte control);
+        public static Vector256<float> Permute(Vector256<float> value, byte control);
+        public static Vector256<double> Permute(Vector256<double> value, byte control);
+        public static Vector256<T> Permute2x128<T>(Vector256<T> left, Vector256<T> right, byte control) where T : struct;
+        public static Vector128<float> PermuteVar(Vector128<float> left, Vector128<float> mask);
+        public static Vector128<double> PermuteVar(Vector128<double> left, Vector128<double> mask);
+        public static Vector256<float> PermuteVar(Vector256<float> left, Vector256<float> mask);
+        public static Vector256<double> PermuteVar(Vector256<double> left, Vector256<double> mask);
+        public static Vector256<float> Reciprocal(Vector256<float> value);
+        public static Vector256<float> ReciprocalSqrt(Vector256<float> value);
+        public static Vector256<float> RoundCurrentDirection(Vector256<float> value);
+        public static Vector256<double> RoundCurrentDirection(Vector256<double> value);
+        public static Vector256<float> RoundToNearestInteger(Vector256<float> value);
+        public static Vector256<double> RoundToNearestInteger(Vector256<double> value);
+        public static Vector256<float> RoundToNegativeInfinity(Vector256<float> value);
+        public static Vector256<double> RoundToNegativeInfinity(Vector256<double> value);
+        public static Vector256<float> RoundToPositiveInfinity(Vector256<float> value);
+        public static Vector256<double> RoundToPositiveInfinity(Vector256<double> value);
+        public static Vector256<float> RoundToZero(Vector256<float> value);
+        public static Vector256<double> RoundToZero(Vector256<double> value);
+        public static Vector256<T> SetAllVector256<T>(T value) where T : struct;
+        public static Vector256<T> SetHighLow<T>(Vector128<T> hi, Vector128<T> lo) where T : struct;
+        public static Vector256<byte> SetVector256(byte e31, byte e30, byte e29, byte e28, byte e27, byte e26, byte e25, byte e24, byte e23, byte e22, byte e21, byte e20, byte e19, byte e18, byte e17, byte e16, byte e15, byte e14, byte e13, byte e12, byte e11, byte e10, byte e9, byte e8, byte e7, byte e6, byte e5, byte e4, byte e3, byte e2, byte e1, byte e0);
+        public static Vector256<double> SetVector256(double e3, double e2, double e1, double e0);
+        public static Vector256<short> SetVector256(short e15, short e14, short e13, short e12, short e11, short e10, short e9, short e8, short e7, short e6, short e5, short e4, short e3, short e2, short e1, short e0);
+        public static Vector256<int> SetVector256(int e7, int e6, int e5, int e4, int e3, int e2, int e1, int e0);
+        public static Vector256<long> SetVector256(long e3, long e2, long e1, long e0);
+        public static Vector256<sbyte> SetVector256(sbyte e31, sbyte e30, sbyte e29, sbyte e28, sbyte e27, sbyte e26, sbyte e25, sbyte e24, sbyte e23, sbyte e22, sbyte e21, sbyte e20, sbyte e19, sbyte e18, sbyte e17, sbyte e16, sbyte e15, sbyte e14, sbyte e13, sbyte e12, sbyte e11, sbyte e10, sbyte e9, sbyte e8, sbyte e7, sbyte e6, sbyte e5, sbyte e4, sbyte e3, sbyte e2, sbyte e1, sbyte e0);
+        public static Vector256<float> SetVector256(float e7, float e6, float e5, float e4, float e3, float e2, float e1, float e0);
+        public static Vector256<ushort> SetVector256(ushort e15, ushort e14, ushort e13, ushort e12, ushort e11, ushort e10, ushort e9, ushort e8, ushort e7, ushort e6, ushort e5, ushort e4, ushort e3, ushort e2, ushort e1, ushort e0);
+        public static Vector256<uint> SetVector256(uint e7, uint e6, uint e5, uint e4, uint e3, uint e2, uint e1, uint e0);
+        public static Vector256<ulong> SetVector256(ulong e3, ulong e2, ulong e1, ulong e0);
+        public static Vector256<T> SetZeroVector256<T>() where T : struct;
+        public static Vector256<float> Shuffle(Vector256<float> value, Vector256<float> right, byte control);
+        public static Vector256<double> Shuffle(Vector256<double> value, Vector256<double> right, byte control);
+        public static Vector256<float> Sqrt(Vector256<float> value);
+        public static Vector256<double> Sqrt(Vector256<double> value);
+        public static Vector256<U> StaticCast<T, U>(Vector256<T> value) where T : struct where U : struct;
+        public unsafe static void Store(byte* address, Vector256<byte> source);
+        public unsafe static void Store(double* address, Vector256<double> source);
+        public unsafe static void Store(short* address, Vector256<short> source);
+        public unsafe static void Store(int* address, Vector256<int> source);
+        public unsafe static void Store(long* address, Vector256<long> source);
+        public unsafe static void Store(sbyte* address, Vector256<sbyte> source);
+        public unsafe static void Store(float* address, Vector256<float> source);
+        public unsafe static void Store(ushort* address, Vector256<ushort> source);
+        public unsafe static void Store(uint* address, Vector256<uint> source);
+        public unsafe static void Store(ulong* address, Vector256<ulong> source);
+        public unsafe static void StoreAligned(byte* address, Vector256<byte> source);
+        public unsafe static void StoreAligned(double* address, Vector256<double> source);
+        public unsafe static void StoreAligned(short* address, Vector256<short> source);
+        public unsafe static void StoreAligned(int* address, Vector256<int> source);
+        public unsafe static void StoreAligned(long* address, Vector256<long> source);
+        public unsafe static void StoreAligned(sbyte* address, Vector256<sbyte> source);
+        public unsafe static void StoreAligned(float* address, Vector256<float> source);
+        public unsafe static void StoreAligned(ushort* address, Vector256<ushort> source);
+        public unsafe static void StoreAligned(uint* address, Vector256<uint> source);
+        public unsafe static void StoreAligned(ulong* address, Vector256<ulong> source);
+        public unsafe static void StoreAlignedNonTemporal(byte* address, Vector256<byte> source);
+        public unsafe static void StoreAlignedNonTemporal(double* address, Vector256<double> source);
+        public unsafe static void StoreAlignedNonTemporal(short* address, Vector256<short> source);
+        public unsafe static void StoreAlignedNonTemporal(int* address, Vector256<int> source);
+        public unsafe static void StoreAlignedNonTemporal(long* address, Vector256<long> source);
+        public unsafe static void StoreAlignedNonTemporal(sbyte* address, Vector256<sbyte> source);
+        public unsafe static void StoreAlignedNonTemporal(float* address, Vector256<float> source);
+        public unsafe static void StoreAlignedNonTemporal(ushort* address, Vector256<ushort> source);
+        public unsafe static void StoreAlignedNonTemporal(uint* address, Vector256<uint> source);
+        public unsafe static void StoreAlignedNonTemporal(ulong* address, Vector256<ulong> source);
+        public static Vector256<float> Subtract(Vector256<float> left, Vector256<float> right);
+        public static Vector256<double> Subtract(Vector256<double> left, Vector256<double> right);
+        public static bool TestC<T>(Vector256<T> left, Vector256<T> right) where T : struct;
+        public static bool TestC(Vector128<float> left, Vector128<float> right);
+        public static bool TestC(Vector128<double> left, Vector128<double> right);
+        public static bool TestNotZAndNotC<T>(Vector256<T> left, Vector256<T> right) where T : struct;
+        public static bool TestNotZAndNotC(Vector128<float> left, Vector128<float> right);
+        public static bool TestNotZAndNotC(Vector128<double> left, Vector128<double> right);
+        public static bool TestZ<T>(Vector256<T> left, Vector256<T> right) where T : struct;
+        public static bool TestZ(Vector128<float> left, Vector128<float> right);
+        public static bool TestZ(Vector128<double> left, Vector128<double> right);
+        public static Vector256<float> UnpackHigh(Vector256<float> left, Vector256<float> right);
+        public static Vector256<double> UnpackHigh(Vector256<double> left, Vector256<double> right);
+        public static Vector256<float> UnpackLow(Vector256<float> left, Vector256<float> right);
+        public static Vector256<double> UnpackLow(Vector256<double> left, Vector256<double> right);
+        public static Vector256<float> Xor(Vector256<float> left, Vector256<float> right);
+        public static Vector256<double> Xor(Vector256<double> left, Vector256<double> right);
+        public static void ZeroAll();
+        public static Vector256<T> ZeroExtendToVector256<T>(Vector128<T> value) where T : struct;
+        public static void ZeroUpper();
+    }
+    public static class Avx2 {
+        public static bool IsSupported { get; }
+        public static Vector256<byte> Abs(Vector256<sbyte> value);
+        public static Vector256<ushort> Abs(Vector256<short> value);
+        public static Vector256<uint> Abs(Vector256<int> value);
+        public static Vector256<byte> Add(Vector256<byte> left, Vector256<byte> right);
+        public static Vector256<sbyte> Add(Vector256<sbyte> left, Vector256<sbyte> right);
+        public static Vector256<short> Add(Vector256<short> left, Vector256<short> right);
+        public static Vector256<int> Add(Vector256<int> left, Vector256<int> right);
+        public static Vector256<long> Add(Vector256<long> left, Vector256<long> right);
+        public static Vector256<ushort> Add(Vector256<ushort> left, Vector256<ushort> right);
+        public static Vector256<uint> Add(Vector256<uint> left, Vector256<uint> right);
+        public static Vector256<ulong> Add(Vector256<ulong> left, Vector256<ulong> right);
+        public static Vector256<byte> AddSaturate(Vector256<byte> left, Vector256<byte> right);
+        public static Vector256<sbyte> AddSaturate(Vector256<sbyte> left, Vector256<sbyte> right);
+        public static Vector256<short> AddSaturate(Vector256<short> left, Vector256<short> right);
+        public static Vector256<ushort> AddSaturate(Vector256<ushort> left, Vector256<ushort> right);
+        public static Vector256<sbyte> AlignRight(Vector256<sbyte> left, Vector256<sbyte> right, byte mask);
+        public static Vector256<byte> And(Vector256<byte> left, Vector256<byte> right);
+        public static Vector256<sbyte> And(Vector256<sbyte> left, Vector256<sbyte> right);
+        public static Vector256<short> And(Vector256<short> left, Vector256<short> right);
+        public static Vector256<int> And(Vector256<int> left, Vector256<int> right);
+        public static Vector256<long> And(Vector256<long> left, Vector256<long> right);
+        public static Vector256<ushort> And(Vector256<ushort> left, Vector256<ushort> right);
+        public static Vector256<uint> And(Vector256<uint> left, Vector256<uint> right);
+        public static Vector256<ulong> And(Vector256<ulong> left, Vector256<ulong> right);
+        public static Vector256<byte> AndNot(Vector256<byte> left, Vector256<byte> right);
+        public static Vector256<sbyte> AndNot(Vector256<sbyte> left, Vector256<sbyte> right);
+        public static Vector256<short> AndNot(Vector256<short> left, Vector256<short> right);
+        public static Vector256<int> AndNot(Vector256<int> left, Vector256<int> right);
+        public static Vector256<long> AndNot(Vector256<long> left, Vector256<long> right);
+        public static Vector256<ushort> AndNot(Vector256<ushort> left, Vector256<ushort> right);
+        public static Vector256<uint> AndNot(Vector256<uint> left, Vector256<uint> right);
+        public static Vector256<ulong> AndNot(Vector256<ulong> left, Vector256<ulong> right);
+        public static Vector256<byte> Average(Vector256<byte> left, Vector256<byte> right);
+        public static Vector256<ushort> Average(Vector256<ushort> left, Vector256<ushort> right);
+        public static Vector128<int> Blend(Vector128<int> left, Vector128<int> right, byte control);
+        public static Vector128<uint> Blend(Vector128<uint> left, Vector128<uint> right, byte control);
+        public static Vector256<short> Blend(Vector256<short> left, Vector256<short> right, byte control);
+        public static Vector256<int> Blend(Vector256<int> left, Vector256<int> right, byte control);
+        public static Vector256<ushort> Blend(Vector256<ushort> left, Vector256<ushort> right, byte control);
+        public static Vector256<uint> Blend(Vector256<uint> left, Vector256<uint> right, byte control);
+        public static Vector256<byte> BlendVariable(Vector256<byte> left, Vector256<byte> right, Vector256<byte> mask);
+        public static Vector256<sbyte> BlendVariable(Vector256<sbyte> left, Vector256<sbyte> right, Vector256<sbyte> mask);
+        public static Vector128<T> BroadcastScalarToVector128<T>(Vector128<T> value) where T : struct;
+        public static Vector256<T> BroadcastScalarToVector256<T>(Vector128<T> value) where T : struct;
+        public unsafe static Vector256<byte> BroadcastVector128ToVector256(byte* address);
+        public unsafe static Vector256<short> BroadcastVector128ToVector256(short* address);
+        public unsafe static Vector256<int> BroadcastVector128ToVector256(int* address);
+        public unsafe static Vector256<long> BroadcastVector128ToVector256(long* address);
+        public unsafe static Vector256<sbyte> BroadcastVector128ToVector256(sbyte* address);
+        public unsafe static Vector256<ushort> BroadcastVector128ToVector256(ushort* address);
+        public unsafe static Vector256<uint> BroadcastVector128ToVector256(uint* address);
+        public unsafe static Vector256<ulong> BroadcastVector128ToVector256(ulong* address);
+        public static Vector256<byte> CompareEqual(Vector256<byte> left, Vector256<byte> right);
+        public static Vector256<sbyte> CompareEqual(Vector256<sbyte> left, Vector256<sbyte> right);
+        public static Vector256<short> CompareEqual(Vector256<short> left, Vector256<short> right);
+        public static Vector256<int> CompareEqual(Vector256<int> left, Vector256<int> right);
+        public static Vector256<long> CompareEqual(Vector256<long> left, Vector256<long> right);
+        public static Vector256<ushort> CompareEqual(Vector256<ushort> left, Vector256<ushort> right);
+        public static Vector256<uint> CompareEqual(Vector256<uint> left, Vector256<uint> right);
+        public static Vector256<ulong> CompareEqual(Vector256<ulong> left, Vector256<ulong> right);
+        public static Vector256<sbyte> CompareGreaterThan(Vector256<sbyte> left, Vector256<sbyte> right);
+        public static Vector256<short> CompareGreaterThan(Vector256<short> left, Vector256<short> right);
+        public static Vector256<int> CompareGreaterThan(Vector256<int> left, Vector256<int> right);
+        public static Vector256<long> CompareGreaterThan(Vector256<long> left, Vector256<long> right);
+        public static double ConvertToDouble(Vector256<double> value);
+        public static int ConvertToInt32(Vector256<int> value);
+        public static uint ConvertToUInt32(Vector256<uint> value);
+        public static Vector256<short> ConvertToVector256Int16(Vector128<sbyte> value);
+        public static Vector256<int> ConvertToVector256Int32(Vector128<sbyte> value);
+        public static Vector256<int> ConvertToVector256Int32(Vector128<short> value);
+        public static Vector256<long> ConvertToVector256Int64(Vector128<sbyte> value);
+        public static Vector256<long> ConvertToVector256Int64(Vector128<short> value);
+        public static Vector256<long> ConvertToVector256Int64(Vector128<int> value);
+        public static Vector256<ushort> ConvertToVector256UInt16(Vector128<byte> value);
+        public static Vector256<uint> ConvertToVector256UInt32(Vector128<byte> value);
+        public static Vector256<uint> ConvertToVector256UInt32(Vector128<ushort> value);
+        public static Vector256<ulong> ConvertToVector256UInt64(Vector128<byte> value);
+        public static Vector256<ulong> ConvertToVector256UInt64(Vector128<ushort> value);
+        public static Vector256<ulong> ConvertToVector256UInt64(Vector128<uint> value);
+        public unsafe static void ExtractVector128(byte* address, Vector256<byte> value, byte index);
+        public unsafe static void ExtractVector128(short* address, Vector256<short> value, byte index);
+        public unsafe static void ExtractVector128(int* address, Vector256<int> value, byte index);
+        public unsafe static void ExtractVector128(long* address, Vector256<long> value, byte index);
+        public unsafe static void ExtractVector128(sbyte* address, Vector256<sbyte> value, byte index);
+        public unsafe static void ExtractVector128(ushort* address, Vector256<ushort> value, byte index);
+        public unsafe static void ExtractVector128(uint* address, Vector256<uint> value, byte index);
+        public unsafe static void ExtractVector128(ulong* address, Vector256<ulong> value, byte index);
+        public static Vector128<byte> ExtractVector128(Vector256<byte> value, byte index);
+        public static Vector128<sbyte> ExtractVector128(Vector256<sbyte> value, byte index);
+        public static Vector128<short> ExtractVector128(Vector256<short> value, byte index);
+        public static Vector128<int> ExtractVector128(Vector256<int> value, byte index);
+        public static Vector128<long> ExtractVector128(Vector256<long> value, byte index);
+        public static Vector128<ushort> ExtractVector128(Vector256<ushort> value, byte index);
+        public static Vector128<uint> ExtractVector128(Vector256<uint> value, byte index);
+        public static Vector128<ulong> ExtractVector128(Vector256<ulong> value, byte index);
+        public unsafe static Vector128<int> GatherMaskVector128(Vector128<int> source, int* baseAddress, Vector128<int> index, Vector128<int> mask, byte scale);
+        public unsafe static Vector128<long> GatherMaskVector128(Vector128<long> source, long* baseAddress, Vector128<int> index, Vector128<long> mask, byte scale);
+        public unsafe static Vector128<int> GatherMaskVector128(Vector128<int> source, int* baseAddress, Vector128<long> index, Vector128<int> mask, byte scale);
+        public unsafe static Vector128<long> GatherMaskVector128(Vector128<long> source, long* baseAddress, Vector128<long> index, Vector128<long> mask, byte scale);
+        public unsafe static Vector128<int> GatherMaskVector128(Vector128<int> source, int* baseAddress, Vector256<long> index, Vector128<int> mask, byte scale);
+        public unsafe static Vector128<uint> GatherMaskVector128(Vector128<uint> source, uint* baseAddress, Vector128<int> index, Vector128<uint> mask, byte scale);
+        public unsafe static Vector128<ulong> GatherMaskVector128(Vector128<ulong> source, ulong* baseAddress, Vector128<int> index, Vector128<ulong> mask, byte scale);
+        public unsafe static Vector128<float> GatherMaskVector128(Vector128<float> source, float* baseAddress, Vector128<int> index, Vector128<float> mask, byte scale);
+        public unsafe static Vector128<double> GatherMaskVector128(Vector128<double> source, double* baseAddress, Vector128<int> index, Vector128<double> mask, byte scale);
+        public unsafe static Vector128<uint> GatherMaskVector128(Vector128<uint> source, uint* baseAddress, Vector128<long> index, Vector128<uint> mask, byte scale);
+        public unsafe static Vector128<ulong> GatherMaskVector128(Vector128<ulong> source, ulong* baseAddress, Vector128<long> index, Vector128<ulong> mask, byte scale);
+        public unsafe static Vector128<float> GatherMaskVector128(Vector128<float> source, float* baseAddress, Vector128<long> index, Vector128<float> mask, byte scale);
+        public unsafe static Vector128<double> GatherMaskVector128(Vector128<double> source, double* baseAddress, Vector128<long> index, Vector128<double> mask, byte scale);
+        public unsafe static Vector128<uint> GatherMaskVector128(Vector128<uint> source, uint* baseAddress, Vector256<long> index, Vector128<uint> mask, byte scale);
+        public unsafe static Vector128<float> GatherMaskVector128(Vector128<float> source, float* baseAddress, Vector256<long> index, Vector128<float> mask, byte scale);
+        public unsafe static Vector256<int> GatherMaskVector256(Vector256<int> source, int* baseAddress, Vector256<int> index, Vector256<int> mask, byte scale);
+        public unsafe static Vector256<long> GatherMaskVector256(Vector256<long> source, long* baseAddress, Vector128<int> index, Vector256<long> mask, byte scale);
+        public unsafe static Vector256<long> GatherMaskVector256(Vector256<long> source, long* baseAddress, Vector256<long> index, Vector256<long> mask, byte scale);
+        public unsafe static Vector256<uint> GatherMaskVector256(Vector256<uint> source, uint* baseAddress, Vector256<int> index, Vector256<uint> mask, byte scale);
+        public unsafe static Vector256<ulong> GatherMaskVector256(Vector256<ulong> source, ulong* baseAddress, Vector128<int> index, Vector256<ulong> mask, byte scale);
+        public unsafe static Vector256<float> GatherMaskVector256(Vector256<float> source, float* baseAddress, Vector256<int> index, Vector256<float> mask, byte scale);
+        public unsafe static Vector256<double> GatherMaskVector256(Vector256<double> source, double* baseAddress, Vector128<int> index, Vector256<double> mask, byte scale);
+        public unsafe static Vector256<ulong> GatherMaskVector256(Vector256<ulong> source, ulong* baseAddress, Vector256<long> index, Vector256<ulong> mask, byte scale);
+        public unsafe static Vector256<double> GatherMaskVector256(Vector256<double> source, double* baseAddress, Vector256<long> index, Vector256<double> mask, byte scale);
+        public unsafe static Vector128<double> GatherVector128(double* baseAddress, Vector128<int> index, byte scale);
+        public unsafe static Vector128<double> GatherVector128(double* baseAddress, Vector128<long> index, byte scale);
+        public unsafe static Vector128<int> GatherVector128(int* baseAddress, Vector128<int> index, byte scale);
+        public unsafe static Vector128<int> GatherVector128(int* baseAddress, Vector128<long> index, byte scale);
+        public unsafe static Vector128<int> GatherVector128(int* baseAddress, Vector256<long> index, byte scale);
+        public unsafe static Vector128<long> GatherVector128(long* baseAddress, Vector128<int> index, byte scale);
+        public unsafe static Vector128<long> GatherVector128(long* baseAddress, Vector128<long> index, byte scale);
+        public unsafe static Vector128<float> GatherVector128(float* baseAddress, Vector128<int> index, byte scale);
+        public unsafe static Vector128<float> GatherVector128(float* baseAddress, Vector128<long> index, byte scale);
+        public unsafe static Vector128<float> GatherVector128(float* baseAddress, Vector256<long> index, byte scale);
+        public unsafe static Vector128<uint> GatherVector128(uint* baseAddress, Vector128<int> index, byte scale);
+        public unsafe static Vector128<uint> GatherVector128(uint* baseAddress, Vector128<long> index, byte scale);
+        public unsafe static Vector128<uint> GatherVector128(uint* baseAddress, Vector256<long> index, byte scale);
+        public unsafe static Vector128<ulong> GatherVector128(ulong* baseAddress, Vector128<int> index, byte scale);
+        public unsafe static Vector128<ulong> GatherVector128(ulong* baseAddress, Vector128<long> index, byte scale);
+        public unsafe static Vector256<double> GatherVector256(double* baseAddress, Vector128<int> index, byte scale);
+        public unsafe static Vector256<double> GatherVector256(double* baseAddress, Vector256<long> index, byte scale);
+        public unsafe static Vector256<int> GatherVector256(int* baseAddress, Vector256<int> index, byte scale);
+        public unsafe static Vector256<long> GatherVector256(long* baseAddress, Vector128<int> index, byte scale);
+        public unsafe static Vector256<long> GatherVector256(long* baseAddress, Vector256<long> index, byte scale);
+        public unsafe static Vector256<float> GatherVector256(float* baseAddress, Vector256<int> index, byte scale);
+        public unsafe static Vector256<uint> GatherVector256(uint* baseAddress, Vector256<int> index, byte scale);
+        public unsafe static Vector256<ulong> GatherVector256(ulong* baseAddress, Vector128<int> index, byte scale);
+        public unsafe static Vector256<ulong> GatherVector256(ulong* baseAddress, Vector256<long> index, byte scale);
+        public static Vector256<short> HorizontalAdd(Vector256<short> left, Vector256<short> right);
+        public static Vector256<int> HorizontalAdd(Vector256<int> left, Vector256<int> right);
+        public static Vector256<short> HorizontalAddSaturate(Vector256<short> left, Vector256<short> right);
+        public static Vector256<short> HorizontalSubtract(Vector256<short> left, Vector256<short> right);
+        public static Vector256<int> HorizontalSubtract(Vector256<int> left, Vector256<int> right);
+        public static Vector256<short> HorizontalSubtractSaturate(Vector256<short> left, Vector256<short> right);
+        public unsafe static Vector256<byte> Insert(Vector256<byte> value, byte* address, byte index);
+        public unsafe static Vector256<sbyte> Insert(Vector256<sbyte> value, sbyte* address, byte index);
+        public unsafe static Vector256<short> Insert(Vector256<short> value, short* address, byte index);
+        public unsafe static Vector256<int> Insert(Vector256<int> value, int* address, byte index);
+        public unsafe static Vector256<long> Insert(Vector256<long> value, long* address, byte index);
+        public unsafe static Vector256<ushort> Insert(Vector256<ushort> value, ushort* address, byte index);
+        public unsafe static Vector256<uint> Insert(Vector256<uint> value, uint* address, byte index);
+        public unsafe static Vector256<ulong> Insert(Vector256<ulong> value, ulong* address, byte index);
+        public static Vector256<byte> Insert(Vector256<byte> value, Vector128<byte> data, byte index);
+        public static Vector256<sbyte> Insert(Vector256<sbyte> value, Vector128<sbyte> data, byte index);
+        public static Vector256<short> Insert(Vector256<short> value, Vector128<short> data, byte index);
+        public static Vector256<int> Insert(Vector256<int> value, Vector128<int> data, byte index);
+        public static Vector256<long> Insert(Vector256<long> value, Vector128<long> data, byte index);
+        public static Vector256<ushort> Insert(Vector256<ushort> value, Vector128<ushort> data, byte index);
+        public static Vector256<uint> Insert(Vector256<uint> value, Vector128<uint> data, byte index);
+        public static Vector256<ulong> Insert(Vector256<ulong> value, Vector128<ulong> data, byte index);
+        public unsafe static Vector256<byte> LoadAlignedVector256NonTemporal(byte* address);
+        public unsafe static Vector256<short> LoadAlignedVector256NonTemporal(short* address);
+        public unsafe static Vector256<int> LoadAlignedVector256NonTemporal(int* address);
+        public unsafe static Vector256<long> LoadAlignedVector256NonTemporal(long* address);
+        public unsafe static Vector256<sbyte> LoadAlignedVector256NonTemporal(sbyte* address);
+        public unsafe static Vector256<ushort> LoadAlignedVector256NonTemporal(ushort* address);
+        public unsafe static Vector256<uint> LoadAlignedVector256NonTemporal(uint* address);
+        public unsafe static Vector256<ulong> LoadAlignedVector256NonTemporal(ulong* address);
+        public unsafe static Vector128<int> MaskLoad(int* address, Vector128<int> mask);
+        public unsafe static Vector256<int> MaskLoad(int* address, Vector256<int> mask);
+        public unsafe static Vector128<long> MaskLoad(long* address, Vector128<long> mask);
+        public unsafe static Vector256<long> MaskLoad(long* address, Vector256<long> mask);
+        public unsafe static Vector128<uint> MaskLoad(uint* address, Vector128<uint> mask);
+        public unsafe static Vector256<uint> MaskLoad(uint* address, Vector256<uint> mask);
+        public unsafe static Vector128<ulong> MaskLoad(ulong* address, Vector128<ulong> mask);
+        public unsafe static Vector256<ulong> MaskLoad(ulong* address, Vector256<ulong> mask);
+        public unsafe static void MaskStore(int* address, Vector128<int> mask, Vector128<int> source);
+        public unsafe static void MaskStore(int* address, Vector256<int> mask, Vector256<int> source);
+        public unsafe static void MaskStore(long* address, Vector128<long> mask, Vector128<long> source);
+        public unsafe static void MaskStore(long* address, Vector256<long> mask, Vector256<long> source);
+        public unsafe static void MaskStore(uint* address, Vector128<uint> mask, Vector128<uint> source);
+        public unsafe static void MaskStore(uint* address, Vector256<uint> mask, Vector256<uint> source);
+        public unsafe static void MaskStore(ulong* address, Vector128<ulong> mask, Vector128<ulong> source);
+        public unsafe static void MaskStore(ulong* address, Vector256<ulong> mask, Vector256<ulong> source);
+        public static Vector256<byte> Max(Vector256<byte> left, Vector256<byte> right);
+        public static Vector256<sbyte> Max(Vector256<sbyte> left, Vector256<sbyte> right);
+        public static Vector256<short> Max(Vector256<short> left, Vector256<short> right);
+        public static Vector256<int> Max(Vector256<int> left, Vector256<int> right);
+        public static Vector256<ushort> Max(Vector256<ushort> left, Vector256<ushort> right);
+        public static Vector256<uint> Max(Vector256<uint> left, Vector256<uint> right);
+        public static Vector256<byte> Min(Vector256<byte> left, Vector256<byte> right);
+        public static Vector256<sbyte> Min(Vector256<sbyte> left, Vector256<sbyte> right);
+        public static Vector256<short> Min(Vector256<short> left, Vector256<short> right);
+        public static Vector256<int> Min(Vector256<int> left, Vector256<int> right);
+        public static Vector256<ushort> Min(Vector256<ushort> left, Vector256<ushort> right);
+        public static Vector256<uint> Min(Vector256<uint> left, Vector256<uint> right);
+        public static int MoveMask(Vector256<byte> value);
+        public static int MoveMask(Vector256<sbyte> value);
+        public static Vector256<ushort> MultipleSumAbsoluteDifferences(Vector256<byte> left, Vector256<byte> right, byte mask);
+        public static Vector256<long> Multiply(Vector256<int> left, Vector256<int> right);
+        public static Vector256<ulong> Multiply(Vector256<uint> left, Vector256<uint> right);
+        public static Vector256<short> MultiplyAddAdjacent(Vector256<byte> left, Vector256<sbyte> right);
+        public static Vector256<int> MultiplyAddAdjacent(Vector256<short> left, Vector256<short> right);
+        public static Vector256<short> MultiplyHigh(Vector256<short> left, Vector256<short> right);
+        public static Vector256<ushort> MultiplyHigh(Vector256<ushort> left, Vector256<ushort> right);
+        public static Vector256<short> MultiplyHighRoundScale(Vector256<short> left, Vector256<short> right);
+        public static Vector256<short> MultiplyLow(Vector256<short> left, Vector256<short> right);
+        public static Vector256<int> MultiplyLow(Vector256<int> left, Vector256<int> right);
+        public static Vector256<byte> Or(Vector256<byte> left, Vector256<byte> right);
+        public static Vector256<sbyte> Or(Vector256<sbyte> left, Vector256<sbyte> right);
+        public static Vector256<short> Or(Vector256<short> left, Vector256<short> right);
+        public static Vector256<int> Or(Vector256<int> left, Vector256<int> right);
+        public static Vector256<long> Or(Vector256<long> left, Vector256<long> right);
+        public static Vector256<ushort> Or(Vector256<ushort> left, Vector256<ushort> right);
+        public static Vector256<uint> Or(Vector256<uint> left, Vector256<uint> right);
+        public static Vector256<ulong> Or(Vector256<ulong> left, Vector256<ulong> right);
+        public static Vector256<sbyte> PackSignedSaturate(Vector256<short> left, Vector256<short> right);
+        public static Vector256<short> PackSignedSaturate(Vector256<int> left, Vector256<int> right);
+        public static Vector256<byte> PackUnsignedSaturate(Vector256<short> left, Vector256<short> right);
+        public static Vector256<ushort> PackUnsignedSaturate(Vector256<int> left, Vector256<int> right);
+        public static Vector256<byte> Permute2x128(Vector256<byte> left, Vector256<byte> right, byte control);
+        public static Vector256<sbyte> Permute2x128(Vector256<sbyte> left, Vector256<sbyte> right, byte control);
+        public static Vector256<short> Permute2x128(Vector256<short> left, Vector256<short> right, byte control);
+        public static Vector256<int> Permute2x128(Vector256<int> left, Vector256<int> right, byte control);
+        public static Vector256<long> Permute2x128(Vector256<long> left, Vector256<long> right, byte control);
+        public static Vector256<ushort> Permute2x128(Vector256<ushort> left, Vector256<ushort> right, byte control);
+        public static Vector256<uint> Permute2x128(Vector256<uint> left, Vector256<uint> right, byte control);
+        public static Vector256<ulong> Permute2x128(Vector256<ulong> left, Vector256<ulong> right, byte control);
+        public static Vector256<long> Permute4x64(Vector256<long> value, byte control);
+        public static Vector256<ulong> Permute4x64(Vector256<ulong> value, byte control);
+        public static Vector256<double> Permute4x64(Vector256<double> value, byte control);
+        public static Vector256<int> PermuteVar8x32(Vector256<int> left, Vector256<int> mask);
+        public static Vector256<uint> PermuteVar8x32(Vector256<uint> left, Vector256<uint> mask);
+        public static Vector256<float> PermuteVar8x32(Vector256<float> left, Vector256<float> mask);
+        public static Vector256<short> ShiftLeftLogical(Vector256<short> value, byte count);
+        public static Vector256<int> ShiftLeftLogical(Vector256<int> value, byte count);
+        public static Vector256<long> ShiftLeftLogical(Vector256<long> value, byte count);
+        public static Vector256<ushort> ShiftLeftLogical(Vector256<ushort> value, byte count);
+        public static Vector256<uint> ShiftLeftLogical(Vector256<uint> value, byte count);
+        public static Vector256<ulong> ShiftLeftLogical(Vector256<ulong> value, byte count);
+        public static Vector256<short> ShiftLeftLogical(Vector256<short> value, Vector128<short> count);
+        public static Vector256<int> ShiftLeftLogical(Vector256<int> value, Vector128<int> count);
+        public static Vector256<long> ShiftLeftLogical(Vector256<long> value, Vector128<long> count);
+        public static Vector256<ushort> ShiftLeftLogical(Vector256<ushort> value, Vector128<ushort> count);
+        public static Vector256<uint> ShiftLeftLogical(Vector256<uint> value, Vector128<uint> count);
+        public static Vector256<ulong> ShiftLeftLogical(Vector256<ulong> value, Vector128<ulong> count);
+        public static Vector256<byte> ShiftLeftLogical128BitLane(Vector256<byte> value, byte numBytes);
+        public static Vector256<sbyte> ShiftLeftLogical128BitLane(Vector256<sbyte> value, byte numBytes);
+        public static Vector256<short> ShiftLeftLogical128BitLane(Vector256<short> value, byte numBytes);
+        public static Vector256<int> ShiftLeftLogical128BitLane(Vector256<int> value, byte numBytes);
+        public static Vector256<long> ShiftLeftLogical128BitLane(Vector256<long> value, byte numBytes);
+        public static Vector256<ushort> ShiftLeftLogical128BitLane(Vector256<ushort> value, byte numBytes);
+        public static Vector256<uint> ShiftLeftLogical128BitLane(Vector256<uint> value, byte numBytes);
+        public static Vector256<ulong> ShiftLeftLogical128BitLane(Vector256<ulong> value, byte numBytes);
+        public static Vector128<int> ShiftLeftLogicalVariable(Vector128<int> value, Vector128<uint> count);
+        public static Vector128<long> ShiftLeftLogicalVariable(Vector128<long> value, Vector128<ulong> count);
+        public static Vector128<uint> ShiftLeftLogicalVariable(Vector128<uint> value, Vector128<uint> count);
+        public static Vector128<ulong> ShiftLeftLogicalVariable(Vector128<ulong> value, Vector128<ulong> count);
+        public static Vector256<int> ShiftLeftLogicalVariable(Vector256<int> value, Vector256<uint> count);
+        public static Vector256<long> ShiftLeftLogicalVariable(Vector256<long> value, Vector256<ulong> count);
+        public static Vector256<uint> ShiftLeftLogicalVariable(Vector256<uint> value, Vector256<uint> count);
+        public static Vector256<ulong> ShiftLeftLogicalVariable(Vector256<ulong> value, Vector256<ulong> count);
+        public static Vector256<short> ShiftRightArithmetic(Vector256<short> value, byte count);
+        public static Vector256<int> ShiftRightArithmetic(Vector256<int> value, byte count);
+        public static Vector256<short> ShiftRightArithmetic(Vector256<short> value, Vector128<short> count);
+        public static Vector256<int> ShiftRightArithmetic(Vector256<int> value, Vector128<int> count);
+        public static Vector128<int> ShiftRightArithmeticVariable(Vector128<int> value, Vector128<uint> count);
+        public static Vector256<int> ShiftRightArithmeticVariable(Vector256<int> value, Vector256<uint> count);
+        public static Vector256<short> ShiftRightLogical(Vector256<short> value, byte count);
+        public static Vector256<int> ShiftRightLogical(Vector256<int> value, byte count);
+        public static Vector256<long> ShiftRightLogical(Vector256<long> value, byte count);
+        public static Vector256<ushort> ShiftRightLogical(Vector256<ushort> value, byte count);
+        public static Vector256<uint> ShiftRightLogical(Vector256<uint> value, byte count);
+        public static Vector256<ulong> ShiftRightLogical(Vector256<ulong> value, byte count);
+        public static Vector256<short> ShiftRightLogical(Vector256<short> value, Vector128<short> count);
+        public static Vector256<int> ShiftRightLogical(Vector256<int> value, Vector128<int> count);
+        public static Vector256<long> ShiftRightLogical(Vector256<long> value, Vector128<long> count);
+        public static Vector256<ushort> ShiftRightLogical(Vector256<ushort> value, Vector128<ushort> count);
+        public static Vector256<uint> ShiftRightLogical(Vector256<uint> value, Vector128<uint> count);
+        public static Vector256<ulong> ShiftRightLogical(Vector256<ulong> value, Vector128<ulong> count);
+        public static Vector256<byte> ShiftRightLogical128BitLane(Vector256<byte> value, byte numBytes);
+        public static Vector256<sbyte> ShiftRightLogical128BitLane(Vector256<sbyte> value, byte numBytes);
+        public static Vector256<short> ShiftRightLogical128BitLane(Vector256<short> value, byte numBytes);
+        public static Vector256<int> ShiftRightLogical128BitLane(Vector256<int> value, byte numBytes);
+        public static Vector256<long> ShiftRightLogical128BitLane(Vector256<long> value, byte numBytes);
+        public static Vector256<ushort> ShiftRightLogical128BitLane(Vector256<ushort> value, byte numBytes);
+        public static Vector256<uint> ShiftRightLogical128BitLane(Vector256<uint> value, byte numBytes);
+        public static Vector256<ulong> ShiftRightLogical128BitLane(Vector256<ulong> value, byte numBytes);
+        public static Vector128<int> ShiftRightLogicalVariable(Vector128<int> value, Vector128<uint> count);
+        public static Vector128<long> ShiftRightLogicalVariable(Vector128<long> value, Vector128<ulong> count);
+        public static Vector128<uint> ShiftRightLogicalVariable(Vector128<uint> value, Vector128<uint> count);
+        public static Vector128<ulong> ShiftRightLogicalVariable(Vector128<ulong> value, Vector128<ulong> count);
+        public static Vector256<int> ShiftRightLogicalVariable(Vector256<int> value, Vector256<uint> count);
+        public static Vector256<long> ShiftRightLogicalVariable(Vector256<long> value, Vector256<ulong> count);
+        public static Vector256<uint> ShiftRightLogicalVariable(Vector256<uint> value, Vector256<uint> count);
+        public static Vector256<ulong> ShiftRightLogicalVariable(Vector256<ulong> value, Vector256<ulong> count);
+        public static Vector256<int> Shuffle(Vector256<int> value, byte control);
+        public static Vector256<uint> Shuffle(Vector256<uint> value, byte control);
+        public static Vector256<byte> Shuffle(Vector256<byte> value, Vector256<byte> mask);
+        public static Vector256<sbyte> Shuffle(Vector256<sbyte> value, Vector256<sbyte> mask);
+        public static Vector256<short> ShuffleHigh(Vector256<short> value, byte control);
+        public static Vector256<ushort> ShuffleHigh(Vector256<ushort> value, byte control);
+        public static Vector256<short> ShuffleLow(Vector256<short> value, byte control);
+        public static Vector256<ushort> ShuffleLow(Vector256<ushort> value, byte control);
+        public static Vector256<sbyte> Sign(Vector256<sbyte> left, Vector256<sbyte> right);
+        public static Vector256<short> Sign(Vector256<short> left, Vector256<short> right);
+        public static Vector256<int> Sign(Vector256<int> left, Vector256<int> right);
+        public static Vector256<byte> Subtract(Vector256<byte> left, Vector256<byte> right);
+        public static Vector256<sbyte> Subtract(Vector256<sbyte> left, Vector256<sbyte> right);
+        public static Vector256<short> Subtract(Vector256<short> left, Vector256<short> right);
+        public static Vector256<int> Subtract(Vector256<int> left, Vector256<int> right);
+        public static Vector256<long> Subtract(Vector256<long> left, Vector256<long> right);
+        public static Vector256<ushort> Subtract(Vector256<ushort> left, Vector256<ushort> right);
+        public static Vector256<uint> Subtract(Vector256<uint> left, Vector256<uint> right);
+        public static Vector256<ulong> Subtract(Vector256<ulong> left, Vector256<ulong> right);
+        public static Vector256<byte> SubtractSaturate(Vector256<byte> left, Vector256<byte> right);
+        public static Vector256<sbyte> SubtractSaturate(Vector256<sbyte> left, Vector256<sbyte> right);
+        public static Vector256<short> SubtractSaturate(Vector256<short> left, Vector256<short> right);
+        public static Vector256<ushort> SubtractSaturate(Vector256<ushort> left, Vector256<ushort> right);
+        public static Vector256<ulong> SumAbsoluteDifferences(Vector256<byte> left, Vector256<byte> right);
+        public static Vector256<byte> UnpackHigh(Vector256<byte> left, Vector256<byte> right);
+        public static Vector256<sbyte> UnpackHigh(Vector256<sbyte> left, Vector256<sbyte> right);
+        public static Vector256<short> UnpackHigh(Vector256<short> left, Vector256<short> right);
+        public static Vector256<int> UnpackHigh(Vector256<int> left, Vector256<int> right);
+        public static Vector256<long> UnpackHigh(Vector256<long> left, Vector256<long> right);
+        public static Vector256<ushort> UnpackHigh(Vector256<ushort> left, Vector256<ushort> right);
+        public static Vector256<uint> UnpackHigh(Vector256<uint> left, Vector256<uint> right);
+        public static Vector256<ulong> UnpackHigh(Vector256<ulong> left, Vector256<ulong> right);
+        public static Vector256<byte> UnpackLow(Vector256<byte> left, Vector256<byte> right);
+        public static Vector256<sbyte> UnpackLow(Vector256<sbyte> left, Vector256<sbyte> right);
+        public static Vector256<short> UnpackLow(Vector256<short> left, Vector256<short> right);
+        public static Vector256<int> UnpackLow(Vector256<int> left, Vector256<int> right);
+        public static Vector256<long> UnpackLow(Vector256<long> left, Vector256<long> right);
+        public static Vector256<ushort> UnpackLow(Vector256<ushort> left, Vector256<ushort> right);
+        public static Vector256<uint> UnpackLow(Vector256<uint> left, Vector256<uint> right);
+        public static Vector256<ulong> UnpackLow(Vector256<ulong> left, Vector256<ulong> right);
+        public static Vector256<byte> Xor(Vector256<byte> left, Vector256<byte> right);
+        public static Vector256<sbyte> Xor(Vector256<sbyte> left, Vector256<sbyte> right);
+        public static Vector256<short> Xor(Vector256<short> left, Vector256<short> right);
+        public static Vector256<int> Xor(Vector256<int> left, Vector256<int> right);
+        public static Vector256<long> Xor(Vector256<long> left, Vector256<long> right);
+        public static Vector256<ushort> Xor(Vector256<ushort> left, Vector256<ushort> right);
+        public static Vector256<uint> Xor(Vector256<uint> left, Vector256<uint> right);
+        public static Vector256<ulong> Xor(Vector256<ulong> left, Vector256<ulong> right);
+    }
+    public static class Bmi1 {
+        public static bool IsSupported { get; }
+        public static uint AndNot(uint left, uint right);
+        public static ulong AndNot(ulong left, ulong right);
+        public static uint BitFieldExtract(uint value, uint control);
+        public static uint BitFieldExtract(uint value, uint start, uint length);
+        public static ulong BitFieldExtract(ulong value, ulong control);
+        public static ulong BitFieldExtract(ulong value, ulong start, ulong length);
+        public static uint ExtractLowestSetBit(uint value);
+        public static ulong ExtractLowestSetBit(ulong value);
+        public static uint GetMaskUptoLowestSetBit(uint value);
+        public static ulong GetMaskUptoLowestSetBit(ulong value);
+        public static uint ResetLowestSetBit(uint value);
+        public static ulong ResetLowestSetBit(ulong value);
+        public static uint TrailingZeroCount(uint value);
+        public static ulong TrailingZeroCount(ulong value);
+    }
+    public static class Bmi2 {
+        public static bool IsSupported { get; }
+        public unsafe static uint MultiplyNoFlags(uint left, uint right, uint* high);
+        public unsafe static ulong MultiplyNoFlags(ulong left, ulong right, ulong* high);
+        public static uint ParallelBitDeposit(uint value, uint mask);
+        public static ulong ParallelBitDeposit(ulong value, ulong mask);
+        public static uint ParallelBitExtract(uint value, uint mask);
+        public static ulong ParallelBitExtract(ulong value, ulong mask);
+        public static uint ZeroHighBits(uint value, uint index);
+        public static ulong ZeroHighBits(ulong value, ulong index);
+    }
+    public enum FloatComparisonMode : byte {
+        EqualOrderedNonSignaling = (byte)0,
+        EqualOrderedSignaling = (byte)16,
+        EqualUnorderedNonSignaling = (byte)8,
+        EqualUnorderedSignaling = (byte)24,
+        FalseOrderedNonSignaling = (byte)11,
+        FalseOrderedSignaling = (byte)27,
+        GreaterThanOrderedNonSignaling = (byte)30,
+        GreaterThanOrderedSignaling = (byte)14,
+        GreaterThanOrEqualOrderedNonSignaling = (byte)29,
+        GreaterThanOrEqualOrderedSignaling = (byte)13,
+        LessThanOrderedNonSignaling = (byte)17,
+        LessThanOrderedSignaling = (byte)1,
+        LessThanOrEqualOrderedNonSignaling = (byte)18,
+        LessThanOrEqualOrderedSignaling = (byte)2,
+        NotEqualOrderedNonSignaling = (byte)12,
+        NotEqualOrderedSignaling = (byte)28,
+        NotEqualUnorderedNonSignaling = (byte)4,
+        NotEqualUnorderedSignaling = (byte)20,
+        NotGreaterThanOrEqualUnorderedNonSignaling = (byte)25,
+        NotGreaterThanOrEqualUnorderedSignaling = (byte)9,
+        NotGreaterThanUnorderedNonSignaling = (byte)26,
+        NotGreaterThanUnorderedSignaling = (byte)10,
+        NotLessThanOrEqualUnorderedNonSignaling = (byte)22,
+        NotLessThanOrEqualUnorderedSignaling = (byte)6,
+        NotLessThanUnorderedNonSignaling = (byte)21,
+        NotLessThanUnorderedSignaling = (byte)5,
+        OrderedNonSignaling = (byte)7,
+        OrderedSignaling = (byte)23,
+        TrueUnorderedNonSignaling = (byte)15,
+        TrueUnorderedSignaling = (byte)31,
+        UnorderedNonSignaling = (byte)3,
+        UnorderedSignaling = (byte)19,
+    }
+    public static class Fma {
+        public static bool IsSupported { get; }
+        public static Vector128<float> MultiplyAdd(Vector128<float> a, Vector128<float> b, Vector128<float> c);
+        public static Vector128<double> MultiplyAdd(Vector128<double> a, Vector128<double> b, Vector128<double> c);
+        public static Vector256<float> MultiplyAdd(Vector256<float> a, Vector256<float> b, Vector256<float> c);
+        public static Vector256<double> MultiplyAdd(Vector256<double> a, Vector256<double> b, Vector256<double> c);
+        public static Vector128<float> MultiplyAddNegated(Vector128<float> a, Vector128<float> b, Vector128<float> c);
+        public static Vector128<double> MultiplyAddNegated(Vector128<double> a, Vector128<double> b, Vector128<double> c);
+        public static Vector256<float> MultiplyAddNegated(Vector256<float> a, Vector256<float> b, Vector256<float> c);
+        public static Vector256<double> MultiplyAddNegated(Vector256<double> a, Vector256<double> b, Vector256<double> c);
+        public static Vector128<float> MultiplyAddNegatedScalar(Vector128<float> a, Vector128<float> b, Vector128<float> c);
+        public static Vector128<double> MultiplyAddNegatedScalar(Vector128<double> a, Vector128<double> b, Vector128<double> c);
+        public static Vector128<float> MultiplyAddScalar(Vector128<float> a, Vector128<float> b, Vector128<float> c);
+        public static Vector128<double> MultiplyAddScalar(Vector128<double> a, Vector128<double> b, Vector128<double> c);
+        public static Vector128<float> MultiplyAddSubtract(Vector128<float> a, Vector128<float> b, Vector128<float> c);
+        public static Vector128<double> MultiplyAddSubtract(Vector128<double> a, Vector128<double> b, Vector128<double> c);
+        public static Vector256<float> MultiplyAddSubtract(Vector256<float> a, Vector256<float> b, Vector256<float> c);
+        public static Vector256<double> MultiplyAddSubtract(Vector256<double> a, Vector256<double> b, Vector256<double> c);
+        public static Vector128<float> MultiplySubtract(Vector128<float> a, Vector128<float> b, Vector128<float> c);
+        public static Vector128<double> MultiplySubtract(Vector128<double> a, Vector128<double> b, Vector128<double> c);
+        public static Vector256<float> MultiplySubtract(Vector256<float> a, Vector256<float> b, Vector256<float> c);
+        public static Vector256<double> MultiplySubtract(Vector256<double> a, Vector256<double> b, Vector256<double> c);
+        public static Vector128<float> MultiplySubtractAdd(Vector128<float> a, Vector128<float> b, Vector128<float> c);
+        public static Vector128<double> MultiplySubtractAdd(Vector128<double> a, Vector128<double> b, Vector128<double> c);
+        public static Vector256<float> MultiplySubtractAdd(Vector256<float> a, Vector256<float> b, Vector256<float> c);
+        public static Vector256<double> MultiplySubtractAdd(Vector256<double> a, Vector256<double> b, Vector256<double> c);
+        public static Vector128<float> MultiplySubtractNegated(Vector128<float> a, Vector128<float> b, Vector128<float> c);
+        public static Vector128<double> MultiplySubtractNegated(Vector128<double> a, Vector128<double> b, Vector128<double> c);
+        public static Vector256<float> MultiplySubtractNegated(Vector256<float> a, Vector256<float> b, Vector256<float> c);
+        public static Vector256<double> MultiplySubtractNegated(Vector256<double> a, Vector256<double> b, Vector256<double> c);
+        public static Vector128<float> MultiplySubtractNegatedScalar(Vector128<float> a, Vector128<float> b, Vector128<float> c);
+        public static Vector128<double> MultiplySubtractNegatedScalar(Vector128<double> a, Vector128<double> b, Vector128<double> c);
+        public static Vector128<float> MultiplySubtractScalar(Vector128<float> a, Vector128<float> b, Vector128<float> c);
+        public static Vector128<double> MultiplySubtractScalar(Vector128<double> a, Vector128<double> b, Vector128<double> c);
+    }
+    public static class Lzcnt {
+        public static bool IsSupported { get; }
+        public static uint LeadingZeroCount(uint value);
+        public static ulong LeadingZeroCount(ulong value);
+    }
+    public static class Pclmulqdq {
+        public static bool IsSupported { get; }
+        public static Vector128<long> CarryLessMultiply(Vector128<long> left, Vector128<long> right, byte control);
+        public static Vector128<ulong> CarryLessMultiply(Vector128<ulong> left, Vector128<ulong> right, byte control);
+    }
+    public static class Popcnt {
+        public static bool IsSupported { get; }
+        public static int PopCount(uint value);
+        public static long PopCount(ulong value);
+    }
+    public enum ResultsFlag : byte {
+        CFlag = (byte)0,
+        NotCFlagAndNotZFlag = (byte)1,
+        OFlag = (byte)2,
+        SFlag = (byte)3,
+        ZFlag = (byte)4,
+    }
+    public static class Sse {
+        public static bool IsSupported { get; }
+        public static Vector128<float> Add(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> AddScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> And(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> AndNot(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareEqual(Vector128<float> left, Vector128<float> right);
+        public static bool CompareEqualOrderedScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareEqualScalar(Vector128<float> left, Vector128<float> right);
+        public static bool CompareEqualUnorderedScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareGreaterThan(Vector128<float> left, Vector128<float> right);
+        public static bool CompareGreaterThanOrderedScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareGreaterThanOrEqual(Vector128<float> left, Vector128<float> right);
+        public static bool CompareGreaterThanOrEqualOrderedScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareGreaterThanOrEqualScalar(Vector128<float> left, Vector128<float> right);
+        public static bool CompareGreaterThanOrEqualUnorderedScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareGreaterThanScalar(Vector128<float> left, Vector128<float> right);
+        public static bool CompareGreaterThanUnorderedScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareLessThan(Vector128<float> left, Vector128<float> right);
+        public static bool CompareLessThanOrderedScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareLessThanOrEqual(Vector128<float> left, Vector128<float> right);
+        public static bool CompareLessThanOrEqualOrderedScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareLessThanOrEqualScalar(Vector128<float> left, Vector128<float> right);
+        public static bool CompareLessThanOrEqualUnorderedScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareLessThanScalar(Vector128<float> left, Vector128<float> right);
+        public static bool CompareLessThanUnorderedScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareNotEqual(Vector128<float> left, Vector128<float> right);
+        public static bool CompareNotEqualOrderedScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareNotEqualScalar(Vector128<float> left, Vector128<float> right);
+        public static bool CompareNotEqualUnorderedScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareNotGreaterThan(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareNotGreaterThanOrEqual(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareNotGreaterThanOrEqualScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareNotGreaterThanScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareNotLessThan(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareNotLessThanOrEqual(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareNotLessThanOrEqualScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareNotLessThanScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareOrdered(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareOrderedScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareUnordered(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> CompareUnorderedScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> ConvertScalarToVector128Single(Vector128<float> upper, int value);
+        public static Vector128<float> ConvertScalarToVector128Single(Vector128<float> upper, long value);
+        public static int ConvertToInt32(Vector128<float> value);
+        public static int ConvertToInt32WithTruncation(Vector128<float> value);
+        public static long ConvertToInt64(Vector128<float> value);
+        public static long ConvertToInt64WithTruncation(Vector128<float> value);
+        public static float ConvertToSingle(Vector128<float> value);
+        public static Vector128<float> Divide(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> DivideScalar(Vector128<float> left, Vector128<float> right);
+        public unsafe static Vector128<float> LoadAlignedVector128(float* address);
+        public unsafe static Vector128<float> LoadHigh(Vector128<float> lower, float* address);
+        public unsafe static Vector128<float> LoadLow(Vector128<float> upper, float* address);
+        public unsafe static Vector128<float> LoadScalarVector128(float* address);
+        public unsafe static Vector128<float> LoadVector128(float* address);
+        public static Vector128<float> Max(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> MaxScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> Min(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> MinScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> MoveHighToLow(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> MoveLowToHigh(Vector128<float> left, Vector128<float> right);
+        public static int MoveMask(Vector128<float> value);
+        public static Vector128<float> MoveScalar(Vector128<float> upper, Vector128<float> value);
+        public static Vector128<float> Multiply(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> MultiplyScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> Or(Vector128<float> left, Vector128<float> right);
+        public unsafe static void Prefetch0(void* address);
+        public unsafe static void Prefetch1(void* address);
+        public unsafe static void Prefetch2(void* address);
+        public unsafe static void PrefetchNonTemporal(void* address);
+        public static Vector128<float> Reciprocal(Vector128<float> value);
+        public static Vector128<float> ReciprocalScalar(Vector128<float> value);
+        public static Vector128<float> ReciprocalScalar(Vector128<float> upper, Vector128<float> value);
+        public static Vector128<float> ReciprocalSqrt(Vector128<float> value);
+        public static Vector128<float> ReciprocalSqrtScalar(Vector128<float> value);
+        public static Vector128<float> ReciprocalSqrtScalar(Vector128<float> upper, Vector128<float> value);
+        public static Vector128<float> SetAllVector128(float value);
+        public static Vector128<float> SetScalarVector128(float value);
+        public static Vector128<float> SetVector128(float e3, float e2, float e1, float e0);
+        public static Vector128<float> SetZeroVector128();
+        public static Vector128<float> Shuffle(Vector128<float> left, Vector128<float> right, byte control);
+        public static Vector128<float> Sqrt(Vector128<float> value);
+        public static Vector128<float> SqrtScalar(Vector128<float> value);
+        public static Vector128<float> SqrtScalar(Vector128<float> upper, Vector128<float> value);
+        public static Vector128<U> StaticCast<T, U>(Vector128<T> value) where T : struct where U : struct;
+        public unsafe static void Store(float* address, Vector128<float> source);
+        public unsafe static void StoreAligned(float* address, Vector128<float> source);
+        public unsafe static void StoreAlignedNonTemporal(float* address, Vector128<float> source);
+        public static void StoreFence();
+        public unsafe static void StoreHigh(float* address, Vector128<float> source);
+        public unsafe static void StoreLow(float* address, Vector128<float> source);
+        public unsafe static void StoreScalar(float* address, Vector128<float> source);
+        public static Vector128<float> Subtract(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> SubtractScalar(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> UnpackHigh(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> UnpackLow(Vector128<float> left, Vector128<float> right);
+        public static Vector128<float> Xor(Vector128<float> left, Vector128<float> right);
+    }
+    public static class Sse2 {
+        public static bool IsSupported { get; }
+        public static Vector128<byte> Add(Vector128<byte> left, Vector128<byte> right);
+        public static Vector128<sbyte> Add(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static Vector128<short> Add(Vector128<short> left, Vector128<short> right);
+        public static Vector128<int> Add(Vector128<int> left, Vector128<int> right);
+        public static Vector128<long> Add(Vector128<long> left, Vector128<long> right);
+        public static Vector128<ushort> Add(Vector128<ushort> left, Vector128<ushort> right);
+        public static Vector128<uint> Add(Vector128<uint> left, Vector128<uint> right);
+        public static Vector128<double> Add(Vector128<double> left, Vector128<double> right);
+        public static Vector128<ulong> Add(Vector128<ulong> left, Vector128<ulong> right);
+        public static Vector128<byte> AddSaturate(Vector128<byte> left, Vector128<byte> right);
+        public static Vector128<sbyte> AddSaturate(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static Vector128<short> AddSaturate(Vector128<short> left, Vector128<short> right);
+        public static Vector128<ushort> AddSaturate(Vector128<ushort> left, Vector128<ushort> right);
+        public static Vector128<double> AddScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<byte> And(Vector128<byte> left, Vector128<byte> right);
+        public static Vector128<sbyte> And(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static Vector128<short> And(Vector128<short> left, Vector128<short> right);
+        public static Vector128<int> And(Vector128<int> left, Vector128<int> right);
+        public static Vector128<long> And(Vector128<long> left, Vector128<long> right);
+        public static Vector128<ushort> And(Vector128<ushort> left, Vector128<ushort> right);
+        public static Vector128<uint> And(Vector128<uint> left, Vector128<uint> right);
+        public static Vector128<ulong> And(Vector128<ulong> left, Vector128<ulong> right);
+        public static Vector128<double> And(Vector128<double> left, Vector128<double> right);
+        public static Vector128<byte> AndNot(Vector128<byte> left, Vector128<byte> right);
+        public static Vector128<sbyte> AndNot(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static Vector128<short> AndNot(Vector128<short> left, Vector128<short> right);
+        public static Vector128<int> AndNot(Vector128<int> left, Vector128<int> right);
+        public static Vector128<long> AndNot(Vector128<long> left, Vector128<long> right);
+        public static Vector128<ushort> AndNot(Vector128<ushort> left, Vector128<ushort> right);
+        public static Vector128<uint> AndNot(Vector128<uint> left, Vector128<uint> right);
+        public static Vector128<ulong> AndNot(Vector128<ulong> left, Vector128<ulong> right);
+        public static Vector128<double> AndNot(Vector128<double> left, Vector128<double> right);
+        public static Vector128<byte> Average(Vector128<byte> left, Vector128<byte> right);
+        public static Vector128<ushort> Average(Vector128<ushort> left, Vector128<ushort> right);
+        public static Vector128<byte> CompareEqual(Vector128<byte> left, Vector128<byte> right);
+        public static Vector128<sbyte> CompareEqual(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static Vector128<short> CompareEqual(Vector128<short> left, Vector128<short> right);
+        public static Vector128<int> CompareEqual(Vector128<int> left, Vector128<int> right);
+        public static Vector128<ushort> CompareEqual(Vector128<ushort> left, Vector128<ushort> right);
+        public static Vector128<uint> CompareEqual(Vector128<uint> left, Vector128<uint> right);
+        public static Vector128<double> CompareEqual(Vector128<double> left, Vector128<double> right);
+        public static bool CompareEqualOrderedScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareEqualScalar(Vector128<double> left, Vector128<double> right);
+        public static bool CompareEqualUnorderedScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<sbyte> CompareGreaterThan(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static Vector128<short> CompareGreaterThan(Vector128<short> left, Vector128<short> right);
+        public static Vector128<int> CompareGreaterThan(Vector128<int> left, Vector128<int> right);
+        public static Vector128<double> CompareGreaterThan(Vector128<double> left, Vector128<double> right);
+        public static bool CompareGreaterThanOrderedScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareGreaterThanOrEqual(Vector128<double> left, Vector128<double> right);
+        public static bool CompareGreaterThanOrEqualOrderedScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareGreaterThanOrEqualScalar(Vector128<double> left, Vector128<double> right);
+        public static bool CompareGreaterThanOrEqualUnorderedScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareGreaterThanScalar(Vector128<double> left, Vector128<double> right);
+        public static bool CompareGreaterThanUnorderedScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<sbyte> CompareLessThan(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static Vector128<short> CompareLessThan(Vector128<short> left, Vector128<short> right);
+        public static Vector128<int> CompareLessThan(Vector128<int> left, Vector128<int> right);
+        public static Vector128<double> CompareLessThan(Vector128<double> left, Vector128<double> right);
+        public static bool CompareLessThanOrderedScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareLessThanOrEqual(Vector128<double> left, Vector128<double> right);
+        public static bool CompareLessThanOrEqualOrderedScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareLessThanOrEqualScalar(Vector128<double> left, Vector128<double> right);
+        public static bool CompareLessThanOrEqualUnorderedScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareLessThanScalar(Vector128<double> left, Vector128<double> right);
+        public static bool CompareLessThanUnorderedScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareNotEqual(Vector128<double> left, Vector128<double> right);
+        public static bool CompareNotEqualOrderedScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareNotEqualScalar(Vector128<double> left, Vector128<double> right);
+        public static bool CompareNotEqualUnorderedScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareNotGreaterThan(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareNotGreaterThanOrEqual(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareNotGreaterThanOrEqualScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareNotGreaterThanScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareNotLessThan(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareNotLessThanOrEqual(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareNotLessThanOrEqualScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareNotLessThanScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareOrdered(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareOrderedScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareUnordered(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> CompareUnorderedScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> ConvertScalarToVector128Double(Vector128<double> upper, int value);
+        public static Vector128<double> ConvertScalarToVector128Double(Vector128<double> upper, long value);
+        public static Vector128<double> ConvertScalarToVector128Double(Vector128<double> upper, Vector128<float> value);
+        public static Vector128<int> ConvertScalarToVector128Int32(int value);
+        public static Vector128<long> ConvertScalarToVector128Int64(long value);
+        public static Vector128<float> ConvertScalarToVector128Single(Vector128<float> upper, Vector128<double> value);
+        public static Vector128<uint> ConvertScalarToVector128UInt32(uint value);
+        public static Vector128<ulong> ConvertScalarToVector128UInt64(ulong value);
+        public static double ConvertToDouble(Vector128<double> value);
+        public static int ConvertToInt32(Vector128<int> value);
+        public static int ConvertToInt32(Vector128<double> value);
+        public static int ConvertToInt32WithTruncation(Vector128<double> value);
+        public static long ConvertToInt64(Vector128<long> value);
+        public static long ConvertToInt64(Vector128<double> value);
+        public static long ConvertToInt64WithTruncation(Vector128<double> value);
+        public static uint ConvertToUInt32(Vector128<uint> value);
+        public static ulong ConvertToUInt64(Vector128<ulong> value);
+        public static Vector128<double> ConvertToVector128Double(Vector128<int> value);
+        public static Vector128<double> ConvertToVector128Double(Vector128<float> value);
+        public static Vector128<int> ConvertToVector128Int32(Vector128<float> value);
+        public static Vector128<int> ConvertToVector128Int32(Vector128<double> value);
+        public static Vector128<int> ConvertToVector128Int32WithTruncation(Vector128<float> value);
+        public static Vector128<int> ConvertToVector128Int32WithTruncation(Vector128<double> value);
+        public static Vector128<float> ConvertToVector128Single(Vector128<int> value);
+        public static Vector128<float> ConvertToVector128Single(Vector128<double> value);
+        public static Vector128<double> Divide(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> DivideScalar(Vector128<double> left, Vector128<double> right);
+        public static short Extract(Vector128<short> value, byte index);
+        public static ushort Extract(Vector128<ushort> value, byte index);
+        public static Vector128<short> Insert(Vector128<short> value, short data, byte index);
+        public static Vector128<ushort> Insert(Vector128<ushort> value, ushort data, byte index);
+        public unsafe static Vector128<byte> LoadAlignedVector128(byte* address);
+        public unsafe static Vector128<double> LoadAlignedVector128(double* address);
+        public unsafe static Vector128<short> LoadAlignedVector128(short* address);
+        public unsafe static Vector128<int> LoadAlignedVector128(int* address);
+        public unsafe static Vector128<long> LoadAlignedVector128(long* address);
+        public unsafe static Vector128<sbyte> LoadAlignedVector128(sbyte* address);
+        public unsafe static Vector128<ushort> LoadAlignedVector128(ushort* address);
+        public unsafe static Vector128<uint> LoadAlignedVector128(uint* address);
+        public unsafe static Vector128<ulong> LoadAlignedVector128(ulong* address);
+        public static void LoadFence();
+        public unsafe static Vector128<double> LoadHigh(Vector128<double> lower, double* address);
+        public unsafe static Vector128<double> LoadLow(Vector128<double> upper, double* address);
+        public unsafe static Vector128<double> LoadScalarVector128(double* address);
+        public unsafe static Vector128<int> LoadScalarVector128(int* address);
+        public unsafe static Vector128<long> LoadScalarVector128(long* address);
+        public unsafe static Vector128<uint> LoadScalarVector128(uint* address);
+        public unsafe static Vector128<ulong> LoadScalarVector128(ulong* address);
+        public unsafe static Vector128<byte> LoadVector128(byte* address);
+        public unsafe static Vector128<double> LoadVector128(double* address);
+        public unsafe static Vector128<short> LoadVector128(short* address);
+        public unsafe static Vector128<int> LoadVector128(int* address);
+        public unsafe static Vector128<long> LoadVector128(long* address);
+        public unsafe static Vector128<sbyte> LoadVector128(sbyte* address);
+        public unsafe static Vector128<ushort> LoadVector128(ushort* address);
+        public unsafe static Vector128<uint> LoadVector128(uint* address);
+        public unsafe static Vector128<ulong> LoadVector128(ulong* address);
+        public unsafe static void MaskMove(Vector128<byte> source, Vector128<byte> mask, byte* address);
+        public unsafe static void MaskMove(Vector128<sbyte> source, Vector128<sbyte> mask, sbyte* address);
+        public static Vector128<byte> Max(Vector128<byte> left, Vector128<byte> right);
+        public static Vector128<short> Max(Vector128<short> left, Vector128<short> right);
+        public static Vector128<double> Max(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> MaxScalar(Vector128<double> left, Vector128<double> right);
+        public static void MemoryFence();
+        public static Vector128<byte> Min(Vector128<byte> left, Vector128<byte> right);
+        public static Vector128<short> Min(Vector128<short> left, Vector128<short> right);
+        public static Vector128<double> Min(Vector128<double> left, Vector128<double> right);
+        public static Vector128<double> MinScalar(Vector128<double> left, Vector128<double> right);
+        public static int MoveMask(Vector128<byte> value);
+        public static int MoveMask(Vector128<sbyte> value);
+        public static int MoveMask(Vector128<double> value);
+        public static Vector128<long> MoveScalar(Vector128<long> value);
+        public static Vector128<ulong> MoveScalar(Vector128<ulong> value);
+        public static Vector128<double> MoveScalar(Vector128<double> upper, Vector128<double> value);
+        public static Vector128<ulong> Multiply(Vector128<uint> left, Vector128<uint> right);
+        public static Vector128<double> Multiply(Vector128<double> left, Vector128<double> right);
+        public static Vector128<short> MultiplyHigh(Vector128<short> left, Vector128<short> right);
+        public static Vector128<ushort> MultiplyHigh(Vector128<ushort> left, Vector128<ushort> right);
+        public static Vector128<int> MultiplyHorizontalAdd(Vector128<short> left, Vector128<short> right);
+        public static Vector128<short> MultiplyLow(Vector128<short> left, Vector128<short> right);
+        public static Vector128<double> MultiplyScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<byte> Or(Vector128<byte> left, Vector128<byte> right);
+        public static Vector128<sbyte> Or(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static Vector128<short> Or(Vector128<short> left, Vector128<short> right);
+        public static Vector128<int> Or(Vector128<int> left, Vector128<int> right);
+        public static Vector128<long> Or(Vector128<long> left, Vector128<long> right);
+        public static Vector128<ushort> Or(Vector128<ushort> left, Vector128<ushort> right);
+        public static Vector128<uint> Or(Vector128<uint> left, Vector128<uint> right);
+        public static Vector128<ulong> Or(Vector128<ulong> left, Vector128<ulong> right);
+        public static Vector128<double> Or(Vector128<double> left, Vector128<double> right);
+        public static Vector128<sbyte> PackSignedSaturate(Vector128<short> left, Vector128<short> right);
+        public static Vector128<short> PackSignedSaturate(Vector128<int> left, Vector128<int> right);
+        public static Vector128<byte> PackUnsignedSaturate(Vector128<short> left, Vector128<short> right);
+        public static Vector128<byte> SetAllVector128(byte value);
+        public static Vector128<double> SetAllVector128(double value);
+        public static Vector128<short> SetAllVector128(short value);
+        public static Vector128<int> SetAllVector128(int value);
+        public static Vector128<long> SetAllVector128(long value);
+        public static Vector128<sbyte> SetAllVector128(sbyte value);
+        public static Vector128<ushort> SetAllVector128(ushort value);
+        public static Vector128<uint> SetAllVector128(uint value);
+        public static Vector128<ulong> SetAllVector128(ulong value);
+        public static Vector128<double> SetScalarVector128(double value);
+        public static Vector128<byte> SetVector128(byte e15, byte e14, byte e13, byte e12, byte e11, byte e10, byte e9, byte e8, byte e7, byte e6, byte e5, byte e4, byte e3, byte e2, byte e1, byte e0);
+        public static Vector128<double> SetVector128(double e1, double e0);
+        public static Vector128<short> SetVector128(short e7, short e6, short e5, short e4, short e3, short e2, short e1, short e0);
+        public static Vector128<int> SetVector128(int e3, int e2, int e1, int e0);
+        public static Vector128<long> SetVector128(long e1, long e0);
+        public static Vector128<sbyte> SetVector128(sbyte e15, sbyte e14, sbyte e13, sbyte e12, sbyte e11, sbyte e10, sbyte e9, sbyte e8, sbyte e7, sbyte e6, sbyte e5, sbyte e4, sbyte e3, sbyte e2, sbyte e1, sbyte e0);
+        public static Vector128<ushort> SetVector128(ushort e7, ushort e6, ushort e5, ushort e4, ushort e3, ushort e2, ushort e1, ushort e0);
+        public static Vector128<uint> SetVector128(uint e3, uint e2, uint e1, uint e0);
+        public static Vector128<ulong> SetVector128(ulong e1, ulong e0);
+        public static Vector128<T> SetZeroVector128<T>() where T : struct;
+        public static Vector128<short> ShiftLeftLogical(Vector128<short> value, byte count);
+        public static Vector128<int> ShiftLeftLogical(Vector128<int> value, byte count);
+        public static Vector128<long> ShiftLeftLogical(Vector128<long> value, byte count);
+        public static Vector128<ushort> ShiftLeftLogical(Vector128<ushort> value, byte count);
+        public static Vector128<uint> ShiftLeftLogical(Vector128<uint> value, byte count);
+        public static Vector128<ulong> ShiftLeftLogical(Vector128<ulong> value, byte count);
+        public static Vector128<short> ShiftLeftLogical(Vector128<short> value, Vector128<short> count);
+        public static Vector128<int> ShiftLeftLogical(Vector128<int> value, Vector128<int> count);
+        public static Vector128<long> ShiftLeftLogical(Vector128<long> value, Vector128<long> count);
+        public static Vector128<ushort> ShiftLeftLogical(Vector128<ushort> value, Vector128<ushort> count);
+        public static Vector128<uint> ShiftLeftLogical(Vector128<uint> value, Vector128<uint> count);
+        public static Vector128<ulong> ShiftLeftLogical(Vector128<ulong> value, Vector128<ulong> count);
+        public static Vector128<byte> ShiftLeftLogical128BitLane(Vector128<byte> value, byte numBytes);
+        public static Vector128<sbyte> ShiftLeftLogical128BitLane(Vector128<sbyte> value, byte numBytes);
+        public static Vector128<short> ShiftLeftLogical128BitLane(Vector128<short> value, byte numBytes);
+        public static Vector128<int> ShiftLeftLogical128BitLane(Vector128<int> value, byte numBytes);
+        public static Vector128<long> ShiftLeftLogical128BitLane(Vector128<long> value, byte numBytes);
+        public static Vector128<ushort> ShiftLeftLogical128BitLane(Vector128<ushort> value, byte numBytes);
+        public static Vector128<uint> ShiftLeftLogical128BitLane(Vector128<uint> value, byte numBytes);
+        public static Vector128<ulong> ShiftLeftLogical128BitLane(Vector128<ulong> value, byte numBytes);
+        public static Vector128<short> ShiftRightArithmetic(Vector128<short> value, byte count);
+        public static Vector128<int> ShiftRightArithmetic(Vector128<int> value, byte count);
+        public static Vector128<short> ShiftRightArithmetic(Vector128<short> value, Vector128<short> count);
+        public static Vector128<int> ShiftRightArithmetic(Vector128<int> value, Vector128<int> count);
+        public static Vector128<short> ShiftRightLogical(Vector128<short> value, byte count);
+        public static Vector128<int> ShiftRightLogical(Vector128<int> value, byte count);
+        public static Vector128<long> ShiftRightLogical(Vector128<long> value, byte count);
+        public static Vector128<ushort> ShiftRightLogical(Vector128<ushort> value, byte count);
+        public static Vector128<uint> ShiftRightLogical(Vector128<uint> value, byte count);
+        public static Vector128<ulong> ShiftRightLogical(Vector128<ulong> value, byte count);
+        public static Vector128<short> ShiftRightLogical(Vector128<short> value, Vector128<short> count);
+        public static Vector128<int> ShiftRightLogical(Vector128<int> value, Vector128<int> count);
+        public static Vector128<long> ShiftRightLogical(Vector128<long> value, Vector128<long> count);
+        public static Vector128<ushort> ShiftRightLogical(Vector128<ushort> value, Vector128<ushort> count);
+        public static Vector128<uint> ShiftRightLogical(Vector128<uint> value, Vector128<uint> count);
+        public static Vector128<ulong> ShiftRightLogical(Vector128<ulong> value, Vector128<ulong> count);
+        public static Vector128<byte> ShiftRightLogical128BitLane(Vector128<byte> value, byte numBytes);
+        public static Vector128<sbyte> ShiftRightLogical128BitLane(Vector128<sbyte> value, byte numBytes);
+        public static Vector128<short> ShiftRightLogical128BitLane(Vector128<short> value, byte numBytes);
+        public static Vector128<int> ShiftRightLogical128BitLane(Vector128<int> value, byte numBytes);
+        public static Vector128<long> ShiftRightLogical128BitLane(Vector128<long> value, byte numBytes);
+        public static Vector128<ushort> ShiftRightLogical128BitLane(Vector128<ushort> value, byte numBytes);
+        public static Vector128<uint> ShiftRightLogical128BitLane(Vector128<uint> value, byte numBytes);
+        public static Vector128<ulong> ShiftRightLogical128BitLane(Vector128<ulong> value, byte numBytes);
+        public static Vector128<int> Shuffle(Vector128<int> value, byte control);
+        public static Vector128<uint> Shuffle(Vector128<uint> value, byte control);
+        public static Vector128<double> Shuffle(Vector128<double> left, Vector128<double> right, byte control);
+        public static Vector128<short> ShuffleHigh(Vector128<short> value, byte control);
+        public static Vector128<ushort> ShuffleHigh(Vector128<ushort> value, byte control);
+        public static Vector128<short> ShuffleLow(Vector128<short> value, byte control);
+        public static Vector128<ushort> ShuffleLow(Vector128<ushort> value, byte control);
+        public static Vector128<double> Sqrt(Vector128<double> value);
+        public static Vector128<double> SqrtScalar(Vector128<double> value);
+        public static Vector128<double> SqrtScalar(Vector128<double> upper, Vector128<double> value);
+        public unsafe static void Store(byte* address, Vector128<byte> source);
+        public unsafe static void Store(double* address, Vector128<double> source);
+        public unsafe static void Store(short* address, Vector128<short> source);
+        public unsafe static void Store(int* address, Vector128<int> source);
+        public unsafe static void Store(long* address, Vector128<long> source);
+        public unsafe static void Store(sbyte* address, Vector128<sbyte> source);
+        public unsafe static void Store(ushort* address, Vector128<ushort> source);
+        public unsafe static void Store(uint* address, Vector128<uint> source);
+        public unsafe static void Store(ulong* address, Vector128<ulong> source);
+        public unsafe static void StoreAligned(byte* address, Vector128<byte> source);
+        public unsafe static void StoreAligned(double* address, Vector128<double> source);
+        public unsafe static void StoreAligned(short* address, Vector128<short> source);
+        public unsafe static void StoreAligned(int* address, Vector128<int> source);
+        public unsafe static void StoreAligned(long* address, Vector128<long> source);
+        public unsafe static void StoreAligned(sbyte* address, Vector128<sbyte> source);
+        public unsafe static void StoreAligned(ushort* address, Vector128<ushort> source);
+        public unsafe static void StoreAligned(uint* address, Vector128<uint> source);
+        public unsafe static void StoreAligned(ulong* address, Vector128<ulong> source);
+        public unsafe static void StoreAlignedNonTemporal(byte* address, Vector128<byte> source);
+        public unsafe static void StoreAlignedNonTemporal(double* address, Vector128<double> source);
+        public unsafe static void StoreAlignedNonTemporal(short* address, Vector128<short> source);
+        public unsafe static void StoreAlignedNonTemporal(int* address, Vector128<int> source);
+        public unsafe static void StoreAlignedNonTemporal(long* address, Vector128<long> source);
+        public unsafe static void StoreAlignedNonTemporal(sbyte* address, Vector128<sbyte> source);
+        public unsafe static void StoreAlignedNonTemporal(ushort* address, Vector128<ushort> source);
+        public unsafe static void StoreAlignedNonTemporal(uint* address, Vector128<uint> source);
+        public unsafe static void StoreAlignedNonTemporal(ulong* address, Vector128<ulong> source);
+        public unsafe static void StoreHigh(double* address, Vector128<double> source);
+        public unsafe static void StoreLow(double* address, Vector128<double> source);
+        public unsafe static void StoreLow(long* address, Vector128<long> source);
+        public unsafe static void StoreLow(ulong* address, Vector128<ulong> source);
+        public unsafe static void StoreNonTemporal(int* address, int value);
+        public unsafe static void StoreNonTemporal(long* address, long value);
+        public unsafe static void StoreNonTemporal(uint* address, uint value);
+        public unsafe static void StoreNonTemporal(ulong* address, ulong value);
+        public unsafe static void StoreScalar(double* address, Vector128<double> source);
+        public static Vector128<byte> Subtract(Vector128<byte> left, Vector128<byte> right);
+        public static Vector128<sbyte> Subtract(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static Vector128<short> Subtract(Vector128<short> left, Vector128<short> right);
+        public static Vector128<int> Subtract(Vector128<int> left, Vector128<int> right);
+        public static Vector128<long> Subtract(Vector128<long> left, Vector128<long> right);
+        public static Vector128<ushort> Subtract(Vector128<ushort> left, Vector128<ushort> right);
+        public static Vector128<uint> Subtract(Vector128<uint> left, Vector128<uint> right);
+        public static Vector128<ulong> Subtract(Vector128<ulong> left, Vector128<ulong> right);
+        public static Vector128<double> Subtract(Vector128<double> left, Vector128<double> right);
+        public static Vector128<byte> SubtractSaturate(Vector128<byte> left, Vector128<byte> right);
+        public static Vector128<sbyte> SubtractSaturate(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static Vector128<short> SubtractSaturate(Vector128<short> left, Vector128<short> right);
+        public static Vector128<ushort> SubtractSaturate(Vector128<ushort> left, Vector128<ushort> right);
+        public static Vector128<double> SubtractScalar(Vector128<double> left, Vector128<double> right);
+        public static Vector128<long> SumAbsoluteDifferences(Vector128<byte> left, Vector128<byte> right);
+        public static Vector128<byte> UnpackHigh(Vector128<byte> left, Vector128<byte> right);
+        public static Vector128<sbyte> UnpackHigh(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static Vector128<short> UnpackHigh(Vector128<short> left, Vector128<short> right);
+        public static Vector128<int> UnpackHigh(Vector128<int> left, Vector128<int> right);
+        public static Vector128<long> UnpackHigh(Vector128<long> left, Vector128<long> right);
+        public static Vector128<ushort> UnpackHigh(Vector128<ushort> left, Vector128<ushort> right);
+        public static Vector128<uint> UnpackHigh(Vector128<uint> left, Vector128<uint> right);
+        public static Vector128<ulong> UnpackHigh(Vector128<ulong> left, Vector128<ulong> right);
+        public static Vector128<double> UnpackHigh(Vector128<double> left, Vector128<double> right);
+        public static Vector128<byte> UnpackLow(Vector128<byte> left, Vector128<byte> right);
+        public static Vector128<sbyte> UnpackLow(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static Vector128<short> UnpackLow(Vector128<short> left, Vector128<short> right);
+        public static Vector128<int> UnpackLow(Vector128<int> left, Vector128<int> right);
+        public static Vector128<long> UnpackLow(Vector128<long> left, Vector128<long> right);
+        public static Vector128<ushort> UnpackLow(Vector128<ushort> left, Vector128<ushort> right);
+        public static Vector128<uint> UnpackLow(Vector128<uint> left, Vector128<uint> right);
+        public static Vector128<ulong> UnpackLow(Vector128<ulong> left, Vector128<ulong> right);
+        public static Vector128<double> UnpackLow(Vector128<double> left, Vector128<double> right);
+        public static Vector128<byte> Xor(Vector128<byte> left, Vector128<byte> right);
+        public static Vector128<sbyte> Xor(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static Vector128<short> Xor(Vector128<short> left, Vector128<short> right);
+        public static Vector128<int> Xor(Vector128<int> left, Vector128<int> right);
+        public static Vector128<long> Xor(Vector128<long> left, Vector128<long> right);
+        public static Vector128<ushort> Xor(Vector128<ushort> left, Vector128<ushort> right);
+        public static Vector128<uint> Xor(Vector128<uint> left, Vector128<uint> right);
+        public static Vector128<ulong> Xor(Vector128<ulong> left, Vector128<ulong> right);
+        public static Vector128<double> Xor(Vector128<double> left, Vector128<double> right);
+    }
+    public static class Sse3 {
+        public static bool IsSupported { get; }
+        public static Vector128<float> AddSubtract(Vector128<float> left, Vector128<float> right);
+        public static Vector128<double> AddSubtract(Vector128<double> left, Vector128<double> right);
+        public static Vector128<float> HorizontalAdd(Vector128<float> left, Vector128<float> right);
+        public static Vector128<double> HorizontalAdd(Vector128<double> left, Vector128<double> right);
+        public static Vector128<float> HorizontalSubtract(Vector128<float> left, Vector128<float> right);
+        public static Vector128<double> HorizontalSubtract(Vector128<double> left, Vector128<double> right);
+        public unsafe static Vector128<double> LoadAndDuplicateToVector128(double* address);
+        public unsafe static Vector128<byte> LoadDquVector128(byte* address);
+        public unsafe static Vector128<short> LoadDquVector128(short* address);
+        public unsafe static Vector128<int> LoadDquVector128(int* address);
+        public unsafe static Vector128<long> LoadDquVector128(long* address);
+        public unsafe static Vector128<sbyte> LoadDquVector128(sbyte* address);
+        public unsafe static Vector128<ushort> LoadDquVector128(ushort* address);
+        public unsafe static Vector128<uint> LoadDquVector128(uint* address);
+        public unsafe static Vector128<ulong> LoadDquVector128(ulong* address);
+        public static Vector128<double> MoveAndDuplicate(Vector128<double> source);
+        public static Vector128<float> MoveHighAndDuplicate(Vector128<float> source);
+        public static Vector128<float> MoveLowAndDuplicate(Vector128<float> source);
+    }
+    public static class Sse41 {
+        public static bool IsSupported { get; }
+        public static Vector128<short> Blend(Vector128<short> left, Vector128<short> right, byte control);
+        public static Vector128<ushort> Blend(Vector128<ushort> left, Vector128<ushort> right, byte control);
+        public static Vector128<float> Blend(Vector128<float> left, Vector128<float> right, byte control);
+        public static Vector128<double> Blend(Vector128<double> left, Vector128<double> right, byte control);
+        public static Vector128<byte> BlendVariable(Vector128<byte> left, Vector128<byte> right, Vector128<byte> mask);
+        public static Vector128<sbyte> BlendVariable(Vector128<sbyte> left, Vector128<sbyte> right, Vector128<sbyte> mask);
+        public static Vector128<float> BlendVariable(Vector128<float> left, Vector128<float> right, Vector128<float> mask);
+        public static Vector128<double> BlendVariable(Vector128<double> left, Vector128<double> right, Vector128<double> mask);
+        public static Vector128<float> Ceiling(Vector128<float> value);
+        public static Vector128<double> Ceiling(Vector128<double> value);
+        public static Vector128<double> CeilingScalar(Vector128<double> value);
+        public static Vector128<float> CeilingScalar(Vector128<float> value);
+        public static Vector128<double> CeilingScalar(Vector128<double> upper, Vector128<double> value);
+        public static Vector128<float> CeilingScalar(Vector128<float> upper, Vector128<float> value);
+        public static Vector128<long> CompareEqual(Vector128<long> left, Vector128<long> right);
+        public static Vector128<ulong> CompareEqual(Vector128<ulong> left, Vector128<ulong> right);
+        public static Vector128<short> ConvertToVector128Int16(Vector128<byte> value);
+        public static Vector128<short> ConvertToVector128Int16(Vector128<sbyte> value);
+        public static Vector128<int> ConvertToVector128Int32(Vector128<byte> value);
+        public static Vector128<int> ConvertToVector128Int32(Vector128<sbyte> value);
+        public static Vector128<int> ConvertToVector128Int32(Vector128<short> value);
+        public static Vector128<int> ConvertToVector128Int32(Vector128<ushort> value);
+        public static Vector128<long> ConvertToVector128Int64(Vector128<byte> value);
+        public static Vector128<long> ConvertToVector128Int64(Vector128<sbyte> value);
+        public static Vector128<long> ConvertToVector128Int64(Vector128<short> value);
+        public static Vector128<long> ConvertToVector128Int64(Vector128<int> value);
+        public static Vector128<long> ConvertToVector128Int64(Vector128<ushort> value);
+        public static Vector128<long> ConvertToVector128Int64(Vector128<uint> value);
+        public static Vector128<float> DotProduct(Vector128<float> left, Vector128<float> right, byte control);
+        public static Vector128<double> DotProduct(Vector128<double> left, Vector128<double> right, byte control);
+        public static byte Extract(Vector128<byte> value, byte index);
+        public static sbyte Extract(Vector128<sbyte> value, byte index);
+        public static int Extract(Vector128<int> value, byte index);
+        public static long Extract(Vector128<long> value, byte index);
+        public static uint Extract(Vector128<uint> value, byte index);
+        public static ulong Extract(Vector128<ulong> value, byte index);
+        public static float Extract(Vector128<float> value, byte index);
+        public static Vector128<float> Floor(Vector128<float> value);
+        public static Vector128<double> Floor(Vector128<double> value);
+        public static Vector128<double> FloorScalar(Vector128<double> value);
+        public static Vector128<float> FloorScalar(Vector128<float> value);
+        public static Vector128<double> FloorScalar(Vector128<double> upper, Vector128<double> value);
+        public static Vector128<float> FloorScalar(Vector128<float> upper, Vector128<float> value);
+        public static Vector128<byte> Insert(Vector128<byte> value, byte data, byte index);
+        public static Vector128<sbyte> Insert(Vector128<sbyte> value, sbyte data, byte index);
+        public static Vector128<int> Insert(Vector128<int> value, int data, byte index);
+        public static Vector128<long> Insert(Vector128<long> value, long data, byte index);
+        public static Vector128<uint> Insert(Vector128<uint> value, uint data, byte index);
+        public static Vector128<ulong> Insert(Vector128<ulong> value, ulong data, byte index);
+        public static Vector128<float> Insert(Vector128<float> value, float data, byte index);
+        public unsafe static Vector128<byte> LoadAlignedVector128NonTemporal(byte* address);
+        public unsafe static Vector128<short> LoadAlignedVector128NonTemporal(short* address);
+        public unsafe static Vector128<int> LoadAlignedVector128NonTemporal(int* address);
+        public unsafe static Vector128<long> LoadAlignedVector128NonTemporal(long* address);
+        public unsafe static Vector128<sbyte> LoadAlignedVector128NonTemporal(sbyte* address);
+        public unsafe static Vector128<ushort> LoadAlignedVector128NonTemporal(ushort* address);
+        public unsafe static Vector128<uint> LoadAlignedVector128NonTemporal(uint* address);
+        public unsafe static Vector128<ulong> LoadAlignedVector128NonTemporal(ulong* address);
+        public static Vector128<sbyte> Max(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static Vector128<int> Max(Vector128<int> left, Vector128<int> right);
+        public static Vector128<ushort> Max(Vector128<ushort> left, Vector128<ushort> right);
+        public static Vector128<uint> Max(Vector128<uint> left, Vector128<uint> right);
+        public static Vector128<sbyte> Min(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static Vector128<int> Min(Vector128<int> left, Vector128<int> right);
+        public static Vector128<ushort> Min(Vector128<ushort> left, Vector128<ushort> right);
+        public static Vector128<uint> Min(Vector128<uint> left, Vector128<uint> right);
+        public static Vector128<ushort> MinHorizontal(Vector128<ushort> value);
+        public static Vector128<ushort> MultipleSumAbsoluteDifferences(Vector128<byte> left, Vector128<byte> right, byte mask);
+        public static Vector128<long> Multiply(Vector128<int> left, Vector128<int> right);
+        public static Vector128<int> MultiplyLow(Vector128<int> left, Vector128<int> right);
+        public static Vector128<ushort> PackUnsignedSaturate(Vector128<int> left, Vector128<int> right);
+        public static Vector128<float> RoundCurrentDirection(Vector128<float> value);
+        public static Vector128<double> RoundCurrentDirection(Vector128<double> value);
+        public static Vector128<double> RoundCurrentDirectionScalar(Vector128<double> value);
+        public static Vector128<float> RoundCurrentDirectionScalar(Vector128<float> value);
+        public static Vector128<double> RoundCurrentDirectionScalar(Vector128<double> upper, Vector128<double> value);
+        public static Vector128<float> RoundCurrentDirectionScalar(Vector128<float> upper, Vector128<float> value);
+        public static Vector128<float> RoundToNearestInteger(Vector128<float> value);
+        public static Vector128<double> RoundToNearestInteger(Vector128<double> value);
+        public static Vector128<double> RoundToNearestIntegerScalar(Vector128<double> value);
+        public static Vector128<float> RoundToNearestIntegerScalar(Vector128<float> value);
+        public static Vector128<double> RoundToNearestIntegerScalar(Vector128<double> upper, Vector128<double> value);
+        public static Vector128<float> RoundToNearestIntegerScalar(Vector128<float> upper, Vector128<float> value);
+        public static Vector128<float> RoundToNegativeInfinity(Vector128<float> value);
+        public static Vector128<double> RoundToNegativeInfinity(Vector128<double> value);
+        public static Vector128<double> RoundToNegativeInfinityScalar(Vector128<double> value);
+        public static Vector128<float> RoundToNegativeInfinityScalar(Vector128<float> value);
+        public static Vector128<double> RoundToNegativeInfinityScalar(Vector128<double> upper, Vector128<double> value);
+        public static Vector128<float> RoundToNegativeInfinityScalar(Vector128<float> upper, Vector128<float> value);
+        public static Vector128<float> RoundToPositiveInfinity(Vector128<float> value);
+        public static Vector128<double> RoundToPositiveInfinity(Vector128<double> value);
+        public static Vector128<double> RoundToPositiveInfinityScalar(Vector128<double> value);
+        public static Vector128<float> RoundToPositiveInfinityScalar(Vector128<float> value);
+        public static Vector128<double> RoundToPositiveInfinityScalar(Vector128<double> upper, Vector128<double> value);
+        public static Vector128<float> RoundToPositiveInfinityScalar(Vector128<float> upper, Vector128<float> value);
+        public static Vector128<float> RoundToZero(Vector128<float> value);
+        public static Vector128<double> RoundToZero(Vector128<double> value);
+        public static Vector128<double> RoundToZeroScalar(Vector128<double> value);
+        public static Vector128<float> RoundToZeroScalar(Vector128<float> value);
+        public static Vector128<double> RoundToZeroScalar(Vector128<double> upper, Vector128<double> value);
+        public static Vector128<float> RoundToZeroScalar(Vector128<float> upper, Vector128<float> value);
+        public static bool TestAllOnes(Vector128<byte> value);
+        public static bool TestAllOnes(Vector128<sbyte> value);
+        public static bool TestAllOnes(Vector128<short> value);
+        public static bool TestAllOnes(Vector128<int> value);
+        public static bool TestAllOnes(Vector128<long> value);
+        public static bool TestAllOnes(Vector128<ushort> value);
+        public static bool TestAllOnes(Vector128<uint> value);
+        public static bool TestAllOnes(Vector128<ulong> value);
+        public static bool TestAllZeros(Vector128<byte> left, Vector128<byte> right);
+        public static bool TestAllZeros(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static bool TestAllZeros(Vector128<short> left, Vector128<short> right);
+        public static bool TestAllZeros(Vector128<int> left, Vector128<int> right);
+        public static bool TestAllZeros(Vector128<long> left, Vector128<long> right);
+        public static bool TestAllZeros(Vector128<ushort> left, Vector128<ushort> right);
+        public static bool TestAllZeros(Vector128<uint> left, Vector128<uint> right);
+        public static bool TestAllZeros(Vector128<ulong> left, Vector128<ulong> right);
+        public static bool TestC(Vector128<byte> left, Vector128<byte> right);
+        public static bool TestC(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static bool TestC(Vector128<short> left, Vector128<short> right);
+        public static bool TestC(Vector128<int> left, Vector128<int> right);
+        public static bool TestC(Vector128<long> left, Vector128<long> right);
+        public static bool TestC(Vector128<ushort> left, Vector128<ushort> right);
+        public static bool TestC(Vector128<uint> left, Vector128<uint> right);
+        public static bool TestC(Vector128<ulong> left, Vector128<ulong> right);
+        public static bool TestMixOnesZeros(Vector128<byte> left, Vector128<byte> right);
+        public static bool TestMixOnesZeros(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static bool TestMixOnesZeros(Vector128<short> left, Vector128<short> right);
+        public static bool TestMixOnesZeros(Vector128<int> left, Vector128<int> right);
+        public static bool TestMixOnesZeros(Vector128<long> left, Vector128<long> right);
+        public static bool TestMixOnesZeros(Vector128<ushort> left, Vector128<ushort> right);
+        public static bool TestMixOnesZeros(Vector128<uint> left, Vector128<uint> right);
+        public static bool TestMixOnesZeros(Vector128<ulong> left, Vector128<ulong> right);
+        public static bool TestNotZAndNotC(Vector128<byte> left, Vector128<byte> right);
+        public static bool TestNotZAndNotC(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static bool TestNotZAndNotC(Vector128<short> left, Vector128<short> right);
+        public static bool TestNotZAndNotC(Vector128<int> left, Vector128<int> right);
+        public static bool TestNotZAndNotC(Vector128<long> left, Vector128<long> right);
+        public static bool TestNotZAndNotC(Vector128<ushort> left, Vector128<ushort> right);
+        public static bool TestNotZAndNotC(Vector128<uint> left, Vector128<uint> right);
+        public static bool TestNotZAndNotC(Vector128<ulong> left, Vector128<ulong> right);
+        public static bool TestZ(Vector128<byte> left, Vector128<byte> right);
+        public static bool TestZ(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static bool TestZ(Vector128<short> left, Vector128<short> right);
+        public static bool TestZ(Vector128<int> left, Vector128<int> right);
+        public static bool TestZ(Vector128<long> left, Vector128<long> right);
+        public static bool TestZ(Vector128<ushort> left, Vector128<ushort> right);
+        public static bool TestZ(Vector128<uint> left, Vector128<uint> right);
+        public static bool TestZ(Vector128<ulong> left, Vector128<ulong> right);
+    }
+    public static class Sse42 {
+        public static bool IsSupported { get; }
+        public static bool CompareExplicitLength(Vector128<byte> left, byte leftLength, Vector128<byte> right, byte rightLength, ResultsFlag flag, StringComparisonMode mode);
+        public static bool CompareExplicitLength(Vector128<sbyte> left, byte leftLength, Vector128<sbyte> right, byte rightLength, ResultsFlag flag, StringComparisonMode mode);
+        public static bool CompareExplicitLength(Vector128<short> left, byte leftLength, Vector128<short> right, byte rightLength, ResultsFlag flag, StringComparisonMode mode);
+        public static bool CompareExplicitLength(Vector128<ushort> left, byte leftLength, Vector128<ushort> right, byte rightLength, ResultsFlag flag, StringComparisonMode mode);
+        public static Vector128<ushort> CompareExplicitLengthBitMask(Vector128<byte> left, byte leftLength, Vector128<byte> right, byte rightLength, StringComparisonMode mode);
+        public static Vector128<ushort> CompareExplicitLengthBitMask(Vector128<sbyte> left, byte leftLength, Vector128<sbyte> right, byte rightLength, StringComparisonMode mode);
+        public static Vector128<byte> CompareExplicitLengthBitMask(Vector128<short> left, byte leftLength, Vector128<short> right, byte rightLength, StringComparisonMode mode);
+        public static Vector128<byte> CompareExplicitLengthBitMask(Vector128<ushort> left, byte leftLength, Vector128<ushort> right, byte rightLength, StringComparisonMode mode);
+        public static int CompareExplicitLengthIndex(Vector128<byte> left, byte leftLength, Vector128<byte> right, byte rightLength, StringComparisonMode mode);
+        public static int CompareExplicitLengthIndex(Vector128<sbyte> left, byte leftLength, Vector128<sbyte> right, byte rightLength, StringComparisonMode mode);
+        public static int CompareExplicitLengthIndex(Vector128<short> left, byte leftLength, Vector128<short> right, byte rightLength, StringComparisonMode mode);
+        public static int CompareExplicitLengthIndex(Vector128<ushort> left, byte leftLength, Vector128<ushort> right, byte rightLength, StringComparisonMode mode);
+        public static Vector128<byte> CompareExplicitLengthUnitMask(Vector128<byte> left, byte leftLength, Vector128<byte> right, byte rightLength, StringComparisonMode mode);
+        public static Vector128<byte> CompareExplicitLengthUnitMask(Vector128<sbyte> left, byte leftLength, Vector128<sbyte> right, byte rightLength, StringComparisonMode mode);
+        public static Vector128<ushort> CompareExplicitLengthUnitMask(Vector128<short> left, byte leftLength, Vector128<short> right, byte rightLength, StringComparisonMode mode);
+        public static Vector128<ushort> CompareExplicitLengthUnitMask(Vector128<ushort> left, byte leftLength, Vector128<ushort> right, byte rightLength, StringComparisonMode mode);
+        public static Vector128<long> CompareGreaterThan(Vector128<long> left, Vector128<long> right);
+        public static bool CompareImplicitLength(Vector128<byte> left, Vector128<byte> right, ResultsFlag flag, StringComparisonMode mode);
+        public static bool CompareImplicitLength(Vector128<sbyte> left, Vector128<sbyte> right, ResultsFlag flag, StringComparisonMode mode);
+        public static bool CompareImplicitLength(Vector128<short> left, Vector128<short> right, ResultsFlag flag, StringComparisonMode mode);
+        public static bool CompareImplicitLength(Vector128<ushort> left, Vector128<ushort> right, ResultsFlag flag, StringComparisonMode mode);
+        public static Vector128<ushort> CompareImplicitLengthBitMask(Vector128<byte> left, Vector128<byte> right, StringComparisonMode mode);
+        public static Vector128<ushort> CompareImplicitLengthBitMask(Vector128<sbyte> left, Vector128<sbyte> right, StringComparisonMode mode);
+        public static Vector128<byte> CompareImplicitLengthBitMask(Vector128<short> left, Vector128<short> right, StringComparisonMode mode);
+        public static Vector128<byte> CompareImplicitLengthBitMask(Vector128<ushort> left, Vector128<ushort> right, StringComparisonMode mode);
+        public static int CompareImplicitLengthIndex(Vector128<byte> left, Vector128<byte> right, StringComparisonMode mode);
+        public static int CompareImplicitLengthIndex(Vector128<sbyte> left, Vector128<sbyte> right, StringComparisonMode mode);
+        public static int CompareImplicitLengthIndex(Vector128<short> left, Vector128<short> right, StringComparisonMode mode);
+        public static int CompareImplicitLengthIndex(Vector128<ushort> left, Vector128<ushort> right, StringComparisonMode mode);
+        public static Vector128<byte> CompareImplicitLengthUnitMask(Vector128<byte> left, Vector128<byte> right, StringComparisonMode mode);
+        public static Vector128<byte> CompareImplicitLengthUnitMask(Vector128<sbyte> left, Vector128<sbyte> right, StringComparisonMode mode);
+        public static Vector128<ushort> CompareImplicitLengthUnitMask(Vector128<short> left, Vector128<short> right, StringComparisonMode mode);
+        public static Vector128<ushort> CompareImplicitLengthUnitMask(Vector128<ushort> left, Vector128<ushort> right, StringComparisonMode mode);
+        public static uint Crc32(uint crc, byte data);
+        public static uint Crc32(uint crc, ushort data);
+        public static uint Crc32(uint crc, uint data);
+        public static ulong Crc32(ulong crc, ulong data);
+    }
+    public static class Ssse3 {
+        public static bool IsSupported { get; }
+        public static Vector128<byte> Abs(Vector128<sbyte> value);
+        public static Vector128<ushort> Abs(Vector128<short> value);
+        public static Vector128<uint> Abs(Vector128<int> value);
+        public static Vector128<sbyte> AlignRight(Vector128<sbyte> left, Vector128<sbyte> right, byte mask);
+        public static Vector128<short> HorizontalAdd(Vector128<short> left, Vector128<short> right);
+        public static Vector128<int> HorizontalAdd(Vector128<int> left, Vector128<int> right);
+        public static Vector128<short> HorizontalAddSaturate(Vector128<short> left, Vector128<short> right);
+        public static Vector128<short> HorizontalSubtract(Vector128<short> left, Vector128<short> right);
+        public static Vector128<int> HorizontalSubtract(Vector128<int> left, Vector128<int> right);
+        public static Vector128<short> HorizontalSubtractSaturate(Vector128<short> left, Vector128<short> right);
+        public static Vector128<short> MultiplyAddAdjacent(Vector128<byte> left, Vector128<sbyte> right);
+        public static Vector128<short> MultiplyHighRoundScale(Vector128<short> left, Vector128<short> right);
+        public static Vector128<sbyte> Shuffle(Vector128<sbyte> value, Vector128<sbyte> mask);
+        public static Vector128<sbyte> Sign(Vector128<sbyte> left, Vector128<sbyte> right);
+        public static Vector128<short> Sign(Vector128<short> left, Vector128<short> right);
+        public static Vector128<int> Sign(Vector128<int> left, Vector128<int> right);
+    }
+    public enum StringComparisonMode : byte {
+        EqualAny = (byte)0,
+        EqualEach = (byte)8,
+        EqualOrdered = (byte)12,
+        LeastSignificant = (byte)0,
+        MaskedNegativePolarity = (byte)48,
+        MostSignificant = (byte)64,
+        NegativePolarity = (byte)16,
+        Ranges = (byte)4,
+    }
+}
 namespace System.Security {
+    public abstract class CodeAccessPermission : IPermission, ISecurityEncodable, IStackWalk {
+        protected CodeAccessPermission();
+        public void Assert();
+        public abstract IPermission Copy();
+        public void Demand();
+        public void Deny();
+        public override bool Equals(object obj);
+        public abstract void FromXml(SecurityElement elem);
+        public override int GetHashCode();
+        public abstract IPermission Intersect(IPermission target);
+        public abstract bool IsSubsetOf(IPermission target);
+        public void PermitOnly();
+        public static void RevertAll();
+        public static void RevertAssert();
+        public static void RevertDeny();
+        public static void RevertPermitOnly();
+        public override string ToString();
+        public abstract SecurityElement ToXml();
+        public virtual IPermission Union(IPermission other);
+    }
+    public class HostProtectionException : SystemException {
+        public HostProtectionException();
+        protected HostProtectionException(SerializationInfo info, StreamingContext context);
+        public HostProtectionException(string message);
+        public HostProtectionException(string message, Exception e);
+        public HostProtectionException(string message, HostProtectionResource protectedResources, HostProtectionResource demandedResources);
+        public HostProtectionResource DemandedResources { get; }
+        public HostProtectionResource ProtectedResources { get; }
+        public override string ToString();
+    }
+    public class HostSecurityManager {
+        public HostSecurityManager();
+        public virtual PolicyLevel DomainPolicy { get; }
+        public virtual HostSecurityManagerOptions Flags { get; }
+        public virtual ApplicationTrust DetermineApplicationTrust(Evidence applicationEvidence, Evidence activatorEvidence, TrustManagerContext context);
+        public virtual EvidenceBase GenerateAppDomainEvidence(Type evidenceType);
+        public virtual EvidenceBase GenerateAssemblyEvidence(Type evidenceType, Assembly assembly);
+        public virtual Type[] GetHostSuppliedAppDomainEvidenceTypes();
+        public virtual Type[] GetHostSuppliedAssemblyEvidenceTypes(Assembly assembly);
+        public virtual Evidence ProvideAppDomainEvidence(Evidence inputEvidence);
+        public virtual Evidence ProvideAssemblyEvidence(Assembly loadedAssembly, Evidence inputEvidence);
+        public virtual PermissionSet ResolvePolicy(Evidence evidence);
+    }
+    public enum HostSecurityManagerOptions {
+        AllFlags = 31,
+        HostAppDomainEvidence = 1,
+        HostAssemblyEvidence = 4,
+        HostDetermineApplicationTrust = 8,
+        HostPolicyLevel = 2,
+        HostResolvePolicy = 16,
+        None = 0,
+    }
+    public interface IEvidenceFactory {
+        Evidence Evidence { get; }
+    }
+    public interface ISecurityPolicyEncodable {
+        void FromXml(SecurityElement e, PolicyLevel level);
+        SecurityElement ToXml(PolicyLevel level);
+    }
+    public interface IStackWalk {
+        void Assert();
+        void Demand();
+        void Deny();
+        void PermitOnly();
+    }
+    public sealed class NamedPermissionSet : PermissionSet {
+        public NamedPermissionSet(NamedPermissionSet permSet);
+        public NamedPermissionSet(string name);
+        public NamedPermissionSet(string name, PermissionSet permSet);
+        public NamedPermissionSet(string name, PermissionState state);
+        public string Description { get; set; }
+        public string Name { get; set; }
+        public override PermissionSet Copy();
+        public NamedPermissionSet Copy(string name);
+        public override bool Equals(object o);
+        public override void FromXml(SecurityElement et);
+        public override int GetHashCode();
+        public override SecurityElement ToXml();
+    }
+    public class PermissionSet : ICollection, IDeserializationCallback, IEnumerable, ISecurityEncodable, IStackWalk {
+        public PermissionSet(PermissionSet permSet);
+        public PermissionSet(PermissionState state);
+        public virtual int Count { get; }
+        public virtual bool IsReadOnly { get; }
+        public virtual bool IsSynchronized { get; }
+        public virtual object SyncRoot { get; }
+        public IPermission AddPermission(IPermission perm);
+        protected virtual IPermission AddPermissionImpl(IPermission perm);
+        public void Assert();
+        public bool ContainsNonCodeAccessPermissions();
+        public static byte[] ConvertPermissionSet(string inFormat, byte[] inData, string outFormat);
+        public virtual PermissionSet Copy();
+        public virtual void CopyTo(Array array, int index);
+        public void Demand();
+        public void Deny();
+        public override bool Equals(object o);
+        public virtual void FromXml(SecurityElement et);
+        public IEnumerator GetEnumerator();
+        protected virtual IEnumerator GetEnumeratorImpl();
+        public override int GetHashCode();
+        public IPermission GetPermission(Type permClass);
+        protected virtual IPermission GetPermissionImpl(Type permClass);
+        public PermissionSet Intersect(PermissionSet other);
+        public bool IsEmpty();
+        public bool IsSubsetOf(PermissionSet target);
+        public bool IsUnrestricted();
+        public void PermitOnly();
+        public IPermission RemovePermission(Type permClass);
+        protected virtual IPermission RemovePermissionImpl(Type permClass);
+        public static void RevertAssert();
+        public IPermission SetPermission(IPermission perm);
+        protected virtual IPermission SetPermissionImpl(IPermission perm);
+        void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
+        public override string ToString();
+        public virtual SecurityElement ToXml();
+        public PermissionSet Union(PermissionSet other);
+    }
+    public enum PolicyLevelType {
+        AppDomain = 3,
+        Enterprise = 2,
+        Machine = 1,
+        User = 0,
+    }
+    public sealed class SecurityContext : IDisposable {
+        public static SecurityContext Capture();
+        public SecurityContext CreateCopy();
+        public void Dispose();
+        public static bool IsFlowSuppressed();
+        public static bool IsWindowsIdentityFlowSuppressed();
+        public static void RestoreFlow();
+        public static void Run(SecurityContext securityContext, ContextCallback callback, object state);
+        public static AsyncFlowControl SuppressFlow();
+        public static AsyncFlowControl SuppressFlowWindowsIdentity();
+    }
+    public enum SecurityContextSource {
+        CurrentAppDomain = 0,
+        CurrentAssembly = 1,
+    }
+    public static class SecurityManager {
+        public static bool CheckExecutionRights { get; set; }
+        public static bool SecurityEnabled { get; set; }
+        public static bool CurrentThreadRequiresSecurityContextCapture();
+        public static PermissionSet GetStandardSandbox(Evidence evidence);
+        public static void GetZoneAndOrigin(out ArrayList zone, out ArrayList origin);
+        public static bool IsGranted(IPermission perm);
+        public static PolicyLevel LoadPolicyLevelFromFile(string path, PolicyLevelType type);
+        public static PolicyLevel LoadPolicyLevelFromString(string str, PolicyLevelType type);
+        public static IEnumerator PolicyHierarchy();
+        public static PermissionSet ResolvePolicy(Evidence evidence);
+        public static PermissionSet ResolvePolicy(Evidence evidence, PermissionSet reqdPset, PermissionSet optPset, PermissionSet denyPset, out PermissionSet denied);
+        public static PermissionSet ResolvePolicy(Evidence[] evidences);
+        public static IEnumerator ResolvePolicyGroups(Evidence evidence);
+        public static PermissionSet ResolveSystemPolicy(Evidence evidence);
+        public static void SavePolicy();
+        public static void SavePolicyLevel(PolicyLevel level);
+    }
+    public abstract class SecurityState {
+        protected SecurityState();
+        public abstract void EnsureState();
+        public bool IsStateAvailable();
+    }
+    public enum SecurityZone {
+        Internet = 3,
+        Intranet = 1,
+        MyComputer = 0,
+        NoZone = -1,
+        Trusted = 2,
+        Untrusted = 4,
+    }
+    public sealed class XmlSyntaxException : SystemException {
+        public XmlSyntaxException();
+        public XmlSyntaxException(int lineNumber);
+        public XmlSyntaxException(int lineNumber, string message);
+        public XmlSyntaxException(string message);
+        public XmlSyntaxException(string message, Exception inner);
+    }
 }
+namespace System.Security.AccessControl {
+    public enum AccessControlActions {
+        Change = 2,
+        None = 0,
+        View = 1,
+    }
+    public enum AccessControlModification {
+        Add = 0,
+        Remove = 3,
+        RemoveAll = 4,
+        RemoveSpecific = 5,
+        Reset = 2,
+        Set = 1,
+    }
+    public enum AccessControlSections {
+        Access = 2,
+        All = 15,
+        Audit = 1,
+        Group = 8,
+        None = 0,
+        Owner = 4,
+    }
+    public enum AccessControlType {
+        Allow = 0,
+        Deny = 1,
+    }
+    public abstract class AccessRule : AuthorizationRule {
+        protected AccessRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public AccessControlType AccessControlType { get; }
+    }
+    public class AccessRule<T> : AccessRule where T : struct {
+        public AccessRule(IdentityReference identity, T rights, AccessControlType type);
+        public AccessRule(IdentityReference identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public AccessRule(string identity, T rights, AccessControlType type);
+        public AccessRule(string identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public T Rights { get; }
+    }
+    public sealed class AceEnumerator : IEnumerator {
+        public GenericAce Current { get; }
+        object System.Collections.IEnumerator.Current { get; }
+        public bool MoveNext();
+        public void Reset();
+    }
+    public enum AceFlags : byte {
+        AuditFlags = (byte)192,
+        ContainerInherit = (byte)2,
+        FailedAccess = (byte)128,
+        InheritanceFlags = (byte)15,
+        Inherited = (byte)16,
+        InheritOnly = (byte)8,
+        None = (byte)0,
+        NoPropagateInherit = (byte)4,
+        ObjectInherit = (byte)1,
+        SuccessfulAccess = (byte)64,
+    }
+    public enum AceQualifier {
+        AccessAllowed = 0,
+        AccessDenied = 1,
+        SystemAlarm = 3,
+        SystemAudit = 2,
+    }
+    public enum AceType : byte {
+        AccessAllowed = (byte)0,
+        AccessAllowedCallback = (byte)9,
+        AccessAllowedCallbackObject = (byte)11,
+        AccessAllowedCompound = (byte)4,
+        AccessAllowedObject = (byte)5,
+        AccessDenied = (byte)1,
+        AccessDeniedCallback = (byte)10,
+        AccessDeniedCallbackObject = (byte)12,
+        AccessDeniedObject = (byte)6,
+        MaxDefinedAceType = (byte)16,
+        SystemAlarm = (byte)3,
+        SystemAlarmCallback = (byte)14,
+        SystemAlarmCallbackObject = (byte)16,
+        SystemAlarmObject = (byte)8,
+        SystemAudit = (byte)2,
+        SystemAuditCallback = (byte)13,
+        SystemAuditCallbackObject = (byte)15,
+        SystemAuditObject = (byte)7,
+    }
+    public enum AuditFlags {
+        Failure = 2,
+        None = 0,
+        Success = 1,
+    }
+    public abstract class AuditRule : AuthorizationRule {
+        protected AuditRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags auditFlags);
+        public AuditFlags AuditFlags { get; }
+    }
+    public class AuditRule<T> : AuditRule where T : struct {
+        public AuditRule(IdentityReference identity, T rights, AuditFlags flags);
+        public AuditRule(IdentityReference identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public AuditRule(string identity, T rights, AuditFlags flags);
+        public AuditRule(string identity, T rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public T Rights { get; }
+    }
+    public abstract class AuthorizationRule {
+        protected internal AuthorizationRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
+        protected internal int AccessMask { get; }
+        public IdentityReference IdentityReference { get; }
+        public InheritanceFlags InheritanceFlags { get; }
+        public bool IsInherited { get; }
+        public PropagationFlags PropagationFlags { get; }
+    }
+    public sealed class AuthorizationRuleCollection : ReadOnlyCollectionBase {
+        public AuthorizationRuleCollection();
+        public AuthorizationRule this[int index] { get; }
+        public void AddRule(AuthorizationRule rule);
+        public void CopyTo(AuthorizationRule[] rules, int index);
+    }
+    public sealed class CommonAce : QualifiedAce {
+        public CommonAce(AceFlags flags, AceQualifier qualifier, int accessMask, SecurityIdentifier sid, bool isCallback, byte[] opaque);
+        public override int BinaryLength { get; }
+        public override void GetBinaryForm(byte[] binaryForm, int offset);
+        public static int MaxOpaqueLength(bool isCallback);
+    }
+    public abstract class CommonAcl : GenericAcl {
+        public sealed override int BinaryLength { get; }
+        public sealed override int Count { get; }
+        public bool IsCanonical { get; }
+        public bool IsContainer { get; }
+        public bool IsDS { get; }
+        public sealed override GenericAce this[int index] { get; set; }
+        public sealed override byte Revision { get; }
+        public sealed override void GetBinaryForm(byte[] binaryForm, int offset);
+        public void Purge(SecurityIdentifier sid);
+        public void RemoveInheritedAces();
+    }
+    public abstract class CommonObjectSecurity : ObjectSecurity {
+        protected CommonObjectSecurity(bool isContainer);
+        protected void AddAccessRule(AccessRule rule);
+        protected void AddAuditRule(AuditRule rule);
+        public AuthorizationRuleCollection GetAccessRules(bool includeExplicit, bool includeInherited, Type targetType);
+        public AuthorizationRuleCollection GetAuditRules(bool includeExplicit, bool includeInherited, Type targetType);
+        protected override bool ModifyAccess(AccessControlModification modification, AccessRule rule, out bool modified);
+        protected override bool ModifyAudit(AccessControlModification modification, AuditRule rule, out bool modified);
+        protected bool RemoveAccessRule(AccessRule rule);
+        protected void RemoveAccessRuleAll(AccessRule rule);
+        protected void RemoveAccessRuleSpecific(AccessRule rule);
+        protected bool RemoveAuditRule(AuditRule rule);
+        protected void RemoveAuditRuleAll(AuditRule rule);
+        protected void RemoveAuditRuleSpecific(AuditRule rule);
+        protected void ResetAccessRule(AccessRule rule);
+        protected void SetAccessRule(AccessRule rule);
+        protected void SetAuditRule(AuditRule rule);
+    }
+    public sealed class CommonSecurityDescriptor : GenericSecurityDescriptor {
+        public CommonSecurityDescriptor(bool isContainer, bool isDS, byte[] binaryForm, int offset);
+        public CommonSecurityDescriptor(bool isContainer, bool isDS, ControlFlags flags, SecurityIdentifier owner, SecurityIdentifier group, SystemAcl systemAcl, DiscretionaryAcl discretionaryAcl);
+        public CommonSecurityDescriptor(bool isContainer, bool isDS, RawSecurityDescriptor rawSecurityDescriptor);
+        public CommonSecurityDescriptor(bool isContainer, bool isDS, string sddlForm);
+        public override ControlFlags ControlFlags { get; }
+        public DiscretionaryAcl DiscretionaryAcl { get; set; }
+        public override SecurityIdentifier Group { get; set; }
+        public bool IsContainer { get; }
+        public bool IsDiscretionaryAclCanonical { get; }
+        public bool IsDS { get; }
+        public bool IsSystemAclCanonical { get; }
+        public override SecurityIdentifier Owner { get; set; }
+        public SystemAcl SystemAcl { get; set; }
+        public void AddDiscretionaryAcl(byte revision, int trusted);
+        public void AddSystemAcl(byte revision, int trusted);
+        public void PurgeAccessControl(SecurityIdentifier sid);
+        public void PurgeAudit(SecurityIdentifier sid);
+        public void SetDiscretionaryAclProtection(bool isProtected, bool preserveInheritance);
+        public void SetSystemAclProtection(bool isProtected, bool preserveInheritance);
+    }
+    public sealed class CompoundAce : KnownAce {
+        public CompoundAce(AceFlags flags, int accessMask, CompoundAceType compoundAceType, SecurityIdentifier sid);
+        public override int BinaryLength { get; }
+        public CompoundAceType CompoundAceType { get; set; }
+        public override void GetBinaryForm(byte[] binaryForm, int offset);
+    }
+    public enum CompoundAceType {
+        Impersonation = 1,
+    }
+    public enum ControlFlags {
+        DiscretionaryAclAutoInherited = 1024,
+        DiscretionaryAclAutoInheritRequired = 256,
+        DiscretionaryAclDefaulted = 8,
+        DiscretionaryAclPresent = 4,
+        DiscretionaryAclProtected = 4096,
+        DiscretionaryAclUntrusted = 64,
+        GroupDefaulted = 2,
+        None = 0,
+        OwnerDefaulted = 1,
+        RMControlValid = 16384,
+        SelfRelative = 32768,
+        ServerSecurity = 128,
+        SystemAclAutoInherited = 2048,
+        SystemAclAutoInheritRequired = 512,
+        SystemAclDefaulted = 32,
+        SystemAclPresent = 16,
+        SystemAclProtected = 8192,
+    }
+    public sealed class CustomAce : GenericAce {
+        public static readonly int MaxOpaqueLength;
+        public CustomAce(AceType type, AceFlags flags, byte[] opaque);
+        public override int BinaryLength { get; }
+        public int OpaqueLength { get; }
+        public override void GetBinaryForm(byte[] binaryForm, int offset);
+        public byte[] GetOpaque();
+        public void SetOpaque(byte[] opaque);
+    }
+    public abstract class DirectoryObjectSecurity : ObjectSecurity {
+        protected DirectoryObjectSecurity();
+        protected DirectoryObjectSecurity(CommonSecurityDescriptor securityDescriptor);
+        public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type, Guid objectType, Guid inheritedObjectType);
+        protected void AddAccessRule(ObjectAccessRule rule);
+        protected void AddAuditRule(ObjectAuditRule rule);
+        public virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags, Guid objectType, Guid inheritedObjectType);
+        public AuthorizationRuleCollection GetAccessRules(bool includeExplicit, bool includeInherited, Type targetType);
+        public AuthorizationRuleCollection GetAuditRules(bool includeExplicit, bool includeInherited, Type targetType);
+        protected override bool ModifyAccess(AccessControlModification modification, AccessRule rule, out bool modified);
+        protected override bool ModifyAudit(AccessControlModification modification, AuditRule rule, out bool modified);
+        protected bool RemoveAccessRule(ObjectAccessRule rule);
+        protected void RemoveAccessRuleAll(ObjectAccessRule rule);
+        protected void RemoveAccessRuleSpecific(ObjectAccessRule rule);
+        protected bool RemoveAuditRule(ObjectAuditRule rule);
+        protected void RemoveAuditRuleAll(ObjectAuditRule rule);
+        protected void RemoveAuditRuleSpecific(ObjectAuditRule rule);
+        protected void ResetAccessRule(ObjectAccessRule rule);
+        protected void SetAccessRule(ObjectAccessRule rule);
+        protected void SetAuditRule(ObjectAuditRule rule);
+    }
+    public sealed class DirectorySecurity : FileSystemSecurity {
+        public DirectorySecurity();
+        public DirectorySecurity(string name, AccessControlSections includeSections);
+    }
+    public sealed class DiscretionaryAcl : CommonAcl {
+        public DiscretionaryAcl(bool isContainer, bool isDS, byte revision, int capacity);
+        public DiscretionaryAcl(bool isContainer, bool isDS, int capacity);
+        public DiscretionaryAcl(bool isContainer, bool isDS, RawAcl rawAcl);
+        public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
+        public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
+        public void AddAccess(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule);
+        public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
+        public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
+        public bool RemoveAccess(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule);
+        public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
+        public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
+        public void RemoveAccessSpecific(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule);
+        public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
+        public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
+        public void SetAccess(AccessControlType accessType, SecurityIdentifier sid, ObjectAccessRule rule);
+    }
+    public sealed class EventWaitHandleAccessRule : AccessRule {
+        public EventWaitHandleAccessRule(IdentityReference identity, EventWaitHandleRights eventRights, AccessControlType type);
+        public EventWaitHandleAccessRule(string identity, EventWaitHandleRights eventRights, AccessControlType type);
+        public EventWaitHandleRights EventWaitHandleRights { get; }
+    }
+    public sealed class EventWaitHandleAuditRule : AuditRule {
+        public EventWaitHandleAuditRule(IdentityReference identity, EventWaitHandleRights eventRights, AuditFlags flags);
+        public EventWaitHandleRights EventWaitHandleRights { get; }
+    }
+    public enum EventWaitHandleRights {
+        ChangePermissions = 262144,
+        Delete = 65536,
+        FullControl = 2031619,
+        Modify = 2,
+        ReadPermissions = 131072,
+        Synchronize = 1048576,
+        TakeOwnership = 524288,
+    }
+    public sealed class EventWaitHandleSecurity : NativeObjectSecurity {
+        public EventWaitHandleSecurity();
+        public override Type AccessRightType { get; }
+        public override Type AccessRuleType { get; }
+        public override Type AuditRuleType { get; }
+        public override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public void AddAccessRule(EventWaitHandleAccessRule rule);
+        public void AddAuditRule(EventWaitHandleAuditRule rule);
+        public override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public bool RemoveAccessRule(EventWaitHandleAccessRule rule);
+        public void RemoveAccessRuleAll(EventWaitHandleAccessRule rule);
+        public void RemoveAccessRuleSpecific(EventWaitHandleAccessRule rule);
+        public bool RemoveAuditRule(EventWaitHandleAuditRule rule);
+        public void RemoveAuditRuleAll(EventWaitHandleAuditRule rule);
+        public void RemoveAuditRuleSpecific(EventWaitHandleAuditRule rule);
+        public void ResetAccessRule(EventWaitHandleAccessRule rule);
+        public void SetAccessRule(EventWaitHandleAccessRule rule);
+        public void SetAuditRule(EventWaitHandleAuditRule rule);
+    }
+    public sealed class FileSecurity : FileSystemSecurity {
+        public FileSecurity();
+        public FileSecurity(string fileName, AccessControlSections includeSections);
+    }
+    public sealed class FileSystemAccessRule : AccessRule {
+        public FileSystemAccessRule(IdentityReference identity, FileSystemRights fileSystemRights, AccessControlType type);
+        public FileSystemAccessRule(IdentityReference identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public FileSystemAccessRule(string identity, FileSystemRights fileSystemRights, AccessControlType type);
+        public FileSystemAccessRule(string identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public FileSystemRights FileSystemRights { get; }
+    }
+    public sealed class FileSystemAuditRule : AuditRule {
+        public FileSystemAuditRule(IdentityReference identity, FileSystemRights fileSystemRights, AuditFlags flags);
+        public FileSystemAuditRule(IdentityReference identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public FileSystemAuditRule(string identity, FileSystemRights fileSystemRights, AuditFlags flags);
+        public FileSystemAuditRule(string identity, FileSystemRights fileSystemRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public FileSystemRights FileSystemRights { get; }
+    }
+    public enum FileSystemRights {
+        AppendData = 4,
+        ChangePermissions = 262144,
+        CreateDirectories = 4,
+        CreateFiles = 2,
+        Delete = 65536,
+        DeleteSubdirectoriesAndFiles = 64,
+        ExecuteFile = 32,
+        FullControl = 2032127,
+        ListDirectory = 1,
+        Modify = 197055,
+        Read = 131209,
+        ReadAndExecute = 131241,
+        ReadAttributes = 128,
+        ReadData = 1,
+        ReadExtendedAttributes = 8,
+        ReadPermissions = 131072,
+        Synchronize = 1048576,
+        TakeOwnership = 524288,
+        Traverse = 32,
+        Write = 278,
+        WriteAttributes = 256,
+        WriteData = 2,
+        WriteExtendedAttributes = 16,
+    }
+    public abstract class FileSystemSecurity : NativeObjectSecurity {
+        public override Type AccessRightType { get; }
+        public override Type AccessRuleType { get; }
+        public override Type AuditRuleType { get; }
+        public sealed override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public void AddAccessRule(FileSystemAccessRule rule);
+        public void AddAuditRule(FileSystemAuditRule rule);
+        public sealed override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public bool RemoveAccessRule(FileSystemAccessRule rule);
+        public void RemoveAccessRuleAll(FileSystemAccessRule rule);
+        public void RemoveAccessRuleSpecific(FileSystemAccessRule rule);
+        public bool RemoveAuditRule(FileSystemAuditRule rule);
+        public void RemoveAuditRuleAll(FileSystemAuditRule rule);
+        public void RemoveAuditRuleSpecific(FileSystemAuditRule rule);
+        public void ResetAccessRule(FileSystemAccessRule rule);
+        public void SetAccessRule(FileSystemAccessRule rule);
+        public void SetAuditRule(FileSystemAuditRule rule);
+    }
+    public abstract class GenericAce {
+        public AceFlags AceFlags { get; set; }
+        public AceType AceType { get; }
+        public AuditFlags AuditFlags { get; }
+        public abstract int BinaryLength { get; }
+        public InheritanceFlags InheritanceFlags { get; }
+        public bool IsInherited { get; }
+        public PropagationFlags PropagationFlags { get; }
+        public GenericAce Copy();
+        public static GenericAce CreateFromBinaryForm(byte[] binaryForm, int offset);
+        public sealed override bool Equals(object o);
+        public abstract void GetBinaryForm(byte[] binaryForm, int offset);
+        public sealed override int GetHashCode();
+        public static bool operator ==(GenericAce left, GenericAce right);
+        public static bool operator !=(GenericAce left, GenericAce right);
+    }
+    public abstract class GenericAcl : ICollection, IEnumerable {
+        public static readonly byte AclRevision;
+        public static readonly byte AclRevisionDS;
+        public static readonly int MaxBinaryLength;
+        protected GenericAcl();
+        public abstract int BinaryLength { get; }
+        public abstract int Count { get; }
+        public bool IsSynchronized { get; }
+        public abstract GenericAce this[int index] { get; set; }
+        public abstract byte Revision { get; }
+        public virtual object SyncRoot { get; }
+        public void CopyTo(GenericAce[] array, int index);
+        public abstract void GetBinaryForm(byte[] binaryForm, int offset);
+        public AceEnumerator GetEnumerator();
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public abstract class GenericSecurityDescriptor {
+        protected GenericSecurityDescriptor();
+        public int BinaryLength { get; }
+        public abstract ControlFlags ControlFlags { get; }
+        public abstract SecurityIdentifier Group { get; set; }
+        public abstract SecurityIdentifier Owner { get; set; }
+        public static byte Revision { get; }
+        public void GetBinaryForm(byte[] binaryForm, int offset);
+        public string GetSddlForm(AccessControlSections includeSections);
+        public static bool IsSddlConversionSupported();
+    }
+    public enum InheritanceFlags {
+        ContainerInherit = 1,
+        None = 0,
+        ObjectInherit = 2,
+    }
+    public abstract class KnownAce : GenericAce {
+        public int AccessMask { get; set; }
+        public SecurityIdentifier SecurityIdentifier { get; set; }
+    }
+    public sealed class MutexAccessRule : AccessRule {
+        public MutexAccessRule(IdentityReference identity, MutexRights eventRights, AccessControlType type);
+        public MutexAccessRule(string identity, MutexRights eventRights, AccessControlType type);
+        public MutexRights MutexRights { get; }
+    }
+    public sealed class MutexAuditRule : AuditRule {
+        public MutexAuditRule(IdentityReference identity, MutexRights eventRights, AuditFlags flags);
+        public MutexRights MutexRights { get; }
+    }
+    public enum MutexRights {
+        ChangePermissions = 262144,
+        Delete = 65536,
+        FullControl = 2031617,
+        Modify = 1,
+        ReadPermissions = 131072,
+        Synchronize = 1048576,
+        TakeOwnership = 524288,
+    }
+    public sealed class MutexSecurity : NativeObjectSecurity {
+        public MutexSecurity();
+        public MutexSecurity(string name, AccessControlSections includeSections);
+        public override Type AccessRightType { get; }
+        public override Type AccessRuleType { get; }
+        public override Type AuditRuleType { get; }
+        public override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public void AddAccessRule(MutexAccessRule rule);
+        public void AddAuditRule(MutexAuditRule rule);
+        public override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public bool RemoveAccessRule(MutexAccessRule rule);
+        public void RemoveAccessRuleAll(MutexAccessRule rule);
+        public void RemoveAccessRuleSpecific(MutexAccessRule rule);
+        public bool RemoveAuditRule(MutexAuditRule rule);
+        public void RemoveAuditRuleAll(MutexAuditRule rule);
+        public void RemoveAuditRuleSpecific(MutexAuditRule rule);
+        public void ResetAccessRule(MutexAccessRule rule);
+        public void SetAccessRule(MutexAccessRule rule);
+        public void SetAuditRule(MutexAuditRule rule);
+    }
+    public abstract class NativeObjectSecurity : CommonObjectSecurity {
+        protected internal delegate Exception ExceptionFromErrorCode(int errorCode, string name, SafeHandle handle, object context); {
+            public ExceptionFromErrorCode(object @object, IntPtr method);
+            public virtual IAsyncResult BeginInvoke(int errorCode, string name, SafeHandle handle, object context, AsyncCallback callback, object @object);
+            public virtual Exception EndInvoke(IAsyncResult result);
+            public virtual Exception Invoke(int errorCode, string name, SafeHandle handle, object context);
+        }
+        protected NativeObjectSecurity(bool isContainer, ResourceType resourceType);
+        protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, NativeObjectSecurity.ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
+        protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, SafeHandle handle, AccessControlSections includeSections);
+        protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, SafeHandle handle, AccessControlSections includeSections, NativeObjectSecurity.ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
+        protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections);
+        protected NativeObjectSecurity(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections, NativeObjectSecurity.ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
+        protected sealed override void Persist(SafeHandle handle, AccessControlSections includeSections);
+        protected void Persist(SafeHandle handle, AccessControlSections includeSections, object exceptionContext);
+        protected sealed override void Persist(string name, AccessControlSections includeSections);
+        protected void Persist(string name, AccessControlSections includeSections, object exceptionContext);
+    }
+    public abstract class ObjectAccessRule : AccessRule {
+        protected ObjectAccessRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, Guid objectType, Guid inheritedObjectType, AccessControlType type);
+        public Guid InheritedObjectType { get; }
+        public ObjectAceFlags ObjectFlags { get; }
+        public Guid ObjectType { get; }
+    }
+    public sealed class ObjectAce : QualifiedAce {
+        public ObjectAce(AceFlags aceFlags, AceQualifier qualifier, int accessMask, SecurityIdentifier sid, ObjectAceFlags flags, Guid type, Guid inheritedType, bool isCallback, byte[] opaque);
+        public override int BinaryLength { get; }
+        public Guid InheritedObjectAceType { get; set; }
+        public ObjectAceFlags ObjectAceFlags { get; set; }
+        public Guid ObjectAceType { get; set; }
+        public override void GetBinaryForm(byte[] binaryForm, int offset);
+        public static int MaxOpaqueLength(bool isCallback);
+    }
+    public enum ObjectAceFlags {
+        InheritedObjectAceTypePresent = 2,
+        None = 0,
+        ObjectAceTypePresent = 1,
+    }
+    public abstract class ObjectAuditRule : AuditRule {
+        protected ObjectAuditRule(IdentityReference identity, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, Guid objectType, Guid inheritedObjectType, AuditFlags auditFlags);
+        public Guid InheritedObjectType { get; }
+        public ObjectAceFlags ObjectFlags { get; }
+        public Guid ObjectType { get; }
+    }
+    public abstract class ObjectSecurity {
+        protected ObjectSecurity();
+        protected ObjectSecurity(bool isContainer, bool isDS);
+        protected ObjectSecurity(CommonSecurityDescriptor securityDescriptor);
+        public abstract Type AccessRightType { get; }
+        protected bool AccessRulesModified { get; set; }
+        public abstract Type AccessRuleType { get; }
+        public bool AreAccessRulesCanonical { get; }
+        public bool AreAccessRulesProtected { get; }
+        public bool AreAuditRulesCanonical { get; }
+        public bool AreAuditRulesProtected { get; }
+        protected bool AuditRulesModified { get; set; }
+        public abstract Type AuditRuleType { get; }
+        protected bool GroupModified { get; set; }
+        protected bool IsContainer { get; }
+        protected bool IsDS { get; }
+        protected bool OwnerModified { get; set; }
+        public abstract AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public abstract AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public IdentityReference GetGroup(Type targetType);
+        public IdentityReference GetOwner(Type targetType);
+        public byte[] GetSecurityDescriptorBinaryForm();
+        public string GetSecurityDescriptorSddlForm(AccessControlSections includeSections);
+        public static bool IsSddlConversionSupported();
+        protected abstract bool ModifyAccess(AccessControlModification modification, AccessRule rule, out bool modified);
+        public virtual bool ModifyAccessRule(AccessControlModification modification, AccessRule rule, out bool modified);
+        protected abstract bool ModifyAudit(AccessControlModification modification, AuditRule rule, out bool modified);
+        public virtual bool ModifyAuditRule(AccessControlModification modification, AuditRule rule, out bool modified);
+        protected virtual void Persist(bool enableOwnershipPrivilege, string name, AccessControlSections includeSections);
+        protected virtual void Persist(SafeHandle handle, AccessControlSections includeSections);
+        protected virtual void Persist(string name, AccessControlSections includeSections);
+        public virtual void PurgeAccessRules(IdentityReference identity);
+        public virtual void PurgeAuditRules(IdentityReference identity);
+        protected void ReadLock();
+        protected void ReadUnlock();
+        public void SetAccessRuleProtection(bool isProtected, bool preserveInheritance);
+        public void SetAuditRuleProtection(bool isProtected, bool preserveInheritance);
+        public void SetGroup(IdentityReference identity);
+        public void SetOwner(IdentityReference identity);
+        public void SetSecurityDescriptorBinaryForm(byte[] binaryForm);
+        public void SetSecurityDescriptorBinaryForm(byte[] binaryForm, AccessControlSections includeSections);
+        public void SetSecurityDescriptorSddlForm(string sddlForm);
+        public void SetSecurityDescriptorSddlForm(string sddlForm, AccessControlSections includeSections);
+        protected void WriteLock();
+        protected void WriteUnlock();
+    }
+    public abstract class ObjectSecurity<T> : NativeObjectSecurity where T : struct {
+        protected ObjectSecurity(bool isContainer, ResourceType resourceType);
+        protected ObjectSecurity(bool isContainer, ResourceType resourceType, SafeHandle safeHandle, AccessControlSections includeSections);
+        protected ObjectSecurity(bool isContainer, ResourceType resourceType, SafeHandle safeHandle, AccessControlSections includeSections, NativeObjectSecurity.ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
+        protected ObjectSecurity(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections);
+        protected ObjectSecurity(bool isContainer, ResourceType resourceType, string name, AccessControlSections includeSections, NativeObjectSecurity.ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
+        public override Type AccessRightType { get; }
+        public override Type AccessRuleType { get; }
+        public override Type AuditRuleType { get; }
+        public override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public virtual void AddAccessRule(AccessRule<T> rule);
+        public virtual void AddAuditRule(AuditRule<T> rule);
+        public override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        protected internal void Persist(SafeHandle handle);
+        protected internal void Persist(string name);
+        public virtual bool RemoveAccessRule(AccessRule<T> rule);
+        public virtual void RemoveAccessRuleAll(AccessRule<T> rule);
+        public virtual void RemoveAccessRuleSpecific(AccessRule<T> rule);
+        public virtual bool RemoveAuditRule(AuditRule<T> rule);
+        public virtual void RemoveAuditRuleAll(AuditRule<T> rule);
+        public virtual void RemoveAuditRuleSpecific(AuditRule<T> rule);
+        public virtual void ResetAccessRule(AccessRule<T> rule);
+        public virtual void SetAccessRule(AccessRule<T> rule);
+        public virtual void SetAuditRule(AuditRule<T> rule);
+    }
+    public sealed class PrivilegeNotHeldException : UnauthorizedAccessException, ISerializable {
+        public PrivilegeNotHeldException();
+        public PrivilegeNotHeldException(string privilege);
+        public PrivilegeNotHeldException(string privilege, Exception inner);
+        public string PrivilegeName { get; }
+        public override void GetObjectData(SerializationInfo info, StreamingContext context);
+    }
+    public enum PropagationFlags {
+        InheritOnly = 2,
+        None = 0,
+        NoPropagateInherit = 1,
+    }
+    public abstract class QualifiedAce : KnownAce {
+        public AceQualifier AceQualifier { get; }
+        public bool IsCallback { get; }
+        public int OpaqueLength { get; }
+        public byte[] GetOpaque();
+        public void SetOpaque(byte[] opaque);
+    }
+    public sealed class RawAcl : GenericAcl {
+        public RawAcl(byte revision, int capacity);
+        public RawAcl(byte[] binaryForm, int offset);
+        public override int BinaryLength { get; }
+        public override int Count { get; }
+        public override GenericAce this[int index] { get; set; }
+        public override byte Revision { get; }
+        public override void GetBinaryForm(byte[] binaryForm, int offset);
+        public void InsertAce(int index, GenericAce ace);
+        public void RemoveAce(int index);
+    }
+    public sealed class RawSecurityDescriptor : GenericSecurityDescriptor {
+        public RawSecurityDescriptor(byte[] binaryForm, int offset);
+        public RawSecurityDescriptor(ControlFlags flags, SecurityIdentifier owner, SecurityIdentifier group, RawAcl systemAcl, RawAcl discretionaryAcl);
+        public RawSecurityDescriptor(string sddlForm);
+        public override ControlFlags ControlFlags { get; }
+        public RawAcl DiscretionaryAcl { get; set; }
+        public override SecurityIdentifier Group { get; set; }
+        public override SecurityIdentifier Owner { get; set; }
+        public byte ResourceManagerControl { get; set; }
+        public RawAcl SystemAcl { get; set; }
+        public void SetFlags(ControlFlags flags);
+    }
+    public sealed class RegistryAccessRule : AccessRule {
+        public RegistryAccessRule(IdentityReference identity, RegistryRights registryRights, AccessControlType type);
+        public RegistryAccessRule(IdentityReference identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public RegistryAccessRule(string identity, RegistryRights registryRights, AccessControlType type);
+        public RegistryAccessRule(string identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public RegistryRights RegistryRights { get; }
+    }
+    public sealed class RegistryAuditRule : AuditRule {
+        public RegistryAuditRule(IdentityReference identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public RegistryAuditRule(string identity, RegistryRights registryRights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public RegistryRights RegistryRights { get; }
+    }
+    public enum RegistryRights {
+        ChangePermissions = 262144,
+        CreateLink = 32,
+        CreateSubKey = 4,
+        Delete = 65536,
+        EnumerateSubKeys = 8,
+        ExecuteKey = 131097,
+        FullControl = 983103,
+        Notify = 16,
+        QueryValues = 1,
+        ReadKey = 131097,
+        ReadPermissions = 131072,
+        SetValue = 2,
+        TakeOwnership = 524288,
+        WriteKey = 131078,
+    }
+    public sealed class RegistrySecurity : NativeObjectSecurity {
+        public RegistrySecurity();
+        public override Type AccessRightType { get; }
+        public override Type AccessRuleType { get; }
+        public override Type AuditRuleType { get; }
+        public override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public void AddAccessRule(RegistryAccessRule rule);
+        public void AddAuditRule(RegistryAuditRule rule);
+        public override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public bool RemoveAccessRule(RegistryAccessRule rule);
+        public void RemoveAccessRuleAll(RegistryAccessRule rule);
+        public void RemoveAccessRuleSpecific(RegistryAccessRule rule);
+        public bool RemoveAuditRule(RegistryAuditRule rule);
+        public void RemoveAuditRuleAll(RegistryAuditRule rule);
+        public void RemoveAuditRuleSpecific(RegistryAuditRule rule);
+        public void ResetAccessRule(RegistryAccessRule rule);
+        public void SetAccessRule(RegistryAccessRule rule);
+        public void SetAuditRule(RegistryAuditRule rule);
+    }
+    public enum ResourceType {
+        DSObject = 8,
+        DSObjectAll = 9,
+        FileObject = 1,
+        KernelObject = 6,
+        LMShare = 5,
+        Printer = 3,
+        ProviderDefined = 10,
+        RegistryKey = 4,
+        RegistryWow6432Key = 12,
+        Service = 2,
+        Unknown = 0,
+        WindowObject = 7,
+        WmiGuidObject = 11,
+    }
+    public enum SecurityInfos {
+        DiscretionaryAcl = 4,
+        Group = 2,
+        Owner = 1,
+        SystemAcl = 8,
+    }
+    public sealed class SemaphoreAccessRule : AccessRule {
+        public SemaphoreAccessRule(IdentityReference identity, SemaphoreRights eventRights, AccessControlType type);
+        public SemaphoreAccessRule(string identity, SemaphoreRights eventRights, AccessControlType type);
+        public SemaphoreRights SemaphoreRights { get; }
+    }
+    public sealed class SemaphoreAuditRule : AuditRule {
+        public SemaphoreAuditRule(IdentityReference identity, SemaphoreRights eventRights, AuditFlags flags);
+        public SemaphoreRights SemaphoreRights { get; }
+    }
+    public enum SemaphoreRights {
+        ChangePermissions = 262144,
+        Delete = 65536,
+        FullControl = 2031619,
+        Modify = 2,
+        ReadPermissions = 131072,
+        Synchronize = 1048576,
+        TakeOwnership = 524288,
+    }
+    public sealed class SemaphoreSecurity : NativeObjectSecurity {
+        public SemaphoreSecurity();
+        public SemaphoreSecurity(string name, AccessControlSections includeSections);
+        public override Type AccessRightType { get; }
+        public override Type AccessRuleType { get; }
+        public override Type AuditRuleType { get; }
+        public override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
+        public void AddAccessRule(SemaphoreAccessRule rule);
+        public void AddAuditRule(SemaphoreAuditRule rule);
+        public override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
+        public bool RemoveAccessRule(SemaphoreAccessRule rule);
+        public void RemoveAccessRuleAll(SemaphoreAccessRule rule);
+        public void RemoveAccessRuleSpecific(SemaphoreAccessRule rule);
+        public bool RemoveAuditRule(SemaphoreAuditRule rule);
+        public void RemoveAuditRuleAll(SemaphoreAuditRule rule);
+        public void RemoveAuditRuleSpecific(SemaphoreAuditRule rule);
+        public void ResetAccessRule(SemaphoreAccessRule rule);
+        public void SetAccessRule(SemaphoreAccessRule rule);
+        public void SetAuditRule(SemaphoreAuditRule rule);
+    }
+    public sealed class SystemAcl : CommonAcl {
+        public SystemAcl(bool isContainer, bool isDS, byte revision, int capacity);
+        public SystemAcl(bool isContainer, bool isDS, int capacity);
+        public SystemAcl(bool isContainer, bool isDS, RawAcl rawAcl);
+        public void AddAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
+        public void AddAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
+        public void AddAudit(SecurityIdentifier sid, ObjectAuditRule rule);
+        public bool RemoveAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
+        public bool RemoveAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
+        public bool RemoveAudit(SecurityIdentifier sid, ObjectAuditRule rule);
+        public void RemoveAuditSpecific(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
+        public void RemoveAuditSpecific(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
+        public void RemoveAuditSpecific(SecurityIdentifier sid, ObjectAuditRule rule);
+        public void SetAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags);
+        public void SetAudit(AuditFlags auditFlags, SecurityIdentifier sid, int accessMask, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, ObjectAceFlags objectFlags, Guid objectType, Guid inheritedObjectType);
+        public void SetAudit(SecurityIdentifier sid, ObjectAuditRule rule);
+    }
+}
 namespace System.Security.Cryptography {
+    public sealed class AesCng : Aes {
+        public AesCng();
+        public AesCng(string keyName);
+        public AesCng(string keyName, CngProvider provider);
+        public AesCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
+        public override byte[] Key { get; set; }
+        public override int KeySize { get; set; }
+        public override ICryptoTransform CreateDecryptor();
+        public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
+        public override ICryptoTransform CreateEncryptor();
+        public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
+        public override void GenerateIV();
+        public override void GenerateKey();
+    }
+    public sealed class CngAlgorithm : IEquatable<CngAlgorithm> {
+        public CngAlgorithm(string algorithm);
+        public string Algorithm { get; }
+        public static CngAlgorithm ECDiffieHellman { get; }
+        public static CngAlgorithm ECDiffieHellmanP256 { get; }
+        public static CngAlgorithm ECDiffieHellmanP384 { get; }
+        public static CngAlgorithm ECDiffieHellmanP521 { get; }
+        public static CngAlgorithm ECDsa { get; }
+        public static CngAlgorithm ECDsaP256 { get; }
+        public static CngAlgorithm ECDsaP384 { get; }
+        public static CngAlgorithm ECDsaP521 { get; }
+        public static CngAlgorithm MD5 { get; }
+        public static CngAlgorithm Rsa { get; }
+        public static CngAlgorithm Sha1 { get; }
+        public static CngAlgorithm Sha256 { get; }
+        public static CngAlgorithm Sha384 { get; }
+        public static CngAlgorithm Sha512 { get; }
+        public bool Equals(CngAlgorithm other);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static bool operator ==(CngAlgorithm left, CngAlgorithm right);
+        public static bool operator !=(CngAlgorithm left, CngAlgorithm right);
+        public override string ToString();
+    }
+    public sealed class CngAlgorithmGroup : IEquatable<CngAlgorithmGroup> {
+        public CngAlgorithmGroup(string algorithmGroup);
+        public string AlgorithmGroup { get; }
+        public static CngAlgorithmGroup DiffieHellman { get; }
+        public static CngAlgorithmGroup Dsa { get; }
+        public static CngAlgorithmGroup ECDiffieHellman { get; }
+        public static CngAlgorithmGroup ECDsa { get; }
+        public static CngAlgorithmGroup Rsa { get; }
+        public bool Equals(CngAlgorithmGroup other);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static bool operator ==(CngAlgorithmGroup left, CngAlgorithmGroup right);
+        public static bool operator !=(CngAlgorithmGroup left, CngAlgorithmGroup right);
+        public override string ToString();
+    }
+    public enum CngExportPolicies {
+        AllowArchiving = 4,
+        AllowExport = 1,
+        AllowPlaintextArchiving = 8,
+        AllowPlaintextExport = 2,
+        None = 0,
+    }
+    public sealed class CngKey : IDisposable {
+        public CngAlgorithm Algorithm { get; }
+        public CngAlgorithmGroup AlgorithmGroup { get; }
+        public CngExportPolicies ExportPolicy { get; }
+        public SafeNCryptKeyHandle Handle { get; }
+        public bool IsEphemeral { get; }
+        public bool IsMachineKey { get; }
+        public string KeyName { get; }
+        public int KeySize { get; }
+        public CngKeyUsages KeyUsage { get; }
+        public IntPtr ParentWindowHandle { get; set; }
+        public CngProvider Provider { get; }
+        public SafeNCryptProviderHandle ProviderHandle { get; }
+        public CngUIPolicy UIPolicy { get; }
+        public string UniqueName { get; }
+        public static CngKey Create(CngAlgorithm algorithm);
+        public static CngKey Create(CngAlgorithm algorithm, string keyName);
+        public static CngKey Create(CngAlgorithm algorithm, string keyName, CngKeyCreationParameters creationParameters);
+        public void Delete();
+        public void Dispose();
+        public static bool Exists(string keyName);
+        public static bool Exists(string keyName, CngProvider provider);
+        public static bool Exists(string keyName, CngProvider provider, CngKeyOpenOptions options);
+        public byte[] Export(CngKeyBlobFormat format);
+        public CngProperty GetProperty(string name, CngPropertyOptions options);
+        public bool HasProperty(string name, CngPropertyOptions options);
+        public static CngKey Import(byte[] keyBlob, CngKeyBlobFormat format);
+        public static CngKey Import(byte[] keyBlob, CngKeyBlobFormat format, CngProvider provider);
+        public static CngKey Open(SafeNCryptKeyHandle keyHandle, CngKeyHandleOpenOptions keyHandleOpenOptions);
+        public static CngKey Open(string keyName);
+        public static CngKey Open(string keyName, CngProvider provider);
+        public static CngKey Open(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
+        public void SetProperty(CngProperty property);
+    }
+    public sealed class CngKeyBlobFormat : IEquatable<CngKeyBlobFormat> {
+        public CngKeyBlobFormat(string format);
+        public static CngKeyBlobFormat EccFullPrivateBlob { get; }
+        public static CngKeyBlobFormat EccFullPublicBlob { get; }
+        public static CngKeyBlobFormat EccPrivateBlob { get; }
+        public static CngKeyBlobFormat EccPublicBlob { get; }
+        public string Format { get; }
+        public static CngKeyBlobFormat GenericPrivateBlob { get; }
+        public static CngKeyBlobFormat GenericPublicBlob { get; }
+        public static CngKeyBlobFormat OpaqueTransportBlob { get; }
+        public static CngKeyBlobFormat Pkcs8PrivateBlob { get; }
+        public bool Equals(CngKeyBlobFormat other);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static bool operator ==(CngKeyBlobFormat left, CngKeyBlobFormat right);
+        public static bool operator !=(CngKeyBlobFormat left, CngKeyBlobFormat right);
+        public override string ToString();
+    }
+    public enum CngKeyCreationOptions {
+        MachineKey = 32,
+        None = 0,
+        OverwriteExistingKey = 128,
+    }
+    public sealed class CngKeyCreationParameters {
+        public CngKeyCreationParameters();
+        public Nullable<CngExportPolicies> ExportPolicy { get; set; }
+        public CngKeyCreationOptions KeyCreationOptions { get; set; }
+        public Nullable<CngKeyUsages> KeyUsage { get; set; }
+        public CngPropertyCollection Parameters { get; }
+        public IntPtr ParentWindowHandle { get; set; }
+        public CngProvider Provider { get; set; }
+        public CngUIPolicy UIPolicy { get; set; }
+    }
+    public enum CngKeyHandleOpenOptions {
+        EphemeralKey = 1,
+        None = 0,
+    }
+    public enum CngKeyOpenOptions {
+        MachineKey = 32,
+        None = 0,
+        Silent = 64,
+        UserKey = 0,
+    }
+    public enum CngKeyUsages {
+        AllUsages = 16777215,
+        Decryption = 1,
+        KeyAgreement = 4,
+        None = 0,
+        Signing = 2,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct CngProperty : IEquatable<CngProperty> {
+        public CngProperty(string name, byte[] value, CngPropertyOptions options);
+        public string Name { get; }
+        public CngPropertyOptions Options { get; }
+        public bool Equals(CngProperty other);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public byte[] GetValue();
+        public static bool operator ==(CngProperty left, CngProperty right);
+        public static bool operator !=(CngProperty left, CngProperty right);
+    }
+    public sealed class CngPropertyCollection : Collection<CngProperty> {
+        public CngPropertyCollection();
+    }
+    public enum CngPropertyOptions {
+        CustomProperty = 1073741824,
+        None = 0,
+        Persist = -2147483648,
+    }
+    public sealed class CngProvider : IEquatable<CngProvider> {
+        public CngProvider(string provider);
+        public static CngProvider MicrosoftSmartCardKeyStorageProvider { get; }
+        public static CngProvider MicrosoftSoftwareKeyStorageProvider { get; }
+        public string Provider { get; }
+        public bool Equals(CngProvider other);
+        public override bool Equals(object obj);
+        public override int GetHashCode();
+        public static bool operator ==(CngProvider left, CngProvider right);
+        public static bool operator !=(CngProvider left, CngProvider right);
+        public override string ToString();
+    }
+    public sealed class CngUIPolicy {
+        public CngUIPolicy(CngUIProtectionLevels protectionLevel);
+        public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName);
+        public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description);
+        public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext);
+        public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext, string creationTitle);
+        public string CreationTitle { get; }
+        public string Description { get; }
+        public string FriendlyName { get; }
+        public CngUIProtectionLevels ProtectionLevel { get; }
+        public string UseContext { get; }
+    }
+    public enum CngUIProtectionLevels {
+        ForceHighProtection = 2,
+        None = 0,
+        ProtectKey = 1,
+    }
+    public sealed class CryptographicAttributeObject {
+        public CryptographicAttributeObject(Oid oid);
+        public CryptographicAttributeObject(Oid oid, AsnEncodedDataCollection values);
+        public Oid Oid { get; }
+        public AsnEncodedDataCollection Values { get; }
+    }
+    public sealed class CryptographicAttributeObjectCollection : ICollection, IEnumerable {
+        public CryptographicAttributeObjectCollection();
+        public CryptographicAttributeObjectCollection(CryptographicAttributeObject attribute);
+        public int Count { get; }
+        public CryptographicAttributeObject this[int index] { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public int Add(AsnEncodedData asnEncodedData);
+        public int Add(CryptographicAttributeObject attribute);
+        public void CopyTo(CryptographicAttributeObject[] array, int index);
+        public CryptographicAttributeObjectEnumerator GetEnumerator();
+        public void Remove(CryptographicAttributeObject attribute);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public sealed class CryptographicAttributeObjectEnumerator : IEnumerator {
+        public CryptographicAttributeObject Current { get; }
+        object System.Collections.IEnumerator.Current { get; }
+        public bool MoveNext();
+        public void Reset();
+    }
+    public static class CryptographicOperations {
+        public static bool FixedTimeEquals(ReadOnlySpan<byte> left, ReadOnlySpan<byte> right);
+        public static void ZeroMemory(Span<byte> buffer);
+    }
     public class CryptoStream : Stream, IDisposable {
+        public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state);
+        public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state);
+        public override int EndRead(IAsyncResult asyncResult);
+        public override void EndWrite(IAsyncResult asyncResult);
     }
+    public enum DataProtectionScope {
+        CurrentUser = 0,
+        LocalMachine = 1,
+    }
     public abstract class DSA : AsymmetricAlgorithm {
+        public virtual bool TryCreateSignature(ReadOnlySpan<byte> hash, Span<byte> destination, out int bytesWritten);
+        protected virtual bool TryHashData(ReadOnlySpan<byte> data, Span<byte> destination, HashAlgorithmName hashAlgorithm, out int bytesWritten);
+        public virtual bool TrySignData(ReadOnlySpan<byte> data, Span<byte> destination, HashAlgorithmName hashAlgorithm, out int bytesWritten);
+        public virtual bool VerifyData(ReadOnlySpan<byte> data, ReadOnlySpan<byte> signature, HashAlgorithmName hashAlgorithm);
+        public virtual bool VerifySignature(ReadOnlySpan<byte> hash, ReadOnlySpan<byte> signature);
     }
+    public sealed class DSACng : DSA {
+        public DSACng();
+        public DSACng(CngKey key);
+        public DSACng(int keySize);
+        public CngKey Key { get; }
+        public override string KeyExchangeAlgorithm { get; }
+        public override KeySizes[] LegalKeySizes { get; }
+        public override string SignatureAlgorithm { get; }
+        public override byte[] CreateSignature(byte[] rgbHash);
+        public override DSAParameters ExportParameters(bool includePrivateParameters);
+        public override void ImportParameters(DSAParameters parameters);
+        public override bool VerifySignature(byte[] rgbHash, byte[] rgbSignature);
+    }
+    public sealed class DSAOpenSsl : DSA {
+        public DSAOpenSsl();
+        public DSAOpenSsl(DSAParameters parameters);
+        public DSAOpenSsl(int keySize);
+        public DSAOpenSsl(IntPtr handle);
+        public DSAOpenSsl(SafeEvpPKeyHandle pkeyHandle);
+        public override int KeySize { set; }
+        public override KeySizes[] LegalKeySizes { get; }
+        public override byte[] CreateSignature(byte[] rgbHash);
+        public SafeEvpPKeyHandle DuplicateKeyHandle();
+        public override DSAParameters ExportParameters(bool includePrivateParameters);
+        public override void ImportParameters(DSAParameters parameters);
+        public override bool VerifySignature(byte[] rgbHash, byte[] rgbSignature);
+    }
+    public abstract class ECDiffieHellman : AsymmetricAlgorithm {
+        protected ECDiffieHellman();
+        public override string KeyExchangeAlgorithm { get; }
+        public abstract ECDiffieHellmanPublicKey PublicKey { get; }
+        public override string SignatureAlgorithm { get; }
+        public static ECDiffieHellman Create();
+        public static ECDiffieHellman Create(ECCurve curve);
+        public static ECDiffieHellman Create(ECParameters parameters);
+        public static ECDiffieHellman Create(string algorithm);
+        public byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm);
+        public virtual byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, byte[] secretPrepend, byte[] secretAppend);
+        public byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, byte[] hmacKey);
+        public virtual byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, byte[] hmacKey, byte[] secretPrepend, byte[] secretAppend);
+        public virtual byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey);
+        public virtual byte[] DeriveKeyTls(ECDiffieHellmanPublicKey otherPartyPublicKey, byte[] prfLabel, byte[] prfSeed);
+        public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
+        public virtual ECParameters ExportParameters(bool includePrivateParameters);
+        public override void FromXmlString(string xmlString);
+        public virtual void GenerateKey(ECCurve curve);
+        public virtual void ImportParameters(ECParameters parameters);
+        public override string ToXmlString(bool includePrivateParameters);
+    }
+    public sealed class ECDiffieHellmanCng : ECDiffieHellman {
+        public ECDiffieHellmanCng();
+        public ECDiffieHellmanCng(CngKey key);
+        public ECDiffieHellmanCng(ECCurve curve);
+        public ECDiffieHellmanCng(int keySize);
+        public CngAlgorithm HashAlgorithm { get; set; }
+        public byte[] HmacKey { get; set; }
+        public CngKey Key { get; }
+        public ECDiffieHellmanKeyDerivationFunction KeyDerivationFunction { get; set; }
+        public override int KeySize { get; set; }
+        public byte[] Label { get; set; }
+        public override ECDiffieHellmanPublicKey PublicKey { get; }
+        public byte[] SecretAppend { get; set; }
+        public byte[] SecretPrepend { get; set; }
+        public byte[] Seed { get; set; }
+        public bool UseSecretAgreementAsHmacKey { get; }
+        public override byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, byte[] secretPrepend, byte[] secretAppend);
+        public override byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, byte[] hmacKey, byte[] secretPrepend, byte[] secretAppend);
+        public byte[] DeriveKeyMaterial(CngKey otherPartyPublicKey);
+        public override byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey);
+        public override byte[] DeriveKeyTls(ECDiffieHellmanPublicKey otherPartyPublicKey, byte[] prfLabel, byte[] prfSeed);
+        public SafeNCryptSecretHandle DeriveSecretAgreementHandle(CngKey otherPartyPublicKey);
+        public SafeNCryptSecretHandle DeriveSecretAgreementHandle(ECDiffieHellmanPublicKey otherPartyPublicKey);
+        public override ECParameters ExportExplicitParameters(bool includePrivateParameters);
+        public override ECParameters ExportParameters(bool includePrivateParameters);
+        public void FromXmlString(string xml, ECKeyXmlFormat format);
+        public override void GenerateKey(ECCurve curve);
+        public override void ImportParameters(ECParameters parameters);
+        public string ToXmlString(ECKeyXmlFormat format);
+    }
+    public sealed class ECDiffieHellmanCngPublicKey : ECDiffieHellmanPublicKey {
+        public CngKeyBlobFormat BlobFormat { get; }
+        public override ECParameters ExportExplicitParameters();
+        public override ECParameters ExportParameters();
+        public static ECDiffieHellmanPublicKey FromByteArray(byte[] publicKeyBlob, CngKeyBlobFormat format);
+        public static ECDiffieHellmanCngPublicKey FromXmlString(string xml);
+        public CngKey Import();
+        public override string ToXmlString();
+    }
+    public enum ECDiffieHellmanKeyDerivationFunction {
+        Hash = 0,
+        Hmac = 1,
+        Tls = 2,
+    }
+    public sealed class ECDiffieHellmanOpenSsl : ECDiffieHellman {
+        public ECDiffieHellmanOpenSsl();
+        public ECDiffieHellmanOpenSsl(ECCurve curve);
+        public ECDiffieHellmanOpenSsl(int keySize);
+        public ECDiffieHellmanOpenSsl(IntPtr handle);
+        public ECDiffieHellmanOpenSsl(SafeEvpPKeyHandle pkeyHandle);
+        public override ECDiffieHellmanPublicKey PublicKey { get; }
+        public override byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, byte[] secretPrepend, byte[] secretAppend);
+        public override byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, byte[] hmacKey, byte[] secretPrepend, byte[] secretAppend);
+        public override byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey);
+        public override byte[] DeriveKeyTls(ECDiffieHellmanPublicKey otherPartyPublicKey, byte[] prfLabel, byte[] prfSeed);
+        public SafeEvpPKeyHandle DuplicateKeyHandle();
+        public override ECParameters ExportExplicitParameters(bool includePrivateParameters);
+        public override ECParameters ExportParameters(bool includePrivateParameters);
+        public override void GenerateKey(ECCurve curve);
+        public override void ImportParameters(ECParameters parameters);
+    }
     public abstract class ECDiffieHellmanPublicKey : IDisposable {
+        protected ECDiffieHellmanPublicKey();
+        public virtual ECParameters ExportExplicitParameters();
+        public virtual ECParameters ExportParameters();
     }
     public abstract class ECDsa : AsymmetricAlgorithm {
+        protected virtual bool TryHashData(ReadOnlySpan<byte> data, Span<byte> destination, HashAlgorithmName hashAlgorithm, out int bytesWritten);
+        public virtual bool TrySignData(ReadOnlySpan<byte> data, Span<byte> destination, HashAlgorithmName hashAlgorithm, out int bytesWritten);
+        public virtual bool TrySignHash(ReadOnlySpan<byte> hash, Span<byte> destination, out int bytesWritten);
+        public virtual bool VerifyData(ReadOnlySpan<byte> data, ReadOnlySpan<byte> signature, HashAlgorithmName hashAlgorithm);
+        public virtual bool VerifyHash(ReadOnlySpan<byte> hash, ReadOnlySpan<byte> signature);
     }
+    public sealed class ECDsaCng : ECDsa {
+        public ECDsaCng();
+        public ECDsaCng(CngKey key);
+        public ECDsaCng(ECCurve curve);
+        public ECDsaCng(int keySize);
+        public CngAlgorithm HashAlgorithm { get; set; }
+        public CngKey Key { get; }
+        public override int KeySize { get; set; }
+        public override KeySizes[] LegalKeySizes { get; }
+        public override ECParameters ExportExplicitParameters(bool includePrivateParameters);
+        public override ECParameters ExportParameters(bool includePrivateParameters);
+        public void FromXmlString(string xml, ECKeyXmlFormat format);
+        public override void GenerateKey(ECCurve curve);
+        public override void ImportParameters(ECParameters parameters);
+        public byte[] SignData(byte[] data);
+        public byte[] SignData(byte[] data, int offset, int count);
+        public byte[] SignData(Stream data);
+        public override byte[] SignHash(byte[] hash);
+        public string ToXmlString(ECKeyXmlFormat format);
+        public bool VerifyData(byte[] data, byte[] signature);
+        public bool VerifyData(byte[] data, int offset, int count, byte[] signature);
+        public bool VerifyData(Stream data, byte[] signature);
+        public override bool VerifyHash(byte[] hash, byte[] signature);
+    }
+    public sealed class ECDsaOpenSsl : ECDsa {
+        public ECDsaOpenSsl();
+        public ECDsaOpenSsl(ECCurve curve);
+        public ECDsaOpenSsl(int keySize);
+        public ECDsaOpenSsl(IntPtr handle);
+        public ECDsaOpenSsl(SafeEvpPKeyHandle pkeyHandle);
+        public override int KeySize { get; set; }
+        public override KeySizes[] LegalKeySizes { get; }
+        public SafeEvpPKeyHandle DuplicateKeyHandle();
+        public override ECParameters ExportExplicitParameters(bool includePrivateParameters);
+        public override ECParameters ExportParameters(bool includePrivateParameters);
+        public override void GenerateKey(ECCurve curve);
+        public override void ImportParameters(ECParameters parameters);
+        public override byte[] SignHash(byte[] hash);
+        public override bool VerifyHash(byte[] hash, byte[] signature);
+    }
+    public enum ECKeyXmlFormat {
+        Rfc4050 = 0,
+    }
     public abstract class HashAlgorithm : ICryptoTransform, IDisposable {
+        protected virtual void HashCore(ReadOnlySpan<byte> source);
+        public bool TryComputeHash(ReadOnlySpan<byte> source, Span<byte> destination, out int bytesWritten);
+        protected virtual bool TryHashFinal(Span<byte> destination, out int bytesWritten);
     }
     public abstract class HMAC : KeyedHashAlgorithm {
+        protected override void HashCore(ReadOnlySpan<byte> source);
+        protected override bool TryHashFinal(Span<byte> destination, out int bytesWritten);
     }
     public class HMACMD5 : HMAC {
+        protected override void HashCore(ReadOnlySpan<byte> source);
+        protected override bool TryHashFinal(Span<byte> destination, out int bytesWritten);
     }
     public class HMACSHA1 : HMAC {
+        protected override void HashCore(ReadOnlySpan<byte> source);
+        protected override bool TryHashFinal(Span<byte> destination, out int bytesWritten);
     }
     public class HMACSHA256 : HMAC {
+        protected override void HashCore(ReadOnlySpan<byte> source);
+        protected override bool TryHashFinal(Span<byte> destination, out int bytesWritten);
     }
     public class HMACSHA384 : HMAC {
+        protected override void HashCore(ReadOnlySpan<byte> source);
+        protected override bool TryHashFinal(Span<byte> destination, out int bytesWritten);
     }
     public class HMACSHA512 : HMAC {
+        protected override void HashCore(ReadOnlySpan<byte> source);
+        protected override bool TryHashFinal(Span<byte> destination, out int bytesWritten);
     }
     public sealed class IncrementalHash : IDisposable {
+        public void AppendData(ReadOnlySpan<byte> data);
+        public bool TryGetHashAndReset(Span<byte> destination, out int bytesWritten);
     }
+    public static class ProtectedData {
+        public static byte[] Protect(byte[] userData, byte[] optionalEntropy, DataProtectionScope scope);
+        public static byte[] Unprotect(byte[] encryptedData, byte[] optionalEntropy, DataProtectionScope scope);
+    }
     public abstract class RandomNumberGenerator : IDisposable {
+        public static void Fill(Span<byte> data);
+        public virtual void GetBytes(Span<byte> data);
+        public virtual void GetNonZeroBytes(Span<byte> data);
     }
     public abstract class RSA : AsymmetricAlgorithm {
+        public virtual bool TryDecrypt(ReadOnlySpan<byte> data, Span<byte> destination, RSAEncryptionPadding padding, out int bytesWritten);
+        public virtual bool TryEncrypt(ReadOnlySpan<byte> data, Span<byte> destination, RSAEncryptionPadding padding, out int bytesWritten);
+        protected virtual bool TryHashData(ReadOnlySpan<byte> data, Span<byte> destination, HashAlgorithmName hashAlgorithm, out int bytesWritten);
+        public virtual bool TrySignData(ReadOnlySpan<byte> data, Span<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, out int bytesWritten);
+        public virtual bool TrySignHash(ReadOnlySpan<byte> hash, Span<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, out int bytesWritten);
+        public virtual bool VerifyData(ReadOnlySpan<byte> data, ReadOnlySpan<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
+        public virtual bool VerifyHash(ReadOnlySpan<byte> hash, ReadOnlySpan<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
     }
+    public sealed class RSACng : RSA {
+        public RSACng();
+        public RSACng(CngKey key);
+        public RSACng(int keySize);
+        public CngKey Key { get; }
+        public override KeySizes[] LegalKeySizes { get; }
+        public override byte[] Decrypt(byte[] data, RSAEncryptionPadding padding);
+        public override byte[] Encrypt(byte[] data, RSAEncryptionPadding padding);
+        public override RSAParameters ExportParameters(bool includePrivateParameters);
+        public override void ImportParameters(RSAParameters parameters);
+        public override byte[] SignHash(byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
+        public override bool VerifyHash(byte[] hash, byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
+    }
+    public sealed class RSAOpenSsl : RSA {
+        public RSAOpenSsl();
+        public RSAOpenSsl(int keySize);
+        public RSAOpenSsl(IntPtr handle);
+        public RSAOpenSsl(RSAParameters parameters);
+        public RSAOpenSsl(SafeEvpPKeyHandle pkeyHandle);
+        public override int KeySize { set; }
+        public override KeySizes[] LegalKeySizes { get; }
+        public override byte[] Decrypt(byte[] data, RSAEncryptionPadding padding);
+        public SafeEvpPKeyHandle DuplicateKeyHandle();
+        public override byte[] Encrypt(byte[] data, RSAEncryptionPadding padding);
+        public override RSAParameters ExportParameters(bool includePrivateParameters);
+        public override void ImportParameters(RSAParameters parameters);
+        public override byte[] SignHash(byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
+        public override bool VerifyHash(byte[] hash, byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
+    }
+    public sealed class SafeEvpPKeyHandle : SafeHandle {
+        public SafeEvpPKeyHandle(IntPtr handle, bool ownsHandle);
+        public override bool IsInvalid { get; }
+        public SafeEvpPKeyHandle DuplicateHandle();
+    }
+    public sealed class TripleDESCng : TripleDES {
+        public TripleDESCng();
+        public TripleDESCng(string keyName);
+        public TripleDESCng(string keyName, CngProvider provider);
+        public TripleDESCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
+        public override byte[] Key { get; set; }
+        public override int KeySize { get; set; }
+        public override ICryptoTransform CreateDecryptor();
+        public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
+        public override ICryptoTransform CreateEncryptor();
+        public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
+        public override void GenerateIV();
+        public override void GenerateKey();
+    }
 }
+namespace System.Security.Cryptography.Pkcs {
+    public sealed class AlgorithmIdentifier {
+        public AlgorithmIdentifier();
+        public AlgorithmIdentifier(Oid oid);
+        public AlgorithmIdentifier(Oid oid, int keyLength);
+        public int KeyLength { get; set; }
+        public Oid Oid { get; set; }
+    }
+    public sealed class CmsRecipient {
+        public CmsRecipient(SubjectIdentifierType recipientIdentifierType, X509Certificate2 certificate);
+        public CmsRecipient(X509Certificate2 certificate);
+        public X509Certificate2 Certificate { get; }
+        public SubjectIdentifierType RecipientIdentifierType { get; }
+    }
+    public sealed class CmsRecipientCollection : ICollection, IEnumerable {
+        public CmsRecipientCollection();
+        public CmsRecipientCollection(CmsRecipient recipient);
+        public CmsRecipientCollection(SubjectIdentifierType recipientIdentifierType, X509Certificate2Collection certificates);
+        public int Count { get; }
+        public CmsRecipient this[int index] { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public int Add(CmsRecipient recipient);
+        public void CopyTo(Array array, int index);
+        public void CopyTo(CmsRecipient[] array, int index);
+        public CmsRecipientEnumerator GetEnumerator();
+        public void Remove(CmsRecipient recipient);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public sealed class CmsRecipientEnumerator : IEnumerator {
+        public CmsRecipient Current { get; }
+        object System.Collections.IEnumerator.Current { get; }
+        public bool MoveNext();
+        public void Reset();
+    }
+    public sealed class CmsSigner {
+        public CmsSigner();
+        public CmsSigner(CspParameters parameters);
+        public CmsSigner(SubjectIdentifierType signerIdentifierType);
+        public CmsSigner(SubjectIdentifierType signerIdentifierType, X509Certificate2 certificate);
+        public CmsSigner(X509Certificate2 certificate);
+        public X509Certificate2 Certificate { get; set; }
+        public X509Certificate2Collection Certificates { get; set; }
+        public Oid DigestAlgorithm { get; set; }
+        public X509IncludeOption IncludeOption { get; set; }
+        public CryptographicAttributeObjectCollection SignedAttributes { get; set; }
+        public SubjectIdentifierType SignerIdentifierType { get; set; }
+        public CryptographicAttributeObjectCollection UnsignedAttributes { get; set; }
+    }
+    public sealed class ContentInfo {
+        public ContentInfo(byte[] content);
+        public ContentInfo(Oid contentType, byte[] content);
+        public byte[] Content { get; }
+        public Oid ContentType { get; }
+        public static Oid GetContentType(byte[] encodedMessage);
+    }
+    public sealed class EnvelopedCms {
+        public EnvelopedCms();
+        public EnvelopedCms(ContentInfo contentInfo);
+        public EnvelopedCms(ContentInfo contentInfo, AlgorithmIdentifier encryptionAlgorithm);
+        public X509Certificate2Collection Certificates { get; }
+        public AlgorithmIdentifier ContentEncryptionAlgorithm { get; }
+        public ContentInfo ContentInfo { get; }
+        public RecipientInfoCollection RecipientInfos { get; }
+        public CryptographicAttributeObjectCollection UnprotectedAttributes { get; }
+        public int Version { get; }
+        public void Decode(byte[] encodedMessage);
+        public void Decrypt();
+        public void Decrypt(RecipientInfo recipientInfo);
+        public void Decrypt(RecipientInfo recipientInfo, X509Certificate2Collection extraStore);
+        public void Decrypt(X509Certificate2Collection extraStore);
+        public byte[] Encode();
+        public void Encrypt(CmsRecipient recipient);
+        public void Encrypt(CmsRecipientCollection recipients);
+    }
+    public sealed class KeyAgreeRecipientInfo : RecipientInfo {
+        public DateTime Date { get; }
+        public override byte[] EncryptedKey { get; }
+        public override AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
+        public SubjectIdentifierOrKey OriginatorIdentifierOrKey { get; }
+        public CryptographicAttributeObject OtherKeyAttribute { get; }
+        public override SubjectIdentifier RecipientIdentifier { get; }
+        public override int Version { get; }
+    }
+    public sealed class KeyTransRecipientInfo : RecipientInfo {
+        public override byte[] EncryptedKey { get; }
+        public override AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
+        public override SubjectIdentifier RecipientIdentifier { get; }
+        public override int Version { get; }
+    }
+    public class Pkcs9AttributeObject : AsnEncodedData {
+        public Pkcs9AttributeObject();
+        public Pkcs9AttributeObject(AsnEncodedData asnEncodedData);
+        public Pkcs9AttributeObject(Oid oid, byte[] encodedData);
+        public Pkcs9AttributeObject(string oid, byte[] encodedData);
+        public Oid Oid { get; }
+        public override void CopyFrom(AsnEncodedData asnEncodedData);
+    }
+    public sealed class Pkcs9ContentType : Pkcs9AttributeObject {
+        public Pkcs9ContentType();
+        public Oid ContentType { get; }
+        public override void CopyFrom(AsnEncodedData asnEncodedData);
+    }
+    public sealed class Pkcs9DocumentDescription : Pkcs9AttributeObject {
+        public Pkcs9DocumentDescription();
+        public Pkcs9DocumentDescription(byte[] encodedDocumentDescription);
+        public Pkcs9DocumentDescription(string documentDescription);
+        public string DocumentDescription { get; }
+        public override void CopyFrom(AsnEncodedData asnEncodedData);
+    }
+    public sealed class Pkcs9DocumentName : Pkcs9AttributeObject {
+        public Pkcs9DocumentName();
+        public Pkcs9DocumentName(byte[] encodedDocumentName);
+        public Pkcs9DocumentName(string documentName);
+        public string DocumentName { get; }
+        public override void CopyFrom(AsnEncodedData asnEncodedData);
+    }
+    public sealed class Pkcs9MessageDigest : Pkcs9AttributeObject {
+        public Pkcs9MessageDigest();
+        public byte[] MessageDigest { get; }
+        public override void CopyFrom(AsnEncodedData asnEncodedData);
+    }
+    public sealed class Pkcs9SigningTime : Pkcs9AttributeObject {
+        public Pkcs9SigningTime();
+        public Pkcs9SigningTime(byte[] encodedSigningTime);
+        public Pkcs9SigningTime(DateTime signingTime);
+        public DateTime SigningTime { get; }
+        public override void CopyFrom(AsnEncodedData asnEncodedData);
+    }
+    public sealed class PublicKeyInfo {
+        public AlgorithmIdentifier Algorithm { get; }
+        public byte[] KeyValue { get; }
+    }
+    public abstract class RecipientInfo {
+        public abstract byte[] EncryptedKey { get; }
+        public abstract AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
+        public abstract SubjectIdentifier RecipientIdentifier { get; }
+        public RecipientInfoType Type { get; }
+        public abstract int Version { get; }
+    }
+    public sealed class RecipientInfoCollection : ICollection, IEnumerable {
+        public int Count { get; }
+        public RecipientInfo this[int index] { get; }
+        bool System.Collections.ICollection.IsSynchronized { get; }
+        object System.Collections.ICollection.SyncRoot { get; }
+        public void CopyTo(Array array, int index);
+        public void CopyTo(RecipientInfo[] array, int index);
+        public RecipientInfoEnumerator GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public sealed class RecipientInfoEnumerator : IEnumerator {
+        public RecipientInfo Current { get; }
+        object System.Collections.IEnumerator.Current { get; }
+        public bool MoveNext();
+        public void Reset();
+    }
+    public enum RecipientInfoType {
+        KeyAgreement = 2,
+        KeyTransport = 1,
+        Unknown = 0,
+    }
+    public sealed class Rfc3161TimestampRequest {
+        public bool HasExtensions { get; }
+        public Oid HashAlgorithmId { get; }
+        public Oid RequestedPolicyId { get; }
+        public bool RequestSignerCertificate { get; }
+        public int Version { get; }
+        public static Rfc3161TimestampRequest CreateFromData(ReadOnlySpan<byte> data, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId=null, Nullable<ReadOnlyMemory<byte>> nonce=default(Nullable<ReadOnlyMemory<byte>>), bool requestSignerCertificates=false, X509ExtensionCollection extensions=null);
+        public static Rfc3161TimestampRequest CreateFromHash(ReadOnlyMemory<byte> hash, Oid hashAlgorithmId, Oid requestedPolicyId=null, Nullable<ReadOnlyMemory<byte>> nonce=default(Nullable<ReadOnlyMemory<byte>>), bool requestSignerCertificates=false, X509ExtensionCollection extensions=null);
+        public static Rfc3161TimestampRequest CreateFromHash(ReadOnlyMemory<byte> hash, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId=null, Nullable<ReadOnlyMemory<byte>> nonce=default(Nullable<ReadOnlyMemory<byte>>), bool requestSignerCertificates=false, X509ExtensionCollection extensions=null);
+        public static Rfc3161TimestampRequest CreateFromSignerInfo(SignerInfo signerInfo, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId=null, Nullable<ReadOnlyMemory<byte>> nonce=default(Nullable<ReadOnlyMemory<byte>>), bool requestSignerCertificates=false, X509ExtensionCollection extensions=null);
+        public byte[] Encode();
+        public X509ExtensionCollection GetExtensions();
+        public ReadOnlyMemory<byte> GetMessageHash();
+        public Nullable<ReadOnlyMemory<byte>> GetNonce();
+        public Rfc3161TimestampToken ProcessResponse(ReadOnlyMemory<byte> responseBytes, out int bytesConsumed);
+        public static bool TryDecode(ReadOnlyMemory<byte> encodedBytes, out Rfc3161TimestampRequest request, out int bytesConsumed);
+        public bool TryEncode(Span<byte> destination, out int bytesWritten);
+    }
+    public sealed class Rfc3161TimestampToken {
+        public Rfc3161TimestampTokenInfo TokenInfo { get; }
+        public SignedCms AsSignedCms();
+        public static bool TryDecode(ReadOnlyMemory<byte> encodedBytes, out Rfc3161TimestampToken token, out int bytesConsumed);
+        public bool VerifySignatureForData(ReadOnlySpan<byte> data, out X509Certificate2 signerCertificate, X509Certificate2Collection extraCandidates=null);
+        public bool VerifySignatureForHash(ReadOnlySpan<byte> hash, Oid hashAlgorithmId, out X509Certificate2 signerCertificate, X509Certificate2Collection extraCandidates=null);
+        public bool VerifySignatureForHash(ReadOnlySpan<byte> hash, HashAlgorithmName hashAlgorithm, out X509Certificate2 signerCertificate, X509Certificate2Collection extraCandidates=null);
+        public bool VerifySignatureForSignerInfo(SignerInfo signerInfo, out X509Certificate2 signerCertificate, X509Certificate2Collection extraCandidates=null);
+    }
+    public sealed class Rfc3161TimestampTokenInfo {
+        public Rfc3161TimestampTokenInfo(Oid policyId, Oid hashAlgorithmId, ReadOnlyMemory<byte> messageHash, ReadOnlyMemory<byte> serialNumber, DateTimeOffset timestamp, Nullable<long> accuracyInMicroseconds=default(Nullable<long>), bool isOrdering=false, Nullable<ReadOnlyMemory<byte>> nonce=default(Nullable<ReadOnlyMemory<byte>>), Nullable<ReadOnlyMemory<byte>> timestampAuthorityName=default(Nullable<ReadOnlyMemory<byte>>), X509ExtensionCollection extensions=null);
+        public Nullable<long> AccuracyInMicroseconds { get; }
+        public bool HasExtensions { get; }
+        public Oid HashAlgorithmId { get; }
+        public bool IsOrdering { get; }
+        public Oid PolicyId { get; }
+        public DateTimeOffset Timestamp { get; }
+        public int Version { get; }
+        public byte[] Encode();
+        public X509ExtensionCollection GetExtensions();
+        public ReadOnlyMemory<byte> GetMessageHash();
+        public Nullable<ReadOnlyMemory<byte>> GetNonce();
+        public ReadOnlyMemory<byte> GetSerialNumber();
+        public Nullable<ReadOnlyMemory<byte>> GetTimestampAuthorityName();
+        public static bool TryDecode(ReadOnlyMemory<byte> encodedBytes, out Rfc3161TimestampTokenInfo timestampTokenInfo, out int bytesConsumed);
+        public bool TryEncode(Span<byte> destination, out int bytesWritten);
+    }
+    public sealed class SignedCms {
+        public SignedCms();
+        public SignedCms(ContentInfo contentInfo);
+        public SignedCms(ContentInfo contentInfo, bool detached);
+        public SignedCms(SubjectIdentifierType signerIdentifierType);
+        public SignedCms(SubjectIdentifierType signerIdentifierType, ContentInfo contentInfo);
+        public SignedCms(SubjectIdentifierType signerIdentifierType, ContentInfo contentInfo, bool detached);
+        public X509Certificate2Collection Certificates { get; }
+        public ContentInfo ContentInfo { get; }
+        public bool Detached { get; }
+        public SignerInfoCollection SignerInfos { get; }
+        public int Version { get; }
+        public void CheckHash();
+        public void CheckSignature(bool verifySignatureOnly);
+        public void CheckSignature(X509Certificate2Collection extraStore, bool verifySignatureOnly);
+        public void ComputeSignature();
+        public void ComputeSignature(CmsSigner signer);
+        public void ComputeSignature(CmsSigner signer, bool silent);
+        public void Decode(byte[] encodedMessage);
+        public byte[] Encode();
+        public void RemoveSignature(int index);
+        public void RemoveSignature(SignerInfo signerInfo);
+    }
+    public sealed class SignerInfo {
+        public X509Certificate2 Certificate { get; }
+        public SignerInfoCollection CounterSignerInfos { get; }
+        public Oid DigestAlgorithm { get; }
+        public Oid SignatureAlgorithm { get; }
+        public CryptographicAttributeObjectCollection SignedAttributes { get; }
+        public SubjectIdentifier SignerIdentifier { get; }
+        public CryptographicAttributeObjectCollection UnsignedAttributes { get; }
+        public int Version { get; }
+        public void CheckHash();
+        public void CheckSignature(bool verifySignatureOnly);
+        public void CheckSignature(X509Certificate2Collection extraStore, bool verifySignatureOnly);
+        public void ComputeCounterSignature();
+        public void ComputeCounterSignature(CmsSigner signer);
+        public byte[] GetSignature();
+        public void RemoveCounterSignature(int index);
+        public void RemoveCounterSignature(SignerInfo counterSignerInfo);
+    }
+    public sealed class SignerInfoCollection : ICollection, IEnumerable {
+        public int Count { get; }
+        public bool IsSynchronized { get; }
+        public SignerInfo this[int index] { get; }
+        public object SyncRoot { get; }
+        public void CopyTo(Array array, int index);
+        public void CopyTo(SignerInfo[] array, int index);
+        public SignerInfoEnumerator GetEnumerator();
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public sealed class SignerInfoEnumerator : IEnumerator {
+        public SignerInfo Current { get; }
+        object System.Collections.IEnumerator.Current { get; }
+        public bool MoveNext();
+        public void Reset();
+    }
+    public sealed class SubjectIdentifier {
+        public SubjectIdentifierType Type { get; }
+        public object Value { get; }
+    }
+    public sealed class SubjectIdentifierOrKey {
+        public SubjectIdentifierOrKeyType Type { get; }
+        public object Value { get; }
+    }
+    public enum SubjectIdentifierOrKeyType {
+        IssuerAndSerialNumber = 1,
+        PublicKeyInfo = 3,
+        SubjectKeyIdentifier = 2,
+        Unknown = 0,
+    }
+    public enum SubjectIdentifierType {
+        IssuerAndSerialNumber = 1,
+        NoSignature = 3,
+        SubjectKeyIdentifier = 2,
+        Unknown = 0,
+    }
+}
 namespace System.Security.Cryptography.X509Certificates {
     public class X509Certificate : IDeserializationCallback, IDisposable, ISerializable {
+        public virtual byte[] GetCertHash(HashAlgorithmName hashAlgorithm);
+        public virtual string GetCertHashString(HashAlgorithmName hashAlgorithm);
+        public virtual bool TryGetCertHash(HashAlgorithmName hashAlgorithm, Span<byte> destination, out int bytesWritten);
     }
     public class X509CertificateCollection : CollectionBase {
+        protected override void OnValidate(object value);
     }
 }
+namespace System.Security.Cryptography.Xml {
+    public sealed class CipherData {
+        public CipherData();
+        public CipherData(byte[] cipherValue);
+        public CipherData(CipherReference cipherReference);
+        public CipherReference CipherReference { get; set; }
+        public byte[] CipherValue { get; set; }
+        public XmlElement GetXml();
+        public void LoadXml(XmlElement value);
+    }
+    public sealed class CipherReference : EncryptedReference {
+        public CipherReference();
+        public CipherReference(string uri);
+        public CipherReference(string uri, TransformChain transformChain);
+        public override XmlElement GetXml();
+        public override void LoadXml(XmlElement value);
+    }
+    public class DataObject {
+        public DataObject();
+        public DataObject(string id, string mimeType, string encoding, XmlElement data);
+        public XmlNodeList Data { get; set; }
+        public string Encoding { get; set; }
+        public string Id { get; set; }
+        public string MimeType { get; set; }
+        public XmlElement GetXml();
+        public void LoadXml(XmlElement value);
+    }
+    public sealed class DataReference : EncryptedReference {
+        public DataReference();
+        public DataReference(string uri);
+        public DataReference(string uri, TransformChain transformChain);
+    }
+    public class DSAKeyValue : KeyInfoClause {
+        public DSAKeyValue();
+        public DSAKeyValue(DSA key);
+        public DSA Key { get; set; }
+        public override XmlElement GetXml();
+        public override void LoadXml(XmlElement value);
+    }
+    public sealed class EncryptedData : EncryptedType {
+        public EncryptedData();
+        public override XmlElement GetXml();
+        public override void LoadXml(XmlElement value);
+    }
+    public sealed class EncryptedKey : EncryptedType {
+        public EncryptedKey();
+        public string CarriedKeyName { get; set; }
+        public string Recipient { get; set; }
+        public ReferenceList ReferenceList { get; }
+        public void AddReference(DataReference dataReference);
+        public void AddReference(KeyReference keyReference);
+        public override XmlElement GetXml();
+        public override void LoadXml(XmlElement value);
+    }
+    public abstract class EncryptedReference {
+        protected EncryptedReference();
+        protected EncryptedReference(string uri);
+        protected EncryptedReference(string uri, TransformChain transformChain);
+        protected internal bool CacheValid { get; }
+        protected string ReferenceType { get; set; }
+        public TransformChain TransformChain { get; set; }
+        public string Uri { get; set; }
+        public void AddTransform(Transform transform);
+        public virtual XmlElement GetXml();
+        public virtual void LoadXml(XmlElement value);
+    }
+    public abstract class EncryptedType {
+        protected EncryptedType();
+        public virtual CipherData CipherData { get; set; }
+        public virtual string Encoding { get; set; }
+        public virtual EncryptionMethod EncryptionMethod { get; set; }
+        public virtual EncryptionPropertyCollection EncryptionProperties { get; }
+        public virtual string Id { get; set; }
+        public KeyInfo KeyInfo { get; set; }
+        public virtual string MimeType { get; set; }
+        public virtual string Type { get; set; }
+        public void AddProperty(EncryptionProperty ep);
+        public abstract XmlElement GetXml();
+        public abstract void LoadXml(XmlElement value);
+    }
+    public class EncryptedXml {
+        public const string XmlEncAES128KeyWrapUrl = "http://www.w3.org/2001/04/xmlenc#kw-aes128";
+        public const string XmlEncAES128Url = "http://www.w3.org/2001/04/xmlenc#aes128-cbc";
+        public const string XmlEncAES192KeyWrapUrl = "http://www.w3.org/2001/04/xmlenc#kw-aes192";
+        public const string XmlEncAES192Url = "http://www.w3.org/2001/04/xmlenc#aes192-cbc";
+        public const string XmlEncAES256KeyWrapUrl = "http://www.w3.org/2001/04/xmlenc#kw-aes256";
+        public const string XmlEncAES256Url = "http://www.w3.org/2001/04/xmlenc#aes256-cbc";
+        public const string XmlEncDESUrl = "http://www.w3.org/2001/04/xmlenc#des-cbc";
+        public const string XmlEncElementContentUrl = "http://www.w3.org/2001/04/xmlenc#Content";
+        public const string XmlEncElementUrl = "http://www.w3.org/2001/04/xmlenc#Element";
+        public const string XmlEncEncryptedKeyUrl = "http://www.w3.org/2001/04/xmlenc#EncryptedKey";
+        public const string XmlEncNamespaceUrl = "http://www.w3.org/2001/04/xmlenc#";
+        public const string XmlEncRSA15Url = "http://www.w3.org/2001/04/xmlenc#rsa-1_5";
+        public const string XmlEncRSAOAEPUrl = "http://www.w3.org/2001/04/xmlenc#rsa-oaep-mgf1p";
+        public const string XmlEncSHA256Url = "http://www.w3.org/2001/04/xmlenc#sha256";
+        public const string XmlEncSHA512Url = "http://www.w3.org/2001/04/xmlenc#sha512";
+        public const string XmlEncTripleDESKeyWrapUrl = "http://www.w3.org/2001/04/xmlenc#kw-tripledes";
+        public const string XmlEncTripleDESUrl = "http://www.w3.org/2001/04/xmlenc#tripledes-cbc";
+        public EncryptedXml();
+        public EncryptedXml(XmlDocument document);
+        public EncryptedXml(XmlDocument document, Evidence evidence);
+        public Evidence DocumentEvidence { get; set; }
+        public Encoding Encoding { get; set; }
+        public CipherMode Mode { get; set; }
+        public PaddingMode Padding { get; set; }
+        public string Recipient { get; set; }
+        public XmlResolver Resolver { get; set; }
+        public int XmlDSigSearchDepth { get; set; }
+        public void AddKeyNameMapping(string keyName, object keyObject);
+        public void ClearKeyNameMappings();
+        public byte[] DecryptData(EncryptedData encryptedData, SymmetricAlgorithm symmetricAlgorithm);
+        public void DecryptDocument();
+        public virtual byte[] DecryptEncryptedKey(EncryptedKey encryptedKey);
+        public static byte[] DecryptKey(byte[] keyData, RSA rsa, bool useOAEP);
+        public static byte[] DecryptKey(byte[] keyData, SymmetricAlgorithm symmetricAlgorithm);
+        public EncryptedData Encrypt(XmlElement inputElement, string keyName);
+        public EncryptedData Encrypt(XmlElement inputElement, X509Certificate2 certificate);
+        public byte[] EncryptData(byte[] plaintext, SymmetricAlgorithm symmetricAlgorithm);
+        public byte[] EncryptData(XmlElement inputElement, SymmetricAlgorithm symmetricAlgorithm, bool content);
+        public static byte[] EncryptKey(byte[] keyData, RSA rsa, bool useOAEP);
+        public static byte[] EncryptKey(byte[] keyData, SymmetricAlgorithm symmetricAlgorithm);
+        public virtual byte[] GetDecryptionIV(EncryptedData encryptedData, string symmetricAlgorithmUri);
+        public virtual SymmetricAlgorithm GetDecryptionKey(EncryptedData encryptedData, string symmetricAlgorithmUri);
+        public virtual XmlElement GetIdElement(XmlDocument document, string idValue);
+        public void ReplaceData(XmlElement inputElement, byte[] decryptedData);
+        public static void ReplaceElement(XmlElement inputElement, EncryptedData encryptedData, bool content);
+    }
+    public class EncryptionMethod {
+        public EncryptionMethod();
+        public EncryptionMethod(string algorithm);
+        public string KeyAlgorithm { get; set; }
+        public int KeySize { get; set; }
+        public XmlElement GetXml();
+        public void LoadXml(XmlElement value);
+    }
+    public sealed class EncryptionProperty {
+        public EncryptionProperty();
+        public EncryptionProperty(XmlElement elementProperty);
+        public string Id { get; }
+        public XmlElement PropertyElement { get; set; }
+        public string Target { get; }
+        public XmlElement GetXml();
+        public void LoadXml(XmlElement value);
+    }
+    public sealed class EncryptionPropertyCollection : ICollection, IEnumerable, IList {
+        public EncryptionPropertyCollection();
+        public int Count { get; }
+        public bool IsFixedSize { get; }
+        public bool IsReadOnly { get; }
+        public bool IsSynchronized { get; }
+        [System.Runtime.CompilerServices.IndexerName("ItemOf")]
+        public EncryptionProperty this[int index] { get; set; }
+        public object SyncRoot { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public int Add(EncryptionProperty value);
+        public void Clear();
+        public bool Contains(EncryptionProperty value);
+        public void CopyTo(Array array, int index);
+        public void CopyTo(EncryptionProperty[] array, int index);
+        public IEnumerator GetEnumerator();
+        public int IndexOf(EncryptionProperty value);
+        public void Insert(int index, EncryptionProperty value);
+        public EncryptionProperty Item(int index);
+        public void Remove(EncryptionProperty value);
+        public void RemoveAt(int index);
+        int System.Collections.IList.Add(object value);
+        bool System.Collections.IList.Contains(object value);
+        int System.Collections.IList.IndexOf(object value);
+        void System.Collections.IList.Insert(int index, object value);
+        void System.Collections.IList.Remove(object value);
+    }
+    public interface IRelDecryptor {
+        Stream Decrypt(EncryptionMethod encryptionMethod, KeyInfo keyInfo, Stream toDecrypt);
+    }
+    public class KeyInfo : IEnumerable {
+        public KeyInfo();
+        public int Count { get; }
+        public string Id { get; set; }
+        public void AddClause(KeyInfoClause clause);
+        public IEnumerator GetEnumerator();
+        public IEnumerator GetEnumerator(Type requestedObjectType);
+        public XmlElement GetXml();
+        public void LoadXml(XmlElement value);
+    }
+    public abstract class KeyInfoClause {
+        protected KeyInfoClause();
+        public abstract XmlElement GetXml();
+        public abstract void LoadXml(XmlElement element);
+    }
+    public class KeyInfoEncryptedKey : KeyInfoClause {
+        public KeyInfoEncryptedKey();
+        public KeyInfoEncryptedKey(EncryptedKey encryptedKey);
+        public EncryptedKey EncryptedKey { get; set; }
+        public override XmlElement GetXml();
+        public override void LoadXml(XmlElement value);
+    }
+    public class KeyInfoName : KeyInfoClause {
+        public KeyInfoName();
+        public KeyInfoName(string keyName);
+        public string Value { get; set; }
+        public override XmlElement GetXml();
+        public override void LoadXml(XmlElement value);
+    }
+    public class KeyInfoNode : KeyInfoClause {
+        public KeyInfoNode();
+        public KeyInfoNode(XmlElement node);
+        public XmlElement Value { get; set; }
+        public override XmlElement GetXml();
+        public override void LoadXml(XmlElement value);
+    }
+    public class KeyInfoRetrievalMethod : KeyInfoClause {
+        public KeyInfoRetrievalMethod();
+        public KeyInfoRetrievalMethod(string strUri);
+        public KeyInfoRetrievalMethod(string strUri, string typeName);
+        public string Type { get; set; }
+        public string Uri { get; set; }
+        public override XmlElement GetXml();
+        public override void LoadXml(XmlElement value);
+    }
+    public class KeyInfoX509Data : KeyInfoClause {
+        public KeyInfoX509Data();
+        public KeyInfoX509Data(byte[] rgbCert);
+        public KeyInfoX509Data(X509Certificate cert);
+        public KeyInfoX509Data(X509Certificate cert, X509IncludeOption includeOption);
+        public ArrayList Certificates { get; }
+        public byte[] CRL { get; set; }
+        public ArrayList IssuerSerials { get; }
+        public ArrayList SubjectKeyIds { get; }
+        public ArrayList SubjectNames { get; }
+        public void AddCertificate(X509Certificate certificate);
+        public void AddIssuerSerial(string issuerName, string serialNumber);
+        public void AddSubjectKeyId(byte[] subjectKeyId);
+        public void AddSubjectKeyId(string subjectKeyId);
+        public void AddSubjectName(string subjectName);
+        public override XmlElement GetXml();
+        public override void LoadXml(XmlElement element);
+    }
+    public sealed class KeyReference : EncryptedReference {
+        public KeyReference();
+        public KeyReference(string uri);
+        public KeyReference(string uri, TransformChain transformChain);
+    }
+    public class Reference {
+        public Reference();
+        public Reference(Stream stream);
+        public Reference(string uri);
+        public string DigestMethod { get; set; }
+        public byte[] DigestValue { get; set; }
+        public string Id { get; set; }
+        public TransformChain TransformChain { get; set; }
+        public string Type { get; set; }
+        public string Uri { get; set; }
+        public void AddTransform(Transform transform);
+        public XmlElement GetXml();
+        public void LoadXml(XmlElement value);
+    }
+    public sealed class ReferenceList : ICollection, IEnumerable, IList {
+        public ReferenceList();
+        public int Count { get; }
+        public bool IsSynchronized { get; }
+        [System.Runtime.CompilerServices.IndexerName("ItemOf")]
+        public EncryptedReference this[int index] { get; set; }
+        public object SyncRoot { get; }
+        bool System.Collections.IList.IsFixedSize { get; }
+        bool System.Collections.IList.IsReadOnly { get; }
+        object System.Collections.IList.this[int index] { get; set; }
+        public int Add(object value);
+        public void Clear();
+        public bool Contains(object value);
+        public void CopyTo(Array array, int index);
+        public IEnumerator GetEnumerator();
+        public int IndexOf(object value);
+        public void Insert(int index, object value);
+        public EncryptedReference Item(int index);
+        public void Remove(object value);
+        public void RemoveAt(int index);
+    }
+    public class RSAKeyValue : KeyInfoClause {
+        public RSAKeyValue();
+        public RSAKeyValue(RSA key);
+        public RSA Key { get; set; }
+        public override XmlElement GetXml();
+        public override void LoadXml(XmlElement value);
+    }
+    public class Signature {
+        public Signature();
+        public string Id { get; set; }
+        public KeyInfo KeyInfo { get; set; }
+        public IList ObjectList { get; set; }
+        public byte[] SignatureValue { get; set; }
+        public SignedInfo SignedInfo { get; set; }
+        public void AddObject(DataObject dataObject);
+        public XmlElement GetXml();
+        public void LoadXml(XmlElement value);
+    }
+    public class SignedInfo : ICollection, IEnumerable {
+        public SignedInfo();
+        public string CanonicalizationMethod { get; set; }
+        public Transform CanonicalizationMethodObject { get; }
+        public int Count { get; }
+        public string Id { get; set; }
+        public bool IsReadOnly { get; }
+        public bool IsSynchronized { get; }
+        public ArrayList References { get; }
+        public string SignatureLength { get; set; }
+        public string SignatureMethod { get; set; }
+        public object SyncRoot { get; }
+        public void AddReference(Reference reference);
+        public void CopyTo(Array array, int index);
+        public IEnumerator GetEnumerator();
+        public XmlElement GetXml();
+        public void LoadXml(XmlElement value);
+    }
+    public class SignedXml {
+        protected Signature m_signature;
+        protected string m_strSigningKeyName;
+        public const string XmlDecryptionTransformUrl = "http://www.w3.org/2002/07/decrypt#XML";
+        public const string XmlDsigBase64TransformUrl = "http://www.w3.org/2000/09/xmldsig#base64";
+        public const string XmlDsigC14NTransformUrl = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315";
+        public const string XmlDsigC14NWithCommentsTransformUrl = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments";
+        public const string XmlDsigCanonicalizationUrl = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315";
+        public const string XmlDsigCanonicalizationWithCommentsUrl = "http://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments";
+        public const string XmlDsigDSAUrl = "http://www.w3.org/2000/09/xmldsig#dsa-sha1";
+        public const string XmlDsigEnvelopedSignatureTransformUrl = "http://www.w3.org/2000/09/xmldsig#enveloped-signature";
+        public const string XmlDsigExcC14NTransformUrl = "http://www.w3.org/2001/10/xml-exc-c14n#";
+        public const string XmlDsigExcC14NWithCommentsTransformUrl = "http://www.w3.org/2001/10/xml-exc-c14n#WithComments";
+        public const string XmlDsigHMACSHA1Url = "http://www.w3.org/2000/09/xmldsig#hmac-sha1";
+        public const string XmlDsigMinimalCanonicalizationUrl = "http://www.w3.org/2000/09/xmldsig#minimal";
+        public const string XmlDsigNamespaceUrl = "http://www.w3.org/2000/09/xmldsig#";
+        public const string XmlDsigRSASHA1Url = "http://www.w3.org/2000/09/xmldsig#rsa-sha1";
+        public const string XmlDsigSHA1Url = "http://www.w3.org/2000/09/xmldsig#sha1";
+        public const string XmlDsigXPathTransformUrl = "http://www.w3.org/TR/1999/REC-xpath-19991116";
+        public const string XmlDsigXsltTransformUrl = "http://www.w3.org/TR/1999/REC-xslt-19991116";
+        public const string XmlLicenseTransformUrl = "urn:mpeg:mpeg21:2003:01-REL-R-NS:licenseTransform";
+        public SignedXml();
+        public SignedXml(XmlDocument document);
+        public SignedXml(XmlElement elem);
+        public EncryptedXml EncryptedXml { get; set; }
+        public KeyInfo KeyInfo { get; set; }
+        public XmlResolver Resolver { set; }
+        public Collection<string> SafeCanonicalizationMethods { get; }
+        public Signature Signature { get; }
+        public Func<SignedXml, bool> SignatureFormatValidator { get; set; }
+        public string SignatureLength { get; }
+        public string SignatureMethod { get; }
+        public byte[] SignatureValue { get; }
+        public SignedInfo SignedInfo { get; }
+        public AsymmetricAlgorithm SigningKey { get; set; }
+        public string SigningKeyName { get; set; }
+        public void AddObject(DataObject dataObject);
+        public void AddReference(Reference reference);
+        public bool CheckSignature();
+        public bool CheckSignature(AsymmetricAlgorithm key);
+        public bool CheckSignature(KeyedHashAlgorithm macAlg);
+        public bool CheckSignature(X509Certificate2 certificate, bool verifySignatureOnly);
+        public bool CheckSignatureReturningKey(out AsymmetricAlgorithm signingKey);
+        public void ComputeSignature();
+        public void ComputeSignature(KeyedHashAlgorithm macAlg);
+        public virtual XmlElement GetIdElement(XmlDocument document, string idValue);
+        protected virtual AsymmetricAlgorithm GetPublicKey();
+        public XmlElement GetXml();
+        public void LoadXml(XmlElement value);
+    }
+    public abstract class Transform {
+        protected Transform();
+        public string Algorithm { get; set; }
+        public XmlElement Context { get; set; }
+        public abstract Type[] InputTypes { get; }
+        public abstract Type[] OutputTypes { get; }
+        public Hashtable PropagatedNamespaces { get; }
+        public XmlResolver Resolver { set; }
+        public virtual byte[] GetDigestedOutput(HashAlgorithm hash);
+        protected abstract XmlNodeList GetInnerXml();
+        public abstract object GetOutput();
+        public abstract object GetOutput(Type type);
+        public XmlElement GetXml();
+        public abstract void LoadInnerXml(XmlNodeList nodeList);
+        public abstract void LoadInput(object obj);
+    }
+    public class TransformChain {
+        public TransformChain();
+        public int Count { get; }
+        public Transform this[int index] { get; }
+        public void Add(Transform transform);
+        public IEnumerator GetEnumerator();
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct X509IssuerSerial {
+        public string IssuerName { get; set; }
+        public string SerialNumber { get; set; }
+    }
+    public class XmlDecryptionTransform : Transform {
+        public XmlDecryptionTransform();
+        public EncryptedXml EncryptedXml { get; set; }
+        public override Type[] InputTypes { get; }
+        public override Type[] OutputTypes { get; }
+        public void AddExceptUri(string uri);
+        protected override XmlNodeList GetInnerXml();
+        public override object GetOutput();
+        public override object GetOutput(Type type);
+        protected virtual bool IsTargetElement(XmlElement inputElement, string idValue);
+        public override void LoadInnerXml(XmlNodeList nodeList);
+        public override void LoadInput(object obj);
+    }
+    public class XmlDsigBase64Transform : Transform {
+        public XmlDsigBase64Transform();
+        public override Type[] InputTypes { get; }
+        public override Type[] OutputTypes { get; }
+        protected override XmlNodeList GetInnerXml();
+        public override object GetOutput();
+        public override object GetOutput(Type type);
+        public override void LoadInnerXml(XmlNodeList nodeList);
+        public override void LoadInput(object obj);
+    }
+    public class XmlDsigC14NTransform : Transform {
+        public XmlDsigC14NTransform();
+        public XmlDsigC14NTransform(bool includeComments);
+        public override Type[] InputTypes { get; }
+        public override Type[] OutputTypes { get; }
+        public override byte[] GetDigestedOutput(HashAlgorithm hash);
+        protected override XmlNodeList GetInnerXml();
+        public override object GetOutput();
+        public override object GetOutput(Type type);
+        public override void LoadInnerXml(XmlNodeList nodeList);
+        public override void LoadInput(object obj);
+    }
+    public class XmlDsigC14NWithCommentsTransform : XmlDsigC14NTransform {
+        public XmlDsigC14NWithCommentsTransform();
+    }
+    public class XmlDsigEnvelopedSignatureTransform : Transform {
+        public XmlDsigEnvelopedSignatureTransform();
+        public XmlDsigEnvelopedSignatureTransform(bool includeComments);
+        public override Type[] InputTypes { get; }
+        public override Type[] OutputTypes { get; }
+        protected override XmlNodeList GetInnerXml();
+        public override object GetOutput();
+        public override object GetOutput(Type type);
+        public override void LoadInnerXml(XmlNodeList nodeList);
+        public override void LoadInput(object obj);
+    }
+    public class XmlDsigExcC14NTransform : Transform {
+        public XmlDsigExcC14NTransform();
+        public XmlDsigExcC14NTransform(bool includeComments);
+        public XmlDsigExcC14NTransform(bool includeComments, string inclusiveNamespacesPrefixList);
+        public XmlDsigExcC14NTransform(string inclusiveNamespacesPrefixList);
+        public string InclusiveNamespacesPrefixList { get; set; }
+        public override Type[] InputTypes { get; }
+        public override Type[] OutputTypes { get; }
+        public override byte[] GetDigestedOutput(HashAlgorithm hash);
+        protected override XmlNodeList GetInnerXml();
+        public override object GetOutput();
+        public override object GetOutput(Type type);
+        public override void LoadInnerXml(XmlNodeList nodeList);
+        public override void LoadInput(object obj);
+    }
+    public class XmlDsigExcC14NWithCommentsTransform : XmlDsigExcC14NTransform {
+        public XmlDsigExcC14NWithCommentsTransform();
+        public XmlDsigExcC14NWithCommentsTransform(string inclusiveNamespacesPrefixList);
+    }
+    public class XmlDsigXPathTransform : Transform {
+        public XmlDsigXPathTransform();
+        public override Type[] InputTypes { get; }
+        public override Type[] OutputTypes { get; }
+        protected override XmlNodeList GetInnerXml();
+        public override object GetOutput();
+        public override object GetOutput(Type type);
+        public override void LoadInnerXml(XmlNodeList nodeList);
+        public override void LoadInput(object obj);
+    }
+    public class XmlDsigXsltTransform : Transform {
+        public XmlDsigXsltTransform();
+        public XmlDsigXsltTransform(bool includeComments);
+        public override Type[] InputTypes { get; }
+        public override Type[] OutputTypes { get; }
+        protected override XmlNodeList GetInnerXml();
+        public override object GetOutput();
+        public override object GetOutput(Type type);
+        public override void LoadInnerXml(XmlNodeList nodeList);
+        public override void LoadInput(object obj);
+    }
+    public class XmlLicenseTransform : Transform {
+        public XmlLicenseTransform();
+        public IRelDecryptor Decryptor { get; set; }
+        public override Type[] InputTypes { get; }
+        public override Type[] OutputTypes { get; }
+        protected override XmlNodeList GetInnerXml();
+        public override object GetOutput();
+        public override object GetOutput(Type type);
+        public override void LoadInnerXml(XmlNodeList nodeList);
+        public override void LoadInput(object obj);
+    }
+}
 namespace System.Security.Permissions {
+    public sealed class EnvironmentPermission : CodeAccessPermission, IUnrestrictedPermission {
+        public EnvironmentPermission(EnvironmentPermissionAccess flag, string pathList);
+        public EnvironmentPermission(PermissionState state);
+        public void AddPathList(EnvironmentPermissionAccess flag, string pathList);
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement esd);
+        public string GetPathList(EnvironmentPermissionAccess flag);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public void SetPathList(EnvironmentPermissionAccess flag, string pathList);
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission other);
+    }
+    public enum EnvironmentPermissionAccess {
+        AllAccess = 3,
+        NoAccess = 0,
+        Read = 1,
+        Write = 2,
+    }
+    public sealed class EnvironmentPermissionAttribute : CodeAccessSecurityAttribute {
+        public EnvironmentPermissionAttribute(SecurityAction action);
+        public string All { get; set; }
+        public string Read { get; set; }
+        public string Write { get; set; }
+        public override IPermission CreatePermission();
+    }
+    public sealed class FileDialogPermission : CodeAccessPermission, IUnrestrictedPermission {
+        public FileDialogPermission(FileDialogPermissionAccess access);
+        public FileDialogPermission(PermissionState state);
+        public FileDialogPermissionAccess Access { get; set; }
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement esd);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public enum FileDialogPermissionAccess {
+        None = 0,
+        Open = 1,
+        OpenSave = 3,
+        Save = 2,
+    }
+    public sealed class FileDialogPermissionAttribute : CodeAccessSecurityAttribute {
+        public FileDialogPermissionAttribute(SecurityAction action);
+        public bool Open { get; set; }
+        public bool Save { get; set; }
+        public override IPermission CreatePermission();
+    }
+    public sealed class FileIOPermission : CodeAccessPermission, IUnrestrictedPermission {
+        public FileIOPermission(FileIOPermissionAccess access, AccessControlActions actions, string path);
+        public FileIOPermission(FileIOPermissionAccess access, AccessControlActions actions, string[] pathList);
+        public FileIOPermission(FileIOPermissionAccess access, string path);
+        public FileIOPermission(FileIOPermissionAccess access, string[] pathList);
+        public FileIOPermission(PermissionState state);
+        public FileIOPermissionAccess AllFiles { get; set; }
+        public FileIOPermissionAccess AllLocalFiles { get; set; }
+        public void AddPathList(FileIOPermissionAccess access, string path);
+        public void AddPathList(FileIOPermissionAccess access, string[] pathList);
+        public override IPermission Copy();
+        public override bool Equals(object o);
+        public override void FromXml(SecurityElement esd);
+        public override int GetHashCode();
+        public string[] GetPathList(FileIOPermissionAccess access);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public void SetPathList(FileIOPermissionAccess access, string path);
+        public void SetPathList(FileIOPermissionAccess access, string[] pathList);
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission other);
+    }
+    public enum FileIOPermissionAccess {
+        AllAccess = 15,
+        Append = 4,
+        NoAccess = 0,
+        PathDiscovery = 8,
+        Read = 1,
+        Write = 2,
+    }
+    public sealed class FileIOPermissionAttribute : CodeAccessSecurityAttribute {
+        public FileIOPermissionAttribute(SecurityAction action);
+        public string All { get; set; }
+        public FileIOPermissionAccess AllFiles { get; set; }
+        public FileIOPermissionAccess AllLocalFiles { get; set; }
+        public string Append { get; set; }
+        public string ChangeAccessControl { get; set; }
+        public string PathDiscovery { get; set; }
+        public string Read { get; set; }
+        public string ViewAccessControl { get; set; }
+        public string ViewAndModify { get; set; }
+        public string Write { get; set; }
+        public override IPermission CreatePermission();
+    }
+    public sealed class GacIdentityPermission : CodeAccessPermission {
+        public GacIdentityPermission();
+        public GacIdentityPermission(PermissionState state);
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement securityElement);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class GacIdentityPermissionAttribute : CodeAccessSecurityAttribute {
+        public GacIdentityPermissionAttribute(SecurityAction action);
+        public override IPermission CreatePermission();
+    }
+    public sealed class HostProtectionAttribute : CodeAccessSecurityAttribute {
+        public HostProtectionAttribute();
+        public HostProtectionAttribute(SecurityAction action);
+        public bool ExternalProcessMgmt { get; set; }
+        public bool ExternalThreading { get; set; }
+        public bool MayLeakOnAbort { get; set; }
+        public HostProtectionResource Resources { get; set; }
+        public bool SecurityInfrastructure { get; set; }
+        public bool SelfAffectingProcessMgmt { get; set; }
+        public bool SelfAffectingThreading { get; set; }
+        public bool SharedState { get; set; }
+        public bool Synchronization { get; set; }
+        public bool UI { get; set; }
+        public override IPermission CreatePermission();
+    }
+    public enum HostProtectionResource {
+        All = 511,
+        ExternalProcessMgmt = 4,
+        ExternalThreading = 16,
+        MayLeakOnAbort = 256,
+        None = 0,
+        SecurityInfrastructure = 64,
+        SelfAffectingProcessMgmt = 8,
+        SelfAffectingThreading = 32,
+        SharedState = 2,
+        Synchronization = 1,
+        UI = 128,
+    }
+    public enum IsolatedStorageContainment {
+        AdministerIsolatedStorageByUser = 112,
+        ApplicationIsolationByMachine = 69,
+        ApplicationIsolationByRoamingUser = 101,
+        ApplicationIsolationByUser = 21,
+        AssemblyIsolationByMachine = 64,
+        AssemblyIsolationByRoamingUser = 96,
+        AssemblyIsolationByUser = 32,
+        DomainIsolationByMachine = 48,
+        DomainIsolationByRoamingUser = 80,
+        DomainIsolationByUser = 16,
+        None = 0,
+        UnrestrictedIsolatedStorage = 240,
+    }
+    public sealed class IsolatedStorageFilePermission : IsolatedStoragePermission {
+        public IsolatedStorageFilePermission(PermissionState state);
+        public override IPermission Copy();
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class IsolatedStorageFilePermissionAttribute : IsolatedStoragePermissionAttribute {
+        public IsolatedStorageFilePermissionAttribute(SecurityAction action);
+        public override IPermission CreatePermission();
+    }
+    public abstract class IsolatedStoragePermission : CodeAccessPermission, IUnrestrictedPermission {
+        protected IsolatedStoragePermission(PermissionState state);
+        public IsolatedStorageContainment UsageAllowed { get; set; }
+        public long UserQuota { get; set; }
+        public override void FromXml(SecurityElement esd);
+        public bool IsUnrestricted();
+        public override SecurityElement ToXml();
+    }
+    public abstract class IsolatedStoragePermissionAttribute : CodeAccessSecurityAttribute {
+        protected IsolatedStoragePermissionAttribute(SecurityAction action);
+        public IsolatedStorageContainment UsageAllowed { get; set; }
+        public long UserQuota { get; set; }
+    }
+    public interface IUnrestrictedPermission {
+        bool IsUnrestricted();
+    }
+    public sealed class KeyContainerPermission : CodeAccessPermission, IUnrestrictedPermission {
+        public KeyContainerPermission(KeyContainerPermissionFlags flags);
+        public KeyContainerPermission(KeyContainerPermissionFlags flags, KeyContainerPermissionAccessEntry[] accessList);
+        public KeyContainerPermission(PermissionState state);
+        public KeyContainerPermissionAccessEntryCollection AccessEntries { get; }
+        public KeyContainerPermissionFlags Flags { get; }
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement securityElement);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class KeyContainerPermissionAccessEntry {
+        public KeyContainerPermissionAccessEntry(CspParameters parameters, KeyContainerPermissionFlags flags);
+        public KeyContainerPermissionAccessEntry(string keyContainerName, KeyContainerPermissionFlags flags);
+        public KeyContainerPermissionAccessEntry(string keyStore, string providerName, int providerType, string keyContainerName, int keySpec, KeyContainerPermissionFlags flags);
+        public KeyContainerPermissionFlags Flags { get; set; }
+        public string KeyContainerName { get; set; }
+        public int KeySpec { get; set; }
+        public string KeyStore { get; set; }
+        public string ProviderName { get; set; }
+        public int ProviderType { get; set; }
+        public override bool Equals(object o);
+        public override int GetHashCode();
+    }
+    public sealed class KeyContainerPermissionAccessEntryCollection : ICollection, IEnumerable {
+        public KeyContainerPermissionAccessEntryCollection();
+        public int Count { get; }
+        public bool IsSynchronized { get; }
+        public KeyContainerPermissionAccessEntry this[int index] { get; }
+        public object SyncRoot { get; }
+        public int Add(KeyContainerPermissionAccessEntry accessEntry);
+        public void Clear();
+        public void CopyTo(Array array, int index);
+        public void CopyTo(KeyContainerPermissionAccessEntry[] array, int index);
+        public KeyContainerPermissionAccessEntryEnumerator GetEnumerator();
+        public int IndexOf(KeyContainerPermissionAccessEntry accessEntry);
+        public void Remove(KeyContainerPermissionAccessEntry accessEntry);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public sealed class KeyContainerPermissionAccessEntryEnumerator : IEnumerator {
+        public KeyContainerPermissionAccessEntryEnumerator();
+        public KeyContainerPermissionAccessEntry Current { get; }
+        object System.Collections.IEnumerator.Current { get; }
+        public bool MoveNext();
+        public void Reset();
+    }
+    public sealed class KeyContainerPermissionAttribute : CodeAccessSecurityAttribute {
+        public KeyContainerPermissionAttribute(SecurityAction action);
+        public KeyContainerPermissionFlags Flags { get; set; }
+        public string KeyContainerName { get; set; }
+        public int KeySpec { get; set; }
+        public string KeyStore { get; set; }
+        public string ProviderName { get; set; }
+        public int ProviderType { get; set; }
+        public override IPermission CreatePermission();
+    }
+    public enum KeyContainerPermissionFlags {
+        AllFlags = 13111,
+        ChangeAcl = 8192,
+        Create = 1,
+        Decrypt = 512,
+        Delete = 4,
+        Export = 32,
+        Import = 16,
+        NoFlags = 0,
+        Open = 2,
+        Sign = 256,
+        ViewAcl = 4096,
+    }
+    public sealed class PermissionSetAttribute : CodeAccessSecurityAttribute {
+        public PermissionSetAttribute(SecurityAction action);
+        public string File { get; set; }
+        public string Hex { get; set; }
+        public string Name { get; set; }
+        public bool UnicodeEncoded { get; set; }
+        public string XML { get; set; }
+        public override IPermission CreatePermission();
+        public PermissionSet CreatePermissionSet();
+    }
+    public enum PermissionState {
+        None = 0,
+        Unrestricted = 1,
+    }
+    public sealed class PrincipalPermission : IPermission, ISecurityEncodable, IUnrestrictedPermission {
+        public PrincipalPermission(PermissionState state);
+        public PrincipalPermission(string name, string role);
+        public PrincipalPermission(string name, string role, bool isAuthenticated);
+        public IPermission Copy();
+        public void Demand();
+        public override bool Equals(object o);
+        public void FromXml(SecurityElement elem);
+        public override int GetHashCode();
+        public IPermission Intersect(IPermission target);
+        public bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public override string ToString();
+        public SecurityElement ToXml();
+        public IPermission Union(IPermission other);
+    }
+    public sealed class PrincipalPermissionAttribute : CodeAccessSecurityAttribute {
+        public PrincipalPermissionAttribute(SecurityAction action);
+        public bool Authenticated { get; set; }
+        public string Name { get; set; }
+        public string Role { get; set; }
+        public override IPermission CreatePermission();
+    }
+    public sealed class PublisherIdentityPermission : CodeAccessPermission {
+        public PublisherIdentityPermission(PermissionState state);
+        public PublisherIdentityPermission(X509Certificate certificate);
+        public X509Certificate Certificate { get; set; }
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement esd);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class PublisherIdentityPermissionAttribute : CodeAccessSecurityAttribute {
+        public PublisherIdentityPermissionAttribute(SecurityAction action);
+        public string CertFile { get; set; }
+        public string SignedFile { get; set; }
+        public string X509Certificate { get; set; }
+        public override IPermission CreatePermission();
+    }
+    public sealed class ReflectionPermission : CodeAccessPermission, IUnrestrictedPermission {
+        public ReflectionPermission(PermissionState state);
+        public ReflectionPermission(ReflectionPermissionFlag flag);
+        public ReflectionPermissionFlag Flags { get; set; }
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement esd);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission other);
+    }
+    public sealed class ReflectionPermissionAttribute : CodeAccessSecurityAttribute {
+        public ReflectionPermissionAttribute(SecurityAction action);
+        public ReflectionPermissionFlag Flags { get; set; }
+        public bool MemberAccess { get; set; }
+        public bool ReflectionEmit { get; set; }
+        public bool RestrictedMemberAccess { get; set; }
+        public bool TypeInformation { get; set; }
+        public override IPermission CreatePermission();
+    }
+    public enum ReflectionPermissionFlag {
+        AllFlags = 7,
+        MemberAccess = 2,
+        NoFlags = 0,
+        ReflectionEmit = 4,
+        RestrictedMemberAccess = 8,
+        TypeInformation = 1,
+    }
+    public sealed class RegistryPermission : CodeAccessPermission, IUnrestrictedPermission {
+        public RegistryPermission(PermissionState state);
+        public RegistryPermission(RegistryPermissionAccess access, AccessControlActions control, string pathList);
+        public RegistryPermission(RegistryPermissionAccess access, string pathList);
+        public void AddPathList(RegistryPermissionAccess access, AccessControlActions actions, string pathList);
+        public void AddPathList(RegistryPermissionAccess access, string pathList);
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement elem);
+        public string GetPathList(RegistryPermissionAccess access);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public void SetPathList(RegistryPermissionAccess access, string pathList);
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission other);
+    }
+    public enum RegistryPermissionAccess {
+        AllAccess = 7,
+        Create = 4,
+        NoAccess = 0,
+        Read = 1,
+        Write = 2,
+    }
+    public sealed class RegistryPermissionAttribute : CodeAccessSecurityAttribute {
+        public RegistryPermissionAttribute(SecurityAction action);
+        public string All { get; set; }
+        public string ChangeAccessControl { get; set; }
+        public string Create { get; set; }
+        public string Read { get; set; }
+        public string ViewAccessControl { get; set; }
+        public string ViewAndModify { get; set; }
+        public string Write { get; set; }
+        public override IPermission CreatePermission();
+    }
+    public abstract class ResourcePermissionBase : CodeAccessPermission, IUnrestrictedPermission {
+        public const string Any = "*";
+        public const string Local = ".";
+        protected ResourcePermissionBase();
+        protected ResourcePermissionBase(PermissionState state);
+        protected Type PermissionAccessType { get; set; }
+        protected string[] TagNames { get; set; }
+        protected void AddPermissionAccess(ResourcePermissionBaseEntry entry);
+        protected void Clear();
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement securityElement);
+        protected ResourcePermissionBaseEntry[] GetPermissionEntries();
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        protected void RemovePermissionAccess(ResourcePermissionBaseEntry entry);
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public class ResourcePermissionBaseEntry {
+        public ResourcePermissionBaseEntry();
+        public ResourcePermissionBaseEntry(int permissionAccess, string[] permissionAccessPath);
+        public int PermissionAccess { get; }
+        public string[] PermissionAccessPath { get; }
+    }
+    public sealed class SecurityPermission : CodeAccessPermission, IUnrestrictedPermission {
+        public SecurityPermission(PermissionState state);
+        public SecurityPermission(SecurityPermissionFlag flag);
+        public SecurityPermissionFlag Flags { get; set; }
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement esd);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class SiteIdentityPermission : CodeAccessPermission {
+        public SiteIdentityPermission(PermissionState state);
+        public SiteIdentityPermission(string site);
+        public string Site { get; set; }
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement esd);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class SiteIdentityPermissionAttribute : CodeAccessSecurityAttribute {
+        public SiteIdentityPermissionAttribute(SecurityAction action);
+        public string Site { get; set; }
+        public override IPermission CreatePermission();
+    }
+    public sealed class StorePermission : CodeAccessPermission, IUnrestrictedPermission {
+        public StorePermission(PermissionState state);
+        public StorePermission(StorePermissionFlags flag);
+        public StorePermissionFlags Flags { get; set; }
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement securityElement);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class StorePermissionAttribute : CodeAccessSecurityAttribute {
+        public StorePermissionAttribute(SecurityAction action);
+        public bool AddToStore { get; set; }
+        public bool CreateStore { get; set; }
+        public bool DeleteStore { get; set; }
+        public bool EnumerateCertificates { get; set; }
+        public bool EnumerateStores { get; set; }
+        public StorePermissionFlags Flags { get; set; }
+        public bool OpenStore { get; set; }
+        public bool RemoveFromStore { get; set; }
+        public override IPermission CreatePermission();
+    }
+    public enum StorePermissionFlags {
+        AddToStore = 32,
+        AllFlags = 247,
+        CreateStore = 1,
+        DeleteStore = 2,
+        EnumerateCertificates = 128,
+        EnumerateStores = 4,
+        NoFlags = 0,
+        OpenStore = 16,
+        RemoveFromStore = 64,
+    }
+    public sealed class StrongNameIdentityPermission : CodeAccessPermission {
+        public StrongNameIdentityPermission(PermissionState state);
+        public StrongNameIdentityPermission(StrongNamePublicKeyBlob blob, string name, Version version);
+        public string Name { get; set; }
+        public StrongNamePublicKeyBlob PublicKey { get; set; }
+        public Version Version { get; set; }
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement e);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class StrongNameIdentityPermissionAttribute : CodeAccessSecurityAttribute {
+        public StrongNameIdentityPermissionAttribute(SecurityAction action);
+        public string Name { get; set; }
+        public string PublicKey { get; set; }
+        public string Version { get; set; }
+        public override IPermission CreatePermission();
+    }
+    public sealed class StrongNamePublicKeyBlob {
+        public StrongNamePublicKeyBlob(byte[] publicKey);
+        public override bool Equals(object o);
+        public override int GetHashCode();
+        public override string ToString();
+    }
+    public sealed class TypeDescriptorPermission : CodeAccessPermission, IUnrestrictedPermission {
+        public TypeDescriptorPermission(PermissionState state);
+        public TypeDescriptorPermission(TypeDescriptorPermissionFlags flag);
+        public TypeDescriptorPermissionFlags Flags { get; set; }
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement securityElement);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class TypeDescriptorPermissionAttribute : CodeAccessSecurityAttribute {
+        public TypeDescriptorPermissionAttribute(SecurityAction action);
+        public TypeDescriptorPermissionFlags Flags { get; set; }
+        public bool RestrictedRegistrationAccess { get; set; }
+        public override IPermission CreatePermission();
+    }
+    public enum TypeDescriptorPermissionFlags {
+        NoFlags = 0,
+        RestrictedRegistrationAccess = 1,
+    }
+    public sealed class UIPermission : CodeAccessPermission, IUnrestrictedPermission {
+        public UIPermission(PermissionState state);
+        public UIPermission(UIPermissionClipboard clipboardFlag);
+        public UIPermission(UIPermissionWindow windowFlag);
+        public UIPermission(UIPermissionWindow windowFlag, UIPermissionClipboard clipboardFlag);
+        public UIPermissionClipboard Clipboard { get; set; }
+        public UIPermissionWindow Window { get; set; }
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement esd);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class UIPermissionAttribute : CodeAccessSecurityAttribute {
+        public UIPermissionAttribute(SecurityAction action);
+        public UIPermissionClipboard Clipboard { get; set; }
+        public UIPermissionWindow Window { get; set; }
+        public override IPermission CreatePermission();
+    }
+    public enum UIPermissionClipboard {
+        AllClipboard = 2,
+        NoClipboard = 0,
+        OwnClipboard = 1,
+    }
+    public enum UIPermissionWindow {
+        AllWindows = 3,
+        NoWindows = 0,
+        SafeSubWindows = 1,
+        SafeTopLevelWindows = 2,
+    }
+    public sealed class UrlIdentityPermission : CodeAccessPermission {
+        public UrlIdentityPermission(PermissionState state);
+        public UrlIdentityPermission(string site);
+        public string Url { get; set; }
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement esd);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class UrlIdentityPermissionAttribute : CodeAccessSecurityAttribute {
+        public UrlIdentityPermissionAttribute(SecurityAction action);
+        public string Url { get; set; }
+        public override IPermission CreatePermission();
+    }
+    public sealed class ZoneIdentityPermission : CodeAccessPermission {
+        public ZoneIdentityPermission(PermissionState state);
+        public ZoneIdentityPermission(SecurityZone zone);
+        public SecurityZone SecurityZone { get; set; }
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement esd);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class ZoneIdentityPermissionAttribute : CodeAccessSecurityAttribute {
+        public ZoneIdentityPermissionAttribute(SecurityAction action);
+        public SecurityZone Zone { get; set; }
+        public override IPermission CreatePermission();
+    }
 }
+namespace System.Security.Policy {
+    public sealed class AllMembershipCondition : IMembershipCondition, ISecurityEncodable, ISecurityPolicyEncodable {
+        public AllMembershipCondition();
+        public bool Check(Evidence evidence);
+        public IMembershipCondition Copy();
+        public override bool Equals(object o);
+        public void FromXml(SecurityElement e);
+        public void FromXml(SecurityElement e, PolicyLevel level);
+        public override int GetHashCode();
+        public override string ToString();
+        public SecurityElement ToXml();
+        public SecurityElement ToXml(PolicyLevel level);
+    }
+    public sealed class ApplicationDirectory : EvidenceBase {
+        public ApplicationDirectory(string name);
+        public string Directory { get; }
+        public object Copy();
+        public override bool Equals(object o);
+        public override int GetHashCode();
+        public override string ToString();
+    }
+    public sealed class ApplicationDirectoryMembershipCondition : IMembershipCondition, ISecurityEncodable, ISecurityPolicyEncodable {
+        public ApplicationDirectoryMembershipCondition();
+        public bool Check(Evidence evidence);
+        public IMembershipCondition Copy();
+        public override bool Equals(object o);
+        public void FromXml(SecurityElement e);
+        public void FromXml(SecurityElement e, PolicyLevel level);
+        public override int GetHashCode();
+        public override string ToString();
+        public SecurityElement ToXml();
+        public SecurityElement ToXml(PolicyLevel level);
+    }
+    public sealed class ApplicationTrust : EvidenceBase, ISecurityEncodable {
+        public ApplicationTrust();
+        public ApplicationTrust(ApplicationIdentity identity);
+        public ApplicationTrust(PermissionSet defaultGrantSet, IEnumerable<StrongName> fullTrustAssemblies);
+        public ApplicationIdentity ApplicationIdentity { get; set; }
+        public PolicyStatement DefaultGrantSet { get; set; }
+        public object ExtraInfo { get; set; }
+        public IList<StrongName> FullTrustAssemblies { get; }
+        public bool IsApplicationTrustedToRun { get; set; }
+        public bool Persist { get; set; }
+        public void FromXml(SecurityElement element);
+        public SecurityElement ToXml();
+    }
+    public sealed class ApplicationTrustCollection : ICollection, IEnumerable {
+        public int Count { get; }
+        public bool IsSynchronized { get; }
+        public ApplicationTrust this[int index] { get; }
+        public ApplicationTrust this[string appFullName] { get; }
+        public object SyncRoot { get; }
+        public int Add(ApplicationTrust trust);
+        public void AddRange(ApplicationTrustCollection trusts);
+        public void AddRange(ApplicationTrust[] trusts);
+        public void Clear();
+        public void CopyTo(ApplicationTrust[] array, int index);
+        public ApplicationTrustCollection Find(ApplicationIdentity applicationIdentity, ApplicationVersionMatch versionMatch);
+        public ApplicationTrustEnumerator GetEnumerator();
+        public void Remove(ApplicationIdentity applicationIdentity, ApplicationVersionMatch versionMatch);
+        public void Remove(ApplicationTrust trust);
+        public void RemoveRange(ApplicationTrustCollection trusts);
+        public void RemoveRange(ApplicationTrust[] trusts);
+        void System.Collections.ICollection.CopyTo(Array array, int index);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+    }
+    public sealed class ApplicationTrustEnumerator : IEnumerator {
+        public ApplicationTrust Current { get; }
+        object System.Collections.IEnumerator.Current { get; }
+        public bool MoveNext();
+        public void Reset();
+    }
+    public enum ApplicationVersionMatch {
+        MatchAllVersions = 1,
+        MatchExactVersion = 0,
+    }
+    public class CodeConnectAccess {
+        public static readonly string AnyScheme;
+        public static readonly int DefaultPort;
+        public static readonly int OriginPort;
+        public static readonly string OriginScheme;
+        public CodeConnectAccess(string allowScheme, int allowPort);
+        public int Port { get; }
+        public string Scheme { get; }
+        public static CodeConnectAccess CreateAnySchemeAccess(int allowPort);
+        public static CodeConnectAccess CreateOriginSchemeAccess(int allowPort);
+        public override bool Equals(object o);
+        public override int GetHashCode();
+    }
+    public abstract class CodeGroup {
+        protected CodeGroup(IMembershipCondition membershipCondition, PolicyStatement policy);
+        public virtual string AttributeString { get; }
+        public IList Children { get; set; }
+        public string Description { get; set; }
+        public IMembershipCondition MembershipCondition { get; set; }
+        public abstract string MergeLogic { get; }
+        public string Name { get; set; }
+        public virtual string PermissionSetName { get; }
+        public PolicyStatement PolicyStatement { get; set; }
+        public void AddChild(CodeGroup group);
+        public abstract CodeGroup Copy();
+        protected virtual void CreateXml(SecurityElement element, PolicyLevel level);
+        public bool Equals(CodeGroup cg, bool compareChildren);
+        public override bool Equals(object o);
+        public void FromXml(SecurityElement e);
+        public void FromXml(SecurityElement e, PolicyLevel level);
+        public override int GetHashCode();
+        protected virtual void ParseXml(SecurityElement e, PolicyLevel level);
+        public void RemoveChild(CodeGroup group);
+        public abstract PolicyStatement Resolve(Evidence evidence);
+        public abstract CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
+        public SecurityElement ToXml();
+        public SecurityElement ToXml(PolicyLevel level);
+    }
+    public sealed class Evidence : ICollection, IEnumerable {
+        public Evidence();
+        public Evidence(Evidence evidence);
+        public Evidence(EvidenceBase[] hostEvidence, EvidenceBase[] assemblyEvidence);
+        public Evidence(object[] hostEvidence, object[] assemblyEvidence);
+        public int Count { get; }
+        public bool IsReadOnly { get; }
+        public bool IsSynchronized { get; }
+        public bool Locked { get; set; }
+        public object SyncRoot { get; }
+        public void AddAssembly(object id);
+        public void AddAssemblyEvidence<T>(T evidence) where T : EvidenceBase;
+        public void AddHost(object id);
+        public void AddHostEvidence<T>(T evidence) where T : EvidenceBase;
+        public void Clear();
+        public Evidence Clone();
+        public void CopyTo(Array array, int index);
+        public IEnumerator GetAssemblyEnumerator();
+        public T GetAssemblyEvidence<T>() where T : EvidenceBase;
+        public IEnumerator GetEnumerator();
+        public IEnumerator GetHostEnumerator();
+        public T GetHostEvidence<T>() where T : EvidenceBase;
+        public void Merge(Evidence evidence);
+        public void RemoveType(Type t);
+    }
+    public abstract class EvidenceBase {
+        protected EvidenceBase();
+        public virtual EvidenceBase Clone();
+    }
+    public sealed class FileCodeGroup : CodeGroup {
+        public FileCodeGroup(IMembershipCondition membershipCondition, FileIOPermissionAccess access);
+        public override string AttributeString { get; }
+        public override string MergeLogic { get; }
+        public override string PermissionSetName { get; }
+        public override CodeGroup Copy();
+        public override bool Equals(object o);
+        public override int GetHashCode();
+        public override PolicyStatement Resolve(Evidence evidence);
+        public override CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
+    }
+    public sealed class FirstMatchCodeGroup : CodeGroup {
+        public FirstMatchCodeGroup(IMembershipCondition membershipCondition, PolicyStatement policy);
+        public override string MergeLogic { get; }
+        public override CodeGroup Copy();
+        public override PolicyStatement Resolve(Evidence evidence);
+        public override CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
+    }
+    public sealed class GacInstalled : EvidenceBase, IIdentityPermissionFactory {
+        public GacInstalled();
+        public object Copy();
+        public IPermission CreateIdentityPermission(Evidence evidence);
+        public override bool Equals(object o);
+        public override int GetHashCode();
+        public override string ToString();
+    }
+    public sealed class GacMembershipCondition : IMembershipCondition, ISecurityEncodable, ISecurityPolicyEncodable {
+        public GacMembershipCondition();
+        public bool Check(Evidence evidence);
+        public IMembershipCondition Copy();
+        public override bool Equals(object o);
+        public void FromXml(SecurityElement e);
+        public void FromXml(SecurityElement e, PolicyLevel level);
+        public override int GetHashCode();
+        public override string ToString();
+        public SecurityElement ToXml();
+        public SecurityElement ToXml(PolicyLevel level);
+    }
+    public sealed class Hash : EvidenceBase, ISerializable {
+        public Hash(Assembly assembly);
+        public byte[] MD5 { get; }
+        public byte[] SHA1 { get; }
+        public byte[] SHA256 { get; }
+        public static Hash CreateMD5(byte[] md5);
+        public static Hash CreateSHA1(byte[] sha1);
+        public static Hash CreateSHA256(byte[] sha256);
+        public byte[] GenerateHash(HashAlgorithm hashAlg);
+        public void GetObjectData(SerializationInfo info, StreamingContext context);
+        public override string ToString();
+    }
+    public sealed class HashMembershipCondition : IDeserializationCallback, IMembershipCondition, ISecurityEncodable, ISecurityPolicyEncodable, ISerializable {
+        public HashMembershipCondition(HashAlgorithm hashAlg, byte[] value);
+        public HashAlgorithm HashAlgorithm { get; set; }
+        public byte[] HashValue { get; set; }
+        public bool Check(Evidence evidence);
+        public IMembershipCondition Copy();
+        public override bool Equals(object o);
+        public void FromXml(SecurityElement e);
+        public void FromXml(SecurityElement e, PolicyLevel level);
+        public override int GetHashCode();
+        void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
+        void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
+        public override string ToString();
+        public SecurityElement ToXml();
+        public SecurityElement ToXml(PolicyLevel level);
+    }
+    public interface IIdentityPermissionFactory {
+        IPermission CreateIdentityPermission(Evidence evidence);
+    }
+    public interface IMembershipCondition : ISecurityEncodable, ISecurityPolicyEncodable {
+        bool Check(Evidence evidence);
+        IMembershipCondition Copy();
+        bool Equals(object obj);
+        string ToString();
+    }
+    public sealed class NetCodeGroup : CodeGroup {
+        public static readonly string AbsentOriginScheme;
+        public static readonly string AnyOtherOriginScheme;
+        public NetCodeGroup(IMembershipCondition membershipCondition);
+        public override string AttributeString { get; }
+        public override string MergeLogic { get; }
+        public override string PermissionSetName { get; }
+        public void AddConnectAccess(string originScheme, CodeConnectAccess connectAccess);
+        public override CodeGroup Copy();
+        public override bool Equals(object o);
+        public DictionaryEntry[] GetConnectAccessRules();
+        public override int GetHashCode();
+        public void ResetConnectAccess();
+        public override PolicyStatement Resolve(Evidence evidence);
+        public override CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
+    }
+    public sealed class PermissionRequestEvidence : EvidenceBase {
+        public PermissionRequestEvidence(PermissionSet request, PermissionSet optional, PermissionSet denied);
+        public PermissionSet DeniedPermissions { get; }
+        public PermissionSet OptionalPermissions { get; }
+        public PermissionSet RequestedPermissions { get; }
+        public PermissionRequestEvidence Copy();
+        public override string ToString();
+    }
+    public class PolicyException : SystemException {
+        public PolicyException();
+        protected PolicyException(SerializationInfo info, StreamingContext context);
+        public PolicyException(string message);
+        public PolicyException(string message, Exception exception);
+    }
+    public sealed class PolicyLevel {
+        public IList FullTrustAssemblies { get; }
+        public string Label { get; }
+        public IList NamedPermissionSets { get; }
+        public CodeGroup RootCodeGroup { get; set; }
+        public string StoreLocation { get; }
+        public PolicyLevelType Type { get; }
+        public void AddFullTrustAssembly(StrongName sn);
+        public void AddFullTrustAssembly(StrongNameMembershipCondition snMC);
+        public void AddNamedPermissionSet(NamedPermissionSet permSet);
+        public NamedPermissionSet ChangeNamedPermissionSet(string name, PermissionSet pSet);
+        public static PolicyLevel CreateAppDomainLevel();
+        public void FromXml(SecurityElement e);
+        public NamedPermissionSet GetNamedPermissionSet(string name);
+        public void Recover();
+        public void RemoveFullTrustAssembly(StrongName sn);
+        public void RemoveFullTrustAssembly(StrongNameMembershipCondition snMC);
+        public NamedPermissionSet RemoveNamedPermissionSet(NamedPermissionSet permSet);
+        public NamedPermissionSet RemoveNamedPermissionSet(string name);
+        public void Reset();
+        public PolicyStatement Resolve(Evidence evidence);
+        public CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
+        public SecurityElement ToXml();
+    }
+    public sealed class PolicyStatement : ISecurityEncodable, ISecurityPolicyEncodable {
+        public PolicyStatement(PermissionSet permSet);
+        public PolicyStatement(PermissionSet permSet, PolicyStatementAttribute attributes);
+        public PolicyStatementAttribute Attributes { get; set; }
+        public string AttributeString { get; }
+        public PermissionSet PermissionSet { get; set; }
+        public PolicyStatement Copy();
+        public override bool Equals(object o);
+        public void FromXml(SecurityElement et);
+        public void FromXml(SecurityElement et, PolicyLevel level);
+        public override int GetHashCode();
+        public SecurityElement ToXml();
+        public SecurityElement ToXml(PolicyLevel level);
+    }
+    public enum PolicyStatementAttribute {
+        All = 3,
+        Exclusive = 1,
+        LevelFinal = 2,
+        Nothing = 0,
+    }
+    public sealed class Publisher : EvidenceBase, IIdentityPermissionFactory {
+        public Publisher(X509Certificate cert);
+        public X509Certificate Certificate { get; }
+        public object Copy();
+        public IPermission CreateIdentityPermission(Evidence evidence);
+        public override bool Equals(object o);
+        public override int GetHashCode();
+        public override string ToString();
+    }
+    public sealed class PublisherMembershipCondition : IMembershipCondition, ISecurityEncodable, ISecurityPolicyEncodable {
+        public PublisherMembershipCondition(X509Certificate certificate);
+        public X509Certificate Certificate { get; set; }
+        public bool Check(Evidence evidence);
+        public IMembershipCondition Copy();
+        public override bool Equals(object o);
+        public void FromXml(SecurityElement e);
+        public void FromXml(SecurityElement e, PolicyLevel level);
+        public override int GetHashCode();
+        public override string ToString();
+        public SecurityElement ToXml();
+        public SecurityElement ToXml(PolicyLevel level);
+    }
+    public sealed class Site : EvidenceBase, IIdentityPermissionFactory {
+        public Site(string name);
+        public string Name { get; }
+        public object Copy();
+        public static Site CreateFromUrl(string url);
+        public IPermission CreateIdentityPermission(Evidence evidence);
+        public override bool Equals(object o);
+        public override int GetHashCode();
+        public override string ToString();
+    }
+    public sealed class SiteMembershipCondition : IMembershipCondition, ISecurityEncodable, ISecurityPolicyEncodable {
+        public SiteMembershipCondition(string site);
+        public string Site { get; set; }
+        public bool Check(Evidence evidence);
+        public IMembershipCondition Copy();
+        public override bool Equals(object o);
+        public void FromXml(SecurityElement e);
+        public void FromXml(SecurityElement e, PolicyLevel level);
+        public override int GetHashCode();
+        public override string ToString();
+        public SecurityElement ToXml();
+        public SecurityElement ToXml(PolicyLevel level);
+    }
+    public sealed class StrongName : EvidenceBase, IIdentityPermissionFactory {
+        public StrongName(StrongNamePublicKeyBlob blob, string name, Version version);
+        public string Name { get; }
+        public StrongNamePublicKeyBlob PublicKey { get; }
+        public Version Version { get; }
+        public object Copy();
+        public IPermission CreateIdentityPermission(Evidence evidence);
+        public override bool Equals(object o);
+        public override int GetHashCode();
+        public override string ToString();
+    }
+    public sealed class StrongNameMembershipCondition : IMembershipCondition, ISecurityEncodable, ISecurityPolicyEncodable {
+        public StrongNameMembershipCondition(StrongNamePublicKeyBlob blob, string name, Version version);
+        public string Name { get; set; }
+        public StrongNamePublicKeyBlob PublicKey { get; set; }
+        public Version Version { get; set; }
+        public bool Check(Evidence evidence);
+        public IMembershipCondition Copy();
+        public override bool Equals(object o);
+        public void FromXml(SecurityElement e);
+        public void FromXml(SecurityElement e, PolicyLevel level);
+        public override int GetHashCode();
+        public override string ToString();
+        public SecurityElement ToXml();
+        public SecurityElement ToXml(PolicyLevel level);
+    }
+    public class TrustManagerContext {
+        public TrustManagerContext();
+        public TrustManagerContext(TrustManagerUIContext uiContext);
+        public virtual bool IgnorePersistedDecision { get; set; }
+        public virtual bool KeepAlive { get; set; }
+        public virtual bool NoPrompt { get; set; }
+        public virtual bool Persist { get; set; }
+        public virtual ApplicationIdentity PreviousApplicationIdentity { get; set; }
+        public virtual TrustManagerUIContext UIContext { get; set; }
+    }
+    public enum TrustManagerUIContext {
+        Install = 0,
+        Run = 2,
+        Upgrade = 1,
+    }
+    public sealed class UnionCodeGroup : CodeGroup {
+        public UnionCodeGroup(IMembershipCondition membershipCondition, PolicyStatement policy);
+        public override string MergeLogic { get; }
+        public override CodeGroup Copy();
+        public override PolicyStatement Resolve(Evidence evidence);
+        public override CodeGroup ResolveMatchingCodeGroups(Evidence evidence);
+    }
+    public sealed class Url : EvidenceBase, IIdentityPermissionFactory {
+        public Url(string name);
+        public string Value { get; }
+        public object Copy();
+        public IPermission CreateIdentityPermission(Evidence evidence);
+        public override bool Equals(object o);
+        public override int GetHashCode();
+        public override string ToString();
+    }
+    public sealed class UrlMembershipCondition : IMembershipCondition, ISecurityEncodable, ISecurityPolicyEncodable {
+        public UrlMembershipCondition(string url);
+        public string Url { get; set; }
+        public bool Check(Evidence evidence);
+        public IMembershipCondition Copy();
+        public override bool Equals(object o);
+        public void FromXml(SecurityElement e);
+        public void FromXml(SecurityElement e, PolicyLevel level);
+        public override int GetHashCode();
+        public override string ToString();
+        public SecurityElement ToXml();
+        public SecurityElement ToXml(PolicyLevel level);
+    }
+    public sealed class Zone : EvidenceBase, IIdentityPermissionFactory {
+        public Zone(SecurityZone zone);
+        public SecurityZone SecurityZone { get; }
+        public object Copy();
+        public static Zone CreateFromUrl(string url);
+        public IPermission CreateIdentityPermission(Evidence evidence);
+        public override bool Equals(object o);
+        public override int GetHashCode();
+        public override string ToString();
+    }
+    public sealed class ZoneMembershipCondition : IMembershipCondition, ISecurityEncodable, ISecurityPolicyEncodable {
+        public ZoneMembershipCondition(SecurityZone zone);
+        public SecurityZone SecurityZone { get; set; }
+        public bool Check(Evidence evidence);
+        public IMembershipCondition Copy();
+        public override bool Equals(object o);
+        public void FromXml(SecurityElement e);
+        public void FromXml(SecurityElement e, PolicyLevel level);
+        public override int GetHashCode();
+        public override string ToString();
+        public SecurityElement ToXml();
+        public SecurityElement ToXml(PolicyLevel level);
+    }
+}
 namespace System.Security.Principal {
+    public sealed class IdentityNotMappedException : SystemException {
+        public IdentityNotMappedException();
+        public IdentityNotMappedException(string message);
+        public IdentityNotMappedException(string message, Exception inner);
+        public IdentityReferenceCollection UnmappedIdentities { get; }
+        public override void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
+    }
+    public abstract class IdentityReference {
+        public abstract string Value { get; }
+        public abstract override bool Equals(object o);
+        public abstract override int GetHashCode();
+        public abstract bool IsValidTargetType(Type targetType);
+        public static bool operator ==(IdentityReference left, IdentityReference right);
+        public static bool operator !=(IdentityReference left, IdentityReference right);
+        public abstract override string ToString();
+        public abstract IdentityReference Translate(Type targetType);
+    }
+    public class IdentityReferenceCollection : ICollection<IdentityReference>, IEnumerable, IEnumerable<IdentityReference> {
+        public IdentityReferenceCollection();
+        public IdentityReferenceCollection(int capacity);
+        public int Count { get; }
+        public IdentityReference this[int index] { get; set; }
+        bool System.Collections.Generic.ICollection<System.Security.Principal.IdentityReference>.IsReadOnly { get; }
+        public void Add(IdentityReference identity);
+        public void Clear();
+        public bool Contains(IdentityReference identity);
+        public void CopyTo(IdentityReference[] array, int offset);
+        public IEnumerator<IdentityReference> GetEnumerator();
+        public bool Remove(IdentityReference identity);
+        IEnumerator System.Collections.IEnumerable.GetEnumerator();
+        public IdentityReferenceCollection Translate(Type targetType);
+        public IdentityReferenceCollection Translate(Type targetType, bool forceSuccess);
+    }
+    public sealed class NTAccount : IdentityReference {
+        public NTAccount(string name);
+        public NTAccount(string domainName, string accountName);
+        public override string Value { get; }
+        public override bool Equals(object o);
+        public override int GetHashCode();
+        public override bool IsValidTargetType(Type targetType);
+        public static bool operator ==(NTAccount left, NTAccount right);
+        public static bool operator !=(NTAccount left, NTAccount right);
+        public override string ToString();
+        public override IdentityReference Translate(Type targetType);
+    }
+    public sealed class SecurityIdentifier : IdentityReference, IComparable<SecurityIdentifier> {
+        public static readonly int MaxBinaryLength;
+        public static readonly int MinBinaryLength;
+        public SecurityIdentifier(byte[] binaryForm, int offset);
+        public SecurityIdentifier(IntPtr binaryForm);
+        public SecurityIdentifier(string sddlForm);
+        public SecurityIdentifier(WellKnownSidType sidType, SecurityIdentifier domainSid);
+        public SecurityIdentifier AccountDomainSid { get; }
+        public int BinaryLength { get; }
+        public override string Value { get; }
+        public int CompareTo(SecurityIdentifier sid);
+        public override bool Equals(object o);
+        public bool Equals(SecurityIdentifier sid);
+        public void GetBinaryForm(byte[] binaryForm, int offset);
+        public override int GetHashCode();
+        public bool IsAccountSid();
+        public bool IsEqualDomainSid(SecurityIdentifier sid);
+        public override bool IsValidTargetType(Type targetType);
+        public bool IsWellKnown(WellKnownSidType type);
+        public static bool operator ==(SecurityIdentifier left, SecurityIdentifier right);
+        public static bool operator !=(SecurityIdentifier left, SecurityIdentifier right);
+        public override string ToString();
+        public override IdentityReference Translate(Type targetType);
+    }
+    public enum TokenAccessLevels {
+        AdjustDefault = 128,
+        AdjustGroups = 64,
+        AdjustPrivileges = 32,
+        AdjustSessionId = 256,
+        AllAccess = 983551,
+        AssignPrimary = 1,
+        Duplicate = 2,
+        Impersonate = 4,
+        MaximumAllowed = 33554432,
+        Query = 8,
+        QuerySource = 16,
+        Read = 131080,
+        Write = 131296,
+    }
+    public enum WellKnownSidType {
+        AccountAdministratorSid = 38,
+        AccountCertAdminsSid = 46,
+        AccountComputersSid = 44,
+        AccountControllersSid = 45,
+        AccountDomainAdminsSid = 41,
+        AccountDomainGuestsSid = 43,
+        AccountDomainUsersSid = 42,
+        AccountEnterpriseAdminsSid = 48,
+        AccountGuestSid = 39,
+        AccountKrbtgtSid = 40,
+        AccountPolicyAdminsSid = 49,
+        AccountRasAndIasServersSid = 50,
+        AccountSchemaAdminsSid = 47,
+        AnonymousSid = 13,
+        AuthenticatedUserSid = 17,
+        BatchSid = 10,
+        BuiltinAccountOperatorsSid = 30,
+        BuiltinAdministratorsSid = 26,
+        BuiltinAuthorizationAccessSid = 59,
+        BuiltinBackupOperatorsSid = 33,
+        BuiltinDomainSid = 25,
+        BuiltinGuestsSid = 28,
+        BuiltinIncomingForestTrustBuildersSid = 56,
+        BuiltinNetworkConfigurationOperatorsSid = 37,
+        BuiltinPerformanceLoggingUsersSid = 58,
+        BuiltinPerformanceMonitoringUsersSid = 57,
+        BuiltinPowerUsersSid = 29,
+        BuiltinPreWindows2000CompatibleAccessSid = 35,
+        BuiltinPrintOperatorsSid = 32,
+        BuiltinRemoteDesktopUsersSid = 36,
+        BuiltinReplicatorSid = 34,
+        BuiltinSystemOperatorsSid = 31,
+        BuiltinUsersSid = 27,
+        CreatorGroupServerSid = 6,
+        CreatorGroupSid = 4,
+        CreatorOwnerServerSid = 5,
+        CreatorOwnerSid = 3,
+        DialupSid = 8,
+        DigestAuthenticationSid = 52,
+        EnterpriseControllersSid = 15,
+        InteractiveSid = 11,
+        LocalServiceSid = 23,
+        LocalSid = 2,
+        LocalSystemSid = 22,
+        LogonIdsSid = 21,
+        MaxDefined = 60,
+        NetworkServiceSid = 24,
+        NetworkSid = 9,
+        NTAuthoritySid = 7,
+        NtlmAuthenticationSid = 51,
+        NullSid = 0,
+        OtherOrganizationSid = 55,
+        ProxySid = 14,
+        RemoteLogonIdSid = 20,
+        RestrictedCodeSid = 18,
+        SChannelAuthenticationSid = 53,
+        SelfSid = 16,
+        ServiceSid = 12,
+        TerminalServerSid = 19,
+        ThisOrganizationSid = 54,
+        WinAccountReadonlyControllersSid = 75,
+        WinApplicationPackageAuthoritySid = 83,
+        WinBuiltinAnyPackageSid = 84,
+        WinBuiltinCertSvcDComAccessGroup = 78,
+        WinBuiltinCryptoOperatorsSid = 64,
+        WinBuiltinDCOMUsersSid = 61,
+        WinBuiltinEventLogReadersGroup = 76,
+        WinBuiltinIUsersSid = 62,
+        WinBuiltinTerminalServerLicenseServersSid = 60,
+        WinCacheablePrincipalsGroupSid = 72,
+        WinCapabilityDocumentsLibrarySid = 91,
+        WinCapabilityEnterpriseAuthenticationSid = 93,
+        WinCapabilityInternetClientServerSid = 86,
+        WinCapabilityInternetClientSid = 85,
+        WinCapabilityMusicLibrarySid = 90,
+        WinCapabilityPicturesLibrarySid = 88,
+        WinCapabilityPrivateNetworkClientServerSid = 87,
+        WinCapabilityRemovableStorageSid = 94,
+        WinCapabilitySharedUserCertificatesSid = 92,
+        WinCapabilityVideosLibrarySid = 89,
+        WinConsoleLogonSid = 81,
+        WinCreatorOwnerRightsSid = 71,
+        WinEnterpriseReadonlyControllersSid = 74,
+        WinHighLabelSid = 68,
+        WinIUserSid = 63,
+        WinLocalLogonSid = 80,
+        WinLowLabelSid = 66,
+        WinMediumLabelSid = 67,
+        WinMediumPlusLabelSid = 79,
+        WinNewEnterpriseReadonlyControllersSid = 77,
+        WinNonCacheablePrincipalsGroupSid = 73,
+        WinSystemLabelSid = 69,
+        WinThisOrganizationCertificateSid = 82,
+        WinUntrustedLabelSid = 65,
+        WinWriteRestrictedCodeSid = 70,
+        WorldSid = 1,
+    }
+    public enum WindowsBuiltInRole {
+        AccountOperator = 548,
+        Administrator = 544,
+        BackupOperator = 551,
+        Guest = 546,
+        PowerUser = 547,
+        PrintOperator = 550,
+        Replicator = 552,
+        SystemOperator = 549,
+        User = 545,
+    }
+    public class WindowsIdentity : ClaimsIdentity, IDeserializationCallback, IDisposable, ISerializable {
+        public const string DefaultIssuer = "AD AUTHORITY";
+        public WindowsIdentity(IntPtr userToken);
+        public WindowsIdentity(IntPtr userToken, string type);
+        public WindowsIdentity(SerializationInfo info, StreamingContext context);
+        public WindowsIdentity(string sUserPrincipalName);
+        public SafeAccessTokenHandle AccessToken { get; }
+        public sealed override string AuthenticationType { get; }
+        public override IEnumerable<Claim> Claims { get; }
+        public IdentityReferenceCollection Groups { get; }
+        public TokenImpersonationLevel ImpersonationLevel { get; }
+        public virtual bool IsAnonymous { get; }
+        public override bool IsAuthenticated { get; }
+        public virtual bool IsGuest { get; }
+        public virtual bool IsSystem { get; }
+        public override string Name { get; }
+        public SecurityIdentifier Owner { get; }
+        public virtual IntPtr Token { get; }
+        public SecurityIdentifier User { get; }
+        public override ClaimsIdentity Clone();
+        public void Dispose();
+        protected virtual void Dispose(bool disposing);
+        public static WindowsIdentity GetAnonymous();
+        public static WindowsIdentity GetCurrent();
+        public static WindowsIdentity GetCurrent(bool ifImpersonating);
+        public static WindowsIdentity GetCurrent(TokenAccessLevels desiredAccess);
+        public static T RunImpersonated<T>(SafeAccessTokenHandle safeAccessTokenHandle, Func<T> func);
+        public static void RunImpersonated(SafeAccessTokenHandle safeAccessTokenHandle, Action action);
+        void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
+        void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
+    }
+    public class WindowsPrincipal : ClaimsPrincipal {
+        public WindowsPrincipal(WindowsIdentity ntIdentity);
+        public override IIdentity Identity { get; }
+        public virtual bool IsInRole(int rid);
+        public virtual bool IsInRole(SecurityIdentifier sid);
+        public override bool IsInRole(string role);
+        public virtual bool IsInRole(WindowsBuiltInRole role);
+    }
 }
+namespace System.ServiceModel.Syndication {
+    public class Atom10FeedFormatter : SyndicationFeedFormatter, IXmlSerializable {
+        public Atom10FeedFormatter();
+        public Atom10FeedFormatter(SyndicationFeed feedToWrite);
+        public Atom10FeedFormatter(Type feedTypeToCreate);
+        protected Type FeedType { get; }
+        public bool PreserveAttributeExtensions { get; set; }
+        public bool PreserveElementExtensions { get; set; }
+        public override string Version { get; }
+        public override bool CanRead(XmlReader reader);
+        protected override SyndicationFeed CreateFeedInstance();
+        public override void ReadFrom(XmlReader reader);
+        protected virtual SyndicationItem ReadItem(XmlReader reader, SyndicationFeed feed);
+        protected virtual IEnumerable<SyndicationItem> ReadItems(XmlReader reader, SyndicationFeed feed, out bool areAllItemsRead);
+        XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
+        void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
+        void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
+        protected virtual void WriteItem(XmlWriter writer, SyndicationItem item, Uri feedBaseUri);
+        protected virtual void WriteItems(XmlWriter writer, IEnumerable<SyndicationItem> items, Uri feedBaseUri);
+        public override void WriteTo(XmlWriter writer);
+    }
+    public class Atom10FeedFormatter<TSyndicationFeed> : Atom10FeedFormatter where TSyndicationFeed : SyndicationFeed, new() {
+        public Atom10FeedFormatter();
+        public Atom10FeedFormatter(TSyndicationFeed feedToWrite);
+        protected override SyndicationFeed CreateFeedInstance();
+    }
+    public class Atom10ItemFormatter : SyndicationItemFormatter, IXmlSerializable {
+        public Atom10ItemFormatter();
+        public Atom10ItemFormatter(SyndicationItem itemToWrite);
+        public Atom10ItemFormatter(Type itemTypeToCreate);
+        protected Type ItemType { get; }
+        public bool PreserveAttributeExtensions { get; set; }
+        public bool PreserveElementExtensions { get; set; }
+        public override string Version { get; }
+        public override bool CanRead(XmlReader reader);
+        protected override SyndicationItem CreateItemInstance();
+        public override void ReadFrom(XmlReader reader);
+        XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
+        void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
+        void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
+        public override void WriteTo(XmlWriter writer);
+    }
+    public class Atom10ItemFormatter<TSyndicationItem> : Atom10ItemFormatter where TSyndicationItem : SyndicationItem, new() {
+        public Atom10ItemFormatter();
+        public Atom10ItemFormatter(TSyndicationItem itemToWrite);
+        protected override SyndicationItem CreateItemInstance();
+    }
+    public class AtomPub10CategoriesDocumentFormatter : CategoriesDocumentFormatter, IXmlSerializable {
+        public AtomPub10CategoriesDocumentFormatter();
+        public AtomPub10CategoriesDocumentFormatter(CategoriesDocument documentToWrite);
+        public AtomPub10CategoriesDocumentFormatter(Type inlineDocumentType, Type referencedDocumentType);
+        public override string Version { get; }
+        public override bool CanRead(XmlReader reader);
+        protected override InlineCategoriesDocument CreateInlineCategoriesDocument();
+        protected override ReferencedCategoriesDocument CreateReferencedCategoriesDocument();
+        public override void ReadFrom(XmlReader reader);
+        XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
+        void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
+        void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
+        public override void WriteTo(XmlWriter writer);
+    }
+    public class AtomPub10ServiceDocumentFormatter : ServiceDocumentFormatter, IXmlSerializable {
+        public AtomPub10ServiceDocumentFormatter();
+        public AtomPub10ServiceDocumentFormatter(ServiceDocument documentToWrite);
+        public AtomPub10ServiceDocumentFormatter(Type documentTypeToCreate);
+        public override string Version { get; }
+        public override bool CanRead(XmlReader reader);
+        protected override ServiceDocument CreateDocumentInstance();
+        public override void ReadFrom(XmlReader reader);
+        XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
+        void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
+        void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
+        public override void WriteTo(XmlWriter writer);
+    }
+    public class AtomPub10ServiceDocumentFormatter<TServiceDocument> : AtomPub10ServiceDocumentFormatter where TServiceDocument : ServiceDocument, new() {
+        public AtomPub10ServiceDocumentFormatter();
+        public AtomPub10ServiceDocumentFormatter(TServiceDocument documentToWrite);
+        protected override ServiceDocument CreateDocumentInstance();
+    }
+    public abstract class CategoriesDocument {
+        public Dictionary<XmlQualifiedName, string> AttributeExtensions { get; }
+        public Uri BaseUri { get; set; }
+        public SyndicationElementExtensionCollection ElementExtensions { get; }
+        public string Language { get; set; }
+        public static InlineCategoriesDocument Create(Collection<SyndicationCategory> categories);
+        public static InlineCategoriesDocument Create(Collection<SyndicationCategory> categories, bool isFixed, string scheme);
+        public static ReferencedCategoriesDocument Create(Uri linkToCategoriesDocument);
+        public CategoriesDocumentFormatter GetFormatter();
+        public static CategoriesDocument Load(XmlReader reader);
+        public void Save(XmlWriter writer);
+        protected internal virtual bool TryParseAttribute(string name, string ns, string value, string version);
+        protected internal virtual bool TryParseElement(XmlReader reader, string version);
+        protected internal virtual void WriteAttributeExtensions(XmlWriter writer, string version);
+        protected internal virtual void WriteElementExtensions(XmlWriter writer, string version);
+    }
+    public abstract class CategoriesDocumentFormatter {
+        protected CategoriesDocumentFormatter();
+        protected CategoriesDocumentFormatter(CategoriesDocument documentToWrite);
+        public CategoriesDocument Document { get; }
+        public abstract string Version { get; }
+        public abstract bool CanRead(XmlReader reader);
+        protected virtual InlineCategoriesDocument CreateInlineCategoriesDocument();
+        protected virtual ReferencedCategoriesDocument CreateReferencedCategoriesDocument();
+        public abstract void ReadFrom(XmlReader reader);
+        protected virtual void SetDocument(CategoriesDocument document);
+        public abstract void WriteTo(XmlWriter writer);
+    }
+    public class InlineCategoriesDocument : CategoriesDocument {
+        public InlineCategoriesDocument();
+        public InlineCategoriesDocument(IEnumerable<SyndicationCategory> categories);
+        public InlineCategoriesDocument(IEnumerable<SyndicationCategory> categories, bool isFixed, string scheme);
+        public Collection<SyndicationCategory> Categories { get; }
+        public bool IsFixed { get; set; }
+        public string Scheme { get; set; }
+        protected internal virtual SyndicationCategory CreateCategory();
+    }
+    public class ReferencedCategoriesDocument : CategoriesDocument {
+        public ReferencedCategoriesDocument();
+        public ReferencedCategoriesDocument(Uri link);
+        public Uri Link { get; set; }
+    }
+    public class ResourceCollectionInfo {
+        public ResourceCollectionInfo();
+        public ResourceCollectionInfo(string title, Uri link);
+        public ResourceCollectionInfo(TextSyndicationContent title, Uri link);
+        public ResourceCollectionInfo(TextSyndicationContent title, Uri link, IEnumerable<CategoriesDocument> categories, bool allowsNewEntries);
+        public ResourceCollectionInfo(TextSyndicationContent title, Uri link, IEnumerable<CategoriesDocument> categories, IEnumerable<string> accepts);
+        public Collection<string> Accepts { get; }
+        public Dictionary<XmlQualifiedName, string> AttributeExtensions { get; }
+        public Uri BaseUri { get; set; }
+        public Collection<CategoriesDocument> Categories { get; }
+        public SyndicationElementExtensionCollection ElementExtensions { get; }
+        public Uri Link { get; set; }
+        public TextSyndicationContent Title { get; set; }
+        protected internal virtual InlineCategoriesDocument CreateInlineCategoriesDocument();
+        protected internal virtual ReferencedCategoriesDocument CreateReferencedCategoriesDocument();
+        protected internal virtual bool TryParseAttribute(string name, string ns, string value, string version);
+        protected internal virtual bool TryParseElement(XmlReader reader, string version);
+        protected internal virtual void WriteAttributeExtensions(XmlWriter writer, string version);
+        protected internal virtual void WriteElementExtensions(XmlWriter writer, string version);
+    }
+    public class Rss20FeedFormatter : SyndicationFeedFormatter, IXmlSerializable {
+        public Rss20FeedFormatter();
+        public Rss20FeedFormatter(SyndicationFeed feedToWrite);
+        public Rss20FeedFormatter(SyndicationFeed feedToWrite, bool serializeExtensionsAsAtom);
+        public Rss20FeedFormatter(Type feedTypeToCreate);
+        protected Type FeedType { get; }
+        public bool PreserveAttributeExtensions { get; set; }
+        public bool PreserveElementExtensions { get; set; }
+        public bool SerializeExtensionsAsAtom { get; set; }
+        public override string Version { get; }
+        public override bool CanRead(XmlReader reader);
+        protected override SyndicationFeed CreateFeedInstance();
+        public override void ReadFrom(XmlReader reader);
+        protected virtual SyndicationItem ReadItem(XmlReader reader, SyndicationFeed feed);
+        protected virtual IEnumerable<SyndicationItem> ReadItems(XmlReader reader, SyndicationFeed feed, out bool areAllItemsRead);
+        protected internal override void SetFeed(SyndicationFeed feed);
+        XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
+        void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
+        void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
+        protected virtual void WriteItem(XmlWriter writer, SyndicationItem item, Uri feedBaseUri);
+        protected virtual void WriteItems(XmlWriter writer, IEnumerable<SyndicationItem> items, Uri feedBaseUri);
+        public override void WriteTo(XmlWriter writer);
+    }
+    public class Rss20FeedFormatter<TSyndicationFeed> : Rss20FeedFormatter where TSyndicationFeed : SyndicationFeed, new() {
+        public Rss20FeedFormatter();
+        public Rss20FeedFormatter(TSyndicationFeed feedToWrite);
+        public Rss20FeedFormatter(TSyndicationFeed feedToWrite, bool serializeExtensionsAsAtom);
+        protected override SyndicationFeed CreateFeedInstance();
+    }
+    public class Rss20ItemFormatter : SyndicationItemFormatter, IXmlSerializable {
+        public Rss20ItemFormatter();
+        public Rss20ItemFormatter(SyndicationItem itemToWrite);
+        public Rss20ItemFormatter(SyndicationItem itemToWrite, bool serializeExtensionsAsAtom);
+        public Rss20ItemFormatter(Type itemTypeToCreate);
+        protected Type ItemType { get; }
+        public bool PreserveAttributeExtensions { get; set; }
+        public bool PreserveElementExtensions { get; set; }
+        public bool SerializeExtensionsAsAtom { get; set; }
+        public override string Version { get; }
+        public override bool CanRead(XmlReader reader);
+        protected override SyndicationItem CreateItemInstance();
+        public override void ReadFrom(XmlReader reader);
+        XmlSchema System.Xml.Serialization.IXmlSerializable.GetSchema();
+        void System.Xml.Serialization.IXmlSerializable.ReadXml(XmlReader reader);
+        void System.Xml.Serialization.IXmlSerializable.WriteXml(XmlWriter writer);
+        public override void WriteTo(XmlWriter writer);
+    }
+    public class Rss20ItemFormatter<TSyndicationItem> : Rss20ItemFormatter, IXmlSerializable where TSyndicationItem : SyndicationItem, new() {
+        public Rss20ItemFormatter();
+        public Rss20ItemFormatter(TSyndicationItem itemToWrite);
+        public Rss20ItemFormatter(TSyndicationItem itemToWrite, bool serializeExtensionsAsAtom);
+        protected override SyndicationItem CreateItemInstance();
+    }
+    public class ServiceDocument {
+        public ServiceDocument();
+        public ServiceDocument(IEnumerable<Workspace> workspaces);
+        public Dictionary<XmlQualifiedName, string> AttributeExtensions { get; }
+        public Uri BaseUri { get; set; }
+        public SyndicationElementExtensionCollection ElementExtensions { get; }
+        public string Language { get; set; }
+        public Collection<Workspace> Workspaces { get; }
+        protected internal virtual Workspace CreateWorkspace();
+        public ServiceDocumentFormatter GetFormatter();
+        public static TServiceDocument Load<TServiceDocument>(XmlReader reader) where TServiceDocument : ServiceDocument, new();
+        public static ServiceDocument Load(XmlReader reader);
+        public void Save(XmlWriter writer);
+        protected internal virtual bool TryParseAttribute(string name, string ns, string value, string version);
+        protected internal virtual bool TryParseElement(XmlReader reader, string version);
+        protected internal virtual void WriteAttributeExtensions(XmlWriter writer, string version);
+        protected internal virtual void WriteElementExtensions(XmlWriter writer, string version);
+    }
+    public abstract class ServiceDocumentFormatter {
+        protected ServiceDocumentFormatter();
+        protected ServiceDocumentFormatter(ServiceDocument documentToWrite);
+        public ServiceDocument Document { get; }
+        public abstract string Version { get; }
+        public abstract bool CanRead(XmlReader reader);
+        protected static SyndicationCategory CreateCategory(InlineCategoriesDocument inlineCategories);
+        protected static ResourceCollectionInfo CreateCollection(Workspace workspace);
+        protected virtual ServiceDocument CreateDocumentInstance();
+        protected static InlineCategoriesDocument CreateInlineCategories(ResourceCollectionInfo collection);
+        protected static ReferencedCategoriesDocument CreateReferencedCategories(ResourceCollectionInfo collection);
+        protected static Workspace CreateWorkspace(ServiceDocument document);
+        protected static void LoadElementExtensions(XmlReader reader, CategoriesDocument categories, int maxExtensionSize);
+        protected static void LoadElementExtensions(XmlReader reader, ResourceCollectionInfo collection, int maxExtensionSize);
+        protected static void LoadElementExtensions(XmlReader reader, ServiceDocument document, int maxExtensionSize);
+        protected static void LoadElementExtensions(XmlReader reader, Workspace workspace, int maxExtensionSize);
+        public abstract void ReadFrom(XmlReader reader);
+        protected virtual void SetDocument(ServiceDocument document);
+        protected static bool TryParseAttribute(string name, string ns, string value, CategoriesDocument categories, string version);
+        protected static bool TryParseAttribute(string name, string ns, string value, ResourceCollectionInfo collection, string version);
+        protected static bool TryParseAttribute(string name, string ns, string value, ServiceDocument document, string version);
+        protected static bool TryParseAttribute(string name, string ns, string value, Workspace workspace, string version);
+        protected static bool TryParseElement(XmlReader reader, CategoriesDocument categories, string version);
+        protected static bool TryParseElement(XmlReader reader, ResourceCollectionInfo collection, string version);
+        protected static bool TryParseElement(XmlReader reader, ServiceDocument document, string version);
+        protected static bool TryParseElement(XmlReader reader, Workspace workspace, string version);
+        protected static void WriteAttributeExtensions(XmlWriter writer, CategoriesDocument categories, string version);
+        protected static void WriteAttributeExtensions(XmlWriter writer, ResourceCollectionInfo collection, string version);
+        protected static void WriteAttributeExtensions(XmlWriter writer, ServiceDocument document, string version);
+        protected static void WriteAttributeExtensions(XmlWriter writer, Workspace workspace, string version);
+        protected static void WriteElementExtensions(XmlWriter writer, CategoriesDocument categories, string version);
+        protected static void WriteElementExtensions(XmlWriter writer, ResourceCollectionInfo collection, string version);
+        protected static void WriteElementExtensions(XmlWriter writer, ServiceDocument document, string version);
+        protected static void WriteElementExtensions(XmlWriter writer, Workspace workspace, string version);
+        public abstract void WriteTo(XmlWriter writer);
+    }
+    public class SyndicationCategory {
+        public SyndicationCategory();
+        public SyndicationCategory(string name);
+        public SyndicationCategory(string name, string scheme, string label);
+        protected SyndicationCategory(SyndicationCategory source);
+        public Dictionary<XmlQualifiedName, string> AttributeExtensions { get; }
+        public SyndicationElementExtensionCollection ElementExtensions { get; }
+        public string Label { get; set; }
+        public string Name { get; set; }
+        public string Scheme { get; set; }
+        public virtual SyndicationCategory Clone();
+        protected internal virtual bool TryParseAttribute(string name, string ns, string value, string version);
+        protected internal virtual bool TryParseElement(XmlReader reader, string version);
+        protected internal virtual void WriteAttributeExtensions(XmlWriter writer, string version);
+        protected internal virtual void WriteElementExtensions(XmlWriter writer, string version);
+    }
+    public abstract class SyndicationContent {
+        protected SyndicationContent();
+        protected SyndicationContent(SyndicationContent source);
+        public Dictionary<XmlQualifiedName, string> AttributeExtensions { get; }
+        public abstract string Type { get; }
+        public abstract SyndicationContent Clone();
+        public static TextSyndicationContent CreateHtmlContent(string content);
+        public static TextSyndicationContent CreatePlaintextContent(string content);
+        public static UrlSyndicationContent CreateUrlContent(Uri url, string mediaType);
+        public static TextSyndicationContent CreateXhtmlContent(string content);
+        public static XmlSyndicationContent CreateXmlContent(object dataContractObject);
+        public static XmlSyndicationContent CreateXmlContent(object dataContractObject, XmlObjectSerializer dataContractSerializer);
+        public static XmlSyndicationContent CreateXmlContent(object xmlSerializerObject, XmlSerializer serializer);
+        public static XmlSyndicationContent CreateXmlContent(XmlReader xmlReader);
+        protected abstract void WriteContentsTo(XmlWriter writer);
+        public void WriteTo(XmlWriter writer, string outerElementName, string outerElementNamespace);
+    }
+    public class SyndicationElementExtension {
+        public SyndicationElementExtension(object dataContractExtension);
+        public SyndicationElementExtension(object dataContractExtension, XmlObjectSerializer dataContractSerializer);
+        public SyndicationElementExtension(object xmlSerializerExtension, XmlSerializer serializer);
+        public SyndicationElementExtension(string outerName, string outerNamespace, object dataContractExtension);
+        public SyndicationElementExtension(string outerName, string outerNamespace, object dataContractExtension, XmlObjectSerializer dataContractSerializer);
+        public SyndicationElementExtension(XmlReader xmlReader);
+        public string OuterName { get; }
+        public string OuterNamespace { get; }
+        public TExtension GetObject<TExtension>();
+        public TExtension GetObject<TExtension>(XmlSerializer serializer);
+        public TExtension GetObject<TExtension>(XmlObjectSerializer serializer);
+        public XmlReader GetReader();
+        public void WriteTo(XmlWriter writer);
+    }
+    public sealed class SyndicationElementExtensionCollection : Collection<SyndicationElementExtension> {
+        public void Add(object extension);
+        public void Add(object dataContractExtension, DataContractSerializer serializer);
+        public void Add(object xmlSerializerExtension, XmlSerializer serializer);
+        public void Add(string outerName, string outerNamespace, object dataContractExtension);
+        public void Add(string outerName, string outerNamespace, object dataContractExtension, XmlObjectSerializer dataContractSerializer);
+        public void Add(XmlReader xmlReader);
+        public XmlReader GetReaderAtElementExtensions();
+        public Collection<TExtension> ReadElementExtensions<TExtension>(string extensionName, string extensionNamespace);
+        public Collection<TExtension> ReadElementExtensions<TExtension>(string extensionName, string extensionNamespace, XmlSerializer serializer);
+        public Collection<TExtension> ReadElementExtensions<TExtension>(string extensionName, string extensionNamespace, XmlObjectSerializer serializer);
+    }
+    public class SyndicationFeed {
+        public SyndicationFeed();
+        public SyndicationFeed(IEnumerable<SyndicationItem> items);
+        public SyndicationFeed(string title, string description, Uri feedAlternateLink);
+        public SyndicationFeed(string title, string description, Uri feedAlternateLink, IEnumerable<SyndicationItem> items);
+        public SyndicationFeed(string title, string description, Uri feedAlternateLink, string id, DateTimeOffset lastUpdatedTime);
+        public SyndicationFeed(string title, string description, Uri feedAlternateLink, string id, DateTimeOffset lastUpdatedTime, IEnumerable<SyndicationItem> items);
+        protected SyndicationFeed(SyndicationFeed source, bool cloneItems);
+        public Dictionary<XmlQualifiedName, string> AttributeExtensions { get; }
+        public Collection<SyndicationPerson> Authors { get; }
+        public Uri BaseUri { get; set; }
+        public Collection<SyndicationCategory> Categories { get; }
+        public Collection<SyndicationPerson> Contributors { get; }
+        public TextSyndicationContent Copyright { get; set; }
+        public TextSyndicationContent Description { get; set; }
+        public SyndicationLink Documentation { get; set; }
+        public SyndicationElementExtensionCollection ElementExtensions { get; }
+        public string Generator { get; set; }
+        public string Id { get; set; }
+        public Uri ImageUrl { get; set; }
+        public IEnumerable<SyndicationItem> Items { get; set; }
+        public string Language { get; set; }
+        public DateTimeOffset LastUpdatedTime { get; set; }
+        public Collection<SyndicationLink> Links { get; }
+        public Collection<string> SkipDays { get; }
+        public Collection<int> SkipHours { get; }
+        public SyndicationTextInput TextInput { get; set; }
+        public Nullable<TimeSpan> TimeToLive { get; set; }
+        public TextSyndicationContent Title { get; set; }
+        public virtual SyndicationFeed Clone(bool cloneItems);
+        protected internal virtual SyndicationCategory CreateCategory();
+        protected internal virtual SyndicationItem CreateItem();
+        protected internal virtual SyndicationLink CreateLink();
+        protected internal virtual SyndicationPerson CreatePerson();
+        public Atom10FeedFormatter GetAtom10Formatter();
+        public Rss20FeedFormatter GetRss20Formatter();
+        public Rss20FeedFormatter GetRss20Formatter(bool serializeExtensionsAsAtom);
+        public static TSyndicationFeed Load<TSyndicationFeed>(XmlReader reader) where TSyndicationFeed : SyndicationFeed, new();
+        public static SyndicationFeed Load(XmlReader reader);
+        public void SaveAsAtom10(XmlWriter writer);
+        public void SaveAsRss20(XmlWriter writer);
+        protected internal virtual bool TryParseAttribute(string name, string ns, string value, string version);
+        protected internal virtual bool TryParseElement(XmlReader reader, string version);
+        protected internal virtual void WriteAttributeExtensions(XmlWriter writer, string version);
+        protected internal virtual void WriteElementExtensions(XmlWriter writer, string version);
+    }
+    public abstract class SyndicationFeedFormatter {
+        protected SyndicationFeedFormatter();
+        protected SyndicationFeedFormatter(SyndicationFeed feedToWrite);
+        public TryParseDateTimeCallback DateTimeParser { get; set; }
+        public SyndicationFeed Feed { get; }
+        public TryParseUriCallback UriParser { get; set; }
+        public abstract string Version { get; }
+        public abstract bool CanRead(XmlReader reader);
+        protected internal static SyndicationCategory CreateCategory(SyndicationFeed feed);
+        protected internal static SyndicationCategory CreateCategory(SyndicationItem item);
+        protected abstract SyndicationFeed CreateFeedInstance();
+        protected internal static SyndicationItem CreateItem(SyndicationFeed feed);
+        protected internal static SyndicationLink CreateLink(SyndicationFeed feed);
+        protected internal static SyndicationLink CreateLink(SyndicationItem item);
+        protected internal static SyndicationPerson CreatePerson(SyndicationFeed feed);
+        protected internal static SyndicationPerson CreatePerson(SyndicationItem item);
+        protected internal static void LoadElementExtensions(XmlReader reader, SyndicationCategory category, int maxExtensionSize);
+        protected internal static void LoadElementExtensions(XmlReader reader, SyndicationFeed feed, int maxExtensionSize);
+        protected internal static void LoadElementExtensions(XmlReader reader, SyndicationItem item, int maxExtensionSize);
+        protected internal static void LoadElementExtensions(XmlReader reader, SyndicationLink link, int maxExtensionSize);
+        protected internal static void LoadElementExtensions(XmlReader reader, SyndicationPerson person, int maxExtensionSize);
+        public abstract void ReadFrom(XmlReader reader);
+        protected internal virtual void SetFeed(SyndicationFeed feed);
+        public override string ToString();
+        protected internal static bool TryParseAttribute(string name, string ns, string value, SyndicationCategory category, string version);
+        protected internal static bool TryParseAttribute(string name, string ns, string value, SyndicationFeed feed, string version);
+        protected internal static bool TryParseAttribute(string name, string ns, string value, SyndicationItem item, string version);
+        protected internal static bool TryParseAttribute(string name, string ns, string value, SyndicationLink link, string version);
+        protected internal static bool TryParseAttribute(string name, string ns, string value, SyndicationPerson person, string version);
+        protected internal static bool TryParseContent(XmlReader reader, SyndicationItem item, string contentType, string version, out SyndicationContent content);
+        protected internal static bool TryParseElement(XmlReader reader, SyndicationCategory category, string version);
+        protected internal static bool TryParseElement(XmlReader reader, SyndicationFeed feed, string version);
+        protected internal static bool TryParseElement(XmlReader reader, SyndicationItem item, string version);
+        protected internal static bool TryParseElement(XmlReader reader, SyndicationLink link, string version);
+        protected internal static bool TryParseElement(XmlReader reader, SyndicationPerson person, string version);
+        protected internal static void WriteAttributeExtensions(XmlWriter writer, SyndicationCategory category, string version);
+        protected internal static void WriteAttributeExtensions(XmlWriter writer, SyndicationFeed feed, string version);
+        protected internal static void WriteAttributeExtensions(XmlWriter writer, SyndicationItem item, string version);
+        protected internal static void WriteAttributeExtensions(XmlWriter writer, SyndicationLink link, string version);
+        protected internal static void WriteAttributeExtensions(XmlWriter writer, SyndicationPerson person, string version);
+        protected internal static void WriteElementExtensions(XmlWriter writer, SyndicationCategory category, string version);
+        protected internal static void WriteElementExtensions(XmlWriter writer, SyndicationFeed feed, string version);
+        protected internal static void WriteElementExtensions(XmlWriter writer, SyndicationItem item, string version);
+        protected internal static void WriteElementExtensions(XmlWriter writer, SyndicationLink link, string version);
+        protected internal static void WriteElementExtensions(XmlWriter writer, SyndicationPerson person, string version);
+        public abstract void WriteTo(XmlWriter writer);
+    }
+    public class SyndicationItem {
+        public SyndicationItem();
+        public SyndicationItem(string title, string content, Uri itemAlternateLink);
+        public SyndicationItem(string title, string content, Uri itemAlternateLink, string id, DateTimeOffset lastUpdatedTime);
+        public SyndicationItem(string title, SyndicationContent content, Uri itemAlternateLink, string id, DateTimeOffset lastUpdatedTime);
+        protected SyndicationItem(SyndicationItem source);
+        public Dictionary<XmlQualifiedName, string> AttributeExtensions { get; }
+        public Collection<SyndicationPerson> Authors { get; }
+        public Uri BaseUri { get; set; }
+        public Collection<SyndicationCategory> Categories { get; }
+        public SyndicationContent Content { get; set; }
+        public Collection<SyndicationPerson> Contributors { get; }
+        public TextSyndicationContent Copyright { get; set; }
+        public SyndicationElementExtensionCollection ElementExtensions { get; }
+        public string Id { get; set; }
+        public DateTimeOffset LastUpdatedTime { get; set; }
+        public Collection<SyndicationLink> Links { get; }
+        public DateTimeOffset PublishDate { get; set; }
+        public SyndicationFeed SourceFeed { get; set; }
+        public TextSyndicationContent Summary { get; set; }
+        public TextSyndicationContent Title { get; set; }
+        public void AddPermalink(Uri permalink);
+        public virtual SyndicationItem Clone();
+        protected internal virtual SyndicationCategory CreateCategory();
+        protected internal virtual SyndicationLink CreateLink();
+        protected internal virtual SyndicationPerson CreatePerson();
+        public Atom10ItemFormatter GetAtom10Formatter();
+        public Rss20ItemFormatter GetRss20Formatter();
+        public Rss20ItemFormatter GetRss20Formatter(bool serializeExtensionsAsAtom);
+        public static TSyndicationItem Load<TSyndicationItem>(XmlReader reader) where TSyndicationItem : SyndicationItem, new();
+        public static SyndicationItem Load(XmlReader reader);
+        public void SaveAsAtom10(XmlWriter writer);
+        public void SaveAsRss20(XmlWriter writer);
+        protected internal virtual bool TryParseAttribute(string name, string ns, string value, string version);
+        protected internal virtual bool TryParseContent(XmlReader reader, string contentType, string version, out SyndicationContent content);
+        protected internal virtual bool TryParseElement(XmlReader reader, string version);
+        protected internal virtual void WriteAttributeExtensions(XmlWriter writer, string version);
+        protected internal virtual void WriteElementExtensions(XmlWriter writer, string version);
+    }
+    public abstract class SyndicationItemFormatter {
+        protected SyndicationItemFormatter();
+        protected SyndicationItemFormatter(SyndicationItem itemToWrite);
+        public SyndicationItem Item { get; }
+        public abstract string Version { get; }
+        public abstract bool CanRead(XmlReader reader);
+        protected static SyndicationCategory CreateCategory(SyndicationItem item);
+        protected abstract SyndicationItem CreateItemInstance();
+        protected static SyndicationLink CreateLink(SyndicationItem item);
+        protected static SyndicationPerson CreatePerson(SyndicationItem item);
+        protected static void LoadElementExtensions(XmlReader reader, SyndicationCategory category, int maxExtensionSize);
+        protected static void LoadElementExtensions(XmlReader reader, SyndicationItem item, int maxExtensionSize);
+        protected static void LoadElementExtensions(XmlReader reader, SyndicationLink link, int maxExtensionSize);
+        protected static void LoadElementExtensions(XmlReader reader, SyndicationPerson person, int maxExtensionSize);
+        public abstract void ReadFrom(XmlReader reader);
+        protected internal virtual void SetItem(SyndicationItem item);
+        public override string ToString();
+        protected static bool TryParseAttribute(string name, string ns, string value, SyndicationCategory category, string version);
+        protected static bool TryParseAttribute(string name, string ns, string value, SyndicationItem item, string version);
+        protected static bool TryParseAttribute(string name, string ns, string value, SyndicationLink link, string version);
+        protected static bool TryParseAttribute(string name, string ns, string value, SyndicationPerson person, string version);
+        protected static bool TryParseContent(XmlReader reader, SyndicationItem item, string contentType, string version, out SyndicationContent content);
+        protected static bool TryParseElement(XmlReader reader, SyndicationCategory category, string version);
+        protected static bool TryParseElement(XmlReader reader, SyndicationItem item, string version);
+        protected static bool TryParseElement(XmlReader reader, SyndicationLink link, string version);
+        protected static bool TryParseElement(XmlReader reader, SyndicationPerson person, string version);
+        protected static void WriteAttributeExtensions(XmlWriter writer, SyndicationCategory category, string version);
+        protected static void WriteAttributeExtensions(XmlWriter writer, SyndicationItem item, string version);
+        protected static void WriteAttributeExtensions(XmlWriter writer, SyndicationLink link, string version);
+        protected static void WriteAttributeExtensions(XmlWriter writer, SyndicationPerson person, string version);
+        protected void WriteElementExtensions(XmlWriter writer, SyndicationCategory category, string version);
+        protected static void WriteElementExtensions(XmlWriter writer, SyndicationItem item, string version);
+        protected void WriteElementExtensions(XmlWriter writer, SyndicationLink link, string version);
+        protected void WriteElementExtensions(XmlWriter writer, SyndicationPerson person, string version);
+        public abstract void WriteTo(XmlWriter writer);
+    }
+    public class SyndicationLink {
+        public SyndicationLink();
+        protected SyndicationLink(SyndicationLink source);
+        public SyndicationLink(Uri uri);
+        public SyndicationLink(Uri uri, string relationshipType, string title, string mediaType, long length);
+        public Dictionary<XmlQualifiedName, string> AttributeExtensions { get; }
+        public Uri BaseUri { get; set; }
+        public SyndicationElementExtensionCollection ElementExtensions { get; }
+        public long Length { get; set; }
+        public string MediaType { get; set; }
+        public string RelationshipType { get; set; }
+        public string Title { get; set; }
+        public Uri Uri { get; set; }
+        public virtual SyndicationLink Clone();
+        public static SyndicationLink CreateAlternateLink(Uri uri);
+        public static SyndicationLink CreateAlternateLink(Uri uri, string mediaType);
+        public static SyndicationLink CreateMediaEnclosureLink(Uri uri, string mediaType, long length);
+        public static SyndicationLink CreateSelfLink(Uri uri);
+        public static SyndicationLink CreateSelfLink(Uri uri, string mediaType);
+        public Uri GetAbsoluteUri();
+        protected internal virtual bool TryParseAttribute(string name, string ns, string value, string version);
+        protected internal virtual bool TryParseElement(XmlReader reader, string version);
+        protected internal virtual void WriteAttributeExtensions(XmlWriter writer, string version);
+        protected internal virtual void WriteElementExtensions(XmlWriter writer, string version);
+    }
+    public class SyndicationPerson {
+        public SyndicationPerson();
+        public SyndicationPerson(string email);
+        public SyndicationPerson(string email, string name, string uri);
+        protected SyndicationPerson(SyndicationPerson source);
+        public Dictionary<XmlQualifiedName, string> AttributeExtensions { get; }
+        public SyndicationElementExtensionCollection ElementExtensions { get; }
+        public string Email { get; set; }
+        public string Name { get; set; }
+        public string Uri { get; set; }
+        public virtual SyndicationPerson Clone();
+        protected internal virtual bool TryParseAttribute(string name, string ns, string value, string version);
+        protected internal virtual bool TryParseElement(XmlReader reader, string version);
+        protected internal virtual void WriteAttributeExtensions(XmlWriter writer, string version);
+        protected internal virtual void WriteElementExtensions(XmlWriter writer, string version);
+    }
+    public class SyndicationTextInput {
+        public SyndicationTextInput();
+        public string Description { get; set; }
+        public SyndicationLink Link { get; set; }
+        public string Name { get; set; }
+        public string Title { get; set; }
+    }
+    public static class SyndicationVersions {
+        public const string Atom10 = "Atom10";
+        public const string Rss20 = "Rss20";
+    }
+    public class TextSyndicationContent : SyndicationContent {
+        public TextSyndicationContent(string text);
+        public TextSyndicationContent(string text, TextSyndicationContentKind textKind);
+        protected TextSyndicationContent(TextSyndicationContent source);
+        public string Text { get; }
+        public override string Type { get; }
+        public override SyndicationContent Clone();
+        protected override void WriteContentsTo(XmlWriter writer);
+    }
+    public enum TextSyndicationContentKind {
+        Html = 1,
+        Plaintext = 0,
+        XHtml = 2,
+    }
+    public delegate bool TryParseDateTimeCallback(XmlDateTimeData data, out DateTimeOffset dateTimeOffset); {
+        public TryParseDateTimeCallback(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(XmlDateTimeData data, out DateTimeOffset dateTimeOffset, AsyncCallback callback, object @object);
+        public virtual bool EndInvoke(out DateTimeOffset dateTimeOffset, IAsyncResult result);
+        public virtual bool Invoke(XmlDateTimeData data, out DateTimeOffset dateTimeOffset);
+    }
+    public delegate bool TryParseUriCallback(XmlUriData data, out Uri uri); {
+        public TryParseUriCallback(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(XmlUriData data, out Uri uri, AsyncCallback callback, object @object);
+        public virtual bool EndInvoke(out Uri uri, IAsyncResult result);
+        public virtual bool Invoke(XmlUriData data, out Uri uri);
+    }
+    public class UrlSyndicationContent : SyndicationContent {
+        public UrlSyndicationContent(Uri url, string mediaType);
+        protected UrlSyndicationContent(UrlSyndicationContent source);
+        public override string Type { get; }
+        public Uri Url { get; }
+        public override SyndicationContent Clone();
+        protected override void WriteContentsTo(XmlWriter writer);
+    }
+    public class Workspace {
+        public Workspace();
+        public Workspace(string title, IEnumerable<ResourceCollectionInfo> collections);
+        public Workspace(TextSyndicationContent title, IEnumerable<ResourceCollectionInfo> collections);
+        public Dictionary<XmlQualifiedName, string> AttributeExtensions { get; }
+        public Uri BaseUri { get; set; }
+        public Collection<ResourceCollectionInfo> Collections { get; }
+        public SyndicationElementExtensionCollection ElementExtensions { get; }
+        public TextSyndicationContent Title { get; set; }
+        protected internal virtual ResourceCollectionInfo CreateResourceCollection();
+        protected internal virtual bool TryParseAttribute(string name, string ns, string value, string version);
+        protected internal virtual bool TryParseElement(XmlReader reader, string version);
+        protected internal virtual void WriteAttributeExtensions(XmlWriter writer, string version);
+        protected internal virtual void WriteElementExtensions(XmlWriter writer, string version);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct XmlDateTimeData {
+        public XmlDateTimeData(string dateTimeString, XmlQualifiedName elementQualifiedName);
+        public string DateTimeString { get; }
+        public XmlQualifiedName ElementQualifiedName { get; }
+    }
+    public class XmlSyndicationContent : SyndicationContent {
+        public XmlSyndicationContent(string type, object dataContractExtension, XmlObjectSerializer dataContractSerializer);
+        public XmlSyndicationContent(string type, object xmlSerializerExtension, XmlSerializer serializer);
+        public XmlSyndicationContent(string type, SyndicationElementExtension extension);
+        public XmlSyndicationContent(XmlReader reader);
+        protected XmlSyndicationContent(XmlSyndicationContent source);
+        public SyndicationElementExtension Extension { get; }
+        public override string Type { get; }
+        public override SyndicationContent Clone();
+        public XmlDictionaryReader GetReaderAtContent();
+        public TContent ReadContent<TContent>();
+        public TContent ReadContent<TContent>(XmlSerializer serializer);
+        public TContent ReadContent<TContent>(XmlObjectSerializer dataContractSerializer);
+        protected override void WriteContentsTo(XmlWriter writer);
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct XmlUriData {
+        public XmlUriData(string uriString, UriKind uriKind, XmlQualifiedName elementQualifiedName);
+        public XmlQualifiedName ElementQualifiedName { get; }
+        public UriKind UriKind { get; }
+        public string UriString { get; }
+    }
+}
+namespace System.ServiceProcess {
+    public enum PowerBroadcastStatus {
+        BatteryLow = 9,
+        OemEvent = 11,
+        PowerStatusChange = 10,
+        QuerySuspend = 0,
+        QuerySuspendFailed = 2,
+        ResumeAutomatic = 18,
+        ResumeCritical = 6,
+        ResumeSuspend = 7,
+        Suspend = 4,
+    }
+    public class ServiceBase : Component {
+        public const int MaxNameLength = 80;
+        public ServiceBase();
+        public bool AutoLog { get; set; }
+        public bool CanHandlePowerEvent { get; set; }
+        public bool CanHandleSessionChangeEvent { get; set; }
+        public bool CanPauseAndContinue { get; set; }
+        public bool CanShutdown { get; set; }
+        public bool CanStop { get; set; }
+        public virtual EventLog EventLog { get; }
+        public int ExitCode { get; set; }
+        protected IntPtr ServiceHandle { get; }
+        public string ServiceName { get; set; }
+        protected override void Dispose(bool disposing);
+        protected virtual void OnContinue();
+        protected virtual void OnCustomCommand(int command);
+        protected virtual void OnPause();
+        protected virtual bool OnPowerEvent(PowerBroadcastStatus powerStatus);
+        protected virtual void OnSessionChange(SessionChangeDescription changeDescription);
+        protected virtual void OnShutdown();
+        protected virtual void OnStart(string[] args);
+        protected virtual void OnStop();
+        public void RequestAdditionalTime(int milliseconds);
+        public static void Run(ServiceBase service);
+        public static void Run(ServiceBase[] services);
+        public void ServiceMainCallback(int argCount, IntPtr argPointer);
+        public void Stop();
+    }
+    public class ServiceController : Component {
+        public ServiceController();
+        public ServiceController(string name);
+        public ServiceController(string name, string machineName);
+        public bool CanPauseAndContinue { get; }
+        public bool CanShutdown { get; }
+        public bool CanStop { get; }
+        public ServiceController[] DependentServices { get; }
+        public string DisplayName { get; set; }
+        public string MachineName { get; set; }
+        public SafeHandle ServiceHandle { get; }
+        public string ServiceName { get; set; }
+        public ServiceController[] ServicesDependedOn { get; }
+        public ServiceType ServiceType { get; }
+        public ServiceStartMode StartType { get; }
+        public ServiceControllerStatus Status { get; }
+        public void Close();
+        public void Continue();
+        protected override void Dispose(bool disposing);
+        public void ExecuteCommand(int command);
+        public static ServiceController[] GetDevices();
+        public static ServiceController[] GetDevices(string machineName);
+        public static ServiceController[] GetServices();
+        public static ServiceController[] GetServices(string machineName);
+        public void Pause();
+        public void Refresh();
+        public void Start();
+        public void Start(string[] args);
+        public void Stop();
+        public void WaitForStatus(ServiceControllerStatus desiredStatus);
+        public void WaitForStatus(ServiceControllerStatus desiredStatus, TimeSpan timeout);
+    }
+    public enum ServiceControllerStatus {
+        ContinuePending = 5,
+        Paused = 7,
+        PausePending = 6,
+        Running = 4,
+        StartPending = 2,
+        Stopped = 1,
+        StopPending = 3,
+    }
+    public enum ServiceStartMode {
+        Automatic = 2,
+        Boot = 0,
+        Disabled = 4,
+        Manual = 3,
+        System = 1,
+    }
+    public enum ServiceType {
+        Adapter = 4,
+        FileSystemDriver = 2,
+        InteractiveProcess = 256,
+        KernelDriver = 1,
+        RecognizerDriver = 8,
+        Win32OwnProcess = 16,
+        Win32ShareProcess = 32,
+    }
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct SessionChangeDescription {
+        public SessionChangeReason Reason { get; }
+        public int SessionId { get; }
+        public override bool Equals(object obj);
+        public bool Equals(SessionChangeDescription changeDescription);
+        public override int GetHashCode();
+        public static bool operator ==(SessionChangeDescription a, SessionChangeDescription b);
+        public static bool operator !=(SessionChangeDescription a, SessionChangeDescription b);
+    }
+    public enum SessionChangeReason {
+        ConsoleConnect = 1,
+        ConsoleDisconnect = 2,
+        RemoteConnect = 3,
+        RemoteDisconnect = 4,
+        SessionLock = 7,
+        SessionLogoff = 6,
+        SessionLogon = 5,
+        SessionRemoteControl = 9,
+        SessionUnlock = 8,
+    }
+    public class TimeoutException : SystemException {
+        public TimeoutException();
+        protected TimeoutException(SerializationInfo info, StreamingContext context);
+        public TimeoutException(string message);
+        public TimeoutException(string message, Exception innerException);
+    }
+}
 namespace System.Text {
+    public sealed class CodePagesEncodingProvider {
+        public static EncodingProvider Instance { get; }
+    }
     public abstract class Decoder {
+        public virtual void Convert(ReadOnlySpan<byte> bytes, Span<char> chars, bool flush, out int bytesUsed, out int charsUsed, out bool completed);
+        public virtual int GetCharCount(ReadOnlySpan<byte> bytes, bool flush);
+        public virtual int GetChars(ReadOnlySpan<byte> bytes, Span<char> chars, bool flush);
     }
     public abstract class Encoder {
+        public virtual void Convert(ReadOnlySpan<char> chars, Span<byte> bytes, bool flush, out int charsUsed, out int bytesUsed, out bool completed);
+        public virtual int GetByteCount(ReadOnlySpan<char> chars, bool flush);
+        public virtual int GetBytes(ReadOnlySpan<char> chars, Span<byte> bytes, bool flush);
     }
     public abstract class Encoding : ICloneable {
+        public virtual ReadOnlySpan<byte> Preamble { get; }
+        public virtual int GetByteCount(ReadOnlySpan<char> chars);
+        public virtual int GetBytes(ReadOnlySpan<char> chars, Span<byte> bytes);
+        public virtual int GetCharCount(ReadOnlySpan<byte> bytes);
+        public virtual int GetChars(ReadOnlySpan<byte> bytes, Span<char> chars);
+        public string GetString(ReadOnlySpan<byte> bytes);
     }
     public sealed class StringBuilder : ISerializable {
+        public StringBuilder Append(ReadOnlySpan<char> value);
+        public StringBuilder Append(StringBuilder value);
+        public StringBuilder Append(StringBuilder value, int startIndex, int count);
+        public void CopyTo(int sourceIndex, Span<char> destination, int count);
+        public bool Equals(ReadOnlySpan<char> value);
+        public StringBuilder Insert(int index, ReadOnlySpan<char> value);
     }
 }
+namespace System.Text.Encodings.Web {
+    public abstract class HtmlEncoder : TextEncoder {
+        protected HtmlEncoder();
+        public static HtmlEncoder Default { get; }
+        public static HtmlEncoder Create(TextEncoderSettings settings);
+        public static HtmlEncoder Create(params UnicodeRange[] allowedRanges);
+    }
+    public abstract class JavaScriptEncoder : TextEncoder {
+        protected JavaScriptEncoder();
+        public static JavaScriptEncoder Default { get; }
+        public static JavaScriptEncoder Create(TextEncoderSettings settings);
+        public static JavaScriptEncoder Create(params UnicodeRange[] allowedRanges);
+    }
+    public abstract class TextEncoder {
+        protected TextEncoder();
+        public abstract int MaxOutputCharactersPerInputCharacter { get; }
+        public virtual string Encode(string value);
+        public virtual void Encode(TextWriter output, char[] value, int startIndex, int characterCount);
+        public void Encode(TextWriter output, string value);
+        public virtual void Encode(TextWriter output, string value, int startIndex, int characterCount);
+        public unsafe abstract int FindFirstCharacterToEncode(char* text, int textLength);
+        public unsafe abstract bool TryEncodeUnicodeScalar(int unicodeScalar, char* buffer, int bufferLength, out int numberOfCharactersWritten);
+        public abstract bool WillEncode(int unicodeScalar);
+    }
+    public class TextEncoderSettings {
+        public TextEncoderSettings();
+        public TextEncoderSettings(TextEncoderSettings other);
+        public TextEncoderSettings(params UnicodeRange[] allowedRanges);
+        public virtual void AllowCharacter(char character);
+        public virtual void AllowCharacters(params char[] characters);
+        public virtual void AllowCodePoints(IEnumerable<int> codePoints);
+        public virtual void AllowRange(UnicodeRange range);
+        public virtual void AllowRanges(params UnicodeRange[] ranges);
+        public virtual void Clear();
+        public virtual void ForbidCharacter(char character);
+        public virtual void ForbidCharacters(params char[] characters);
+        public virtual void ForbidRange(UnicodeRange range);
+        public virtual void ForbidRanges(params UnicodeRange[] ranges);
+        public virtual IEnumerable<int> GetAllowedCodePoints();
+    }
+    public abstract class UrlEncoder : TextEncoder {
+        protected UrlEncoder();
+        public static UrlEncoder Default { get; }
+        public static UrlEncoder Create(TextEncoderSettings settings);
+        public static UrlEncoder Create(params UnicodeRange[] allowedRanges);
+    }
+}
 namespace System.Text.RegularExpressions {
     public class Regex : ISerializable {
+        public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname);
+        public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes);
+        public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes, string resourceFile);
     }
+    public class RegexCompilationInfo {
+        public RegexCompilationInfo(string pattern, RegexOptions options, string name, string fullnamespace, bool ispublic);
+        public RegexCompilationInfo(string pattern, RegexOptions options, string name, string fullnamespace, bool ispublic, TimeSpan matchTimeout);
+        public bool IsPublic { get; set; }
+        public TimeSpan MatchTimeout { get; set; }
+        public string Name { get; set; }
+        public string Namespace { get; set; }
+        public RegexOptions Options { get; set; }
+        public string Pattern { get; set; }
+    }
 }
+namespace System.Text.Unicode {
+    public sealed class UnicodeRange {
+        public UnicodeRange(int firstCodePoint, int length);
+        public int FirstCodePoint { get; private set; }
+        public int Length { get; private set; }
+        public static UnicodeRange Create(char firstCharacter, char lastCharacter);
+    }
+    public static class UnicodeRanges {
+        public static UnicodeRange All { get; }
+        public static UnicodeRange AlphabeticPresentationForms { get; }
+        public static UnicodeRange Arabic { get; }
+        public static UnicodeRange ArabicExtendedA { get; }
+        public static UnicodeRange ArabicPresentationFormsA { get; }
+        public static UnicodeRange ArabicPresentationFormsB { get; }
+        public static UnicodeRange ArabicSupplement { get; }
+        public static UnicodeRange Armenian { get; }
+        public static UnicodeRange Arrows { get; }
+        public static UnicodeRange Balinese { get; }
+        public static UnicodeRange Bamum { get; }
+        public static UnicodeRange BasicLatin { get; }
+        public static UnicodeRange Batak { get; }
+        public static UnicodeRange Bengali { get; }
+        public static UnicodeRange BlockElements { get; }
+        public static UnicodeRange Bopomofo { get; }
+        public static UnicodeRange BopomofoExtended { get; }
+        public static UnicodeRange BoxDrawing { get; }
+        public static UnicodeRange BraillePatterns { get; }
+        public static UnicodeRange Buginese { get; }
+        public static UnicodeRange Buhid { get; }
+        public static UnicodeRange Cham { get; }
+        public static UnicodeRange Cherokee { get; }
+        public static UnicodeRange CherokeeSupplement { get; }
+        public static UnicodeRange CjkCompatibility { get; }
+        public static UnicodeRange CjkCompatibilityForms { get; }
+        public static UnicodeRange CjkCompatibilityIdeographs { get; }
+        public static UnicodeRange CjkRadicalsSupplement { get; }
+        public static UnicodeRange CjkStrokes { get; }
+        public static UnicodeRange CjkSymbolsandPunctuation { get; }
+        public static UnicodeRange CjkUnifiedIdeographs { get; }
+        public static UnicodeRange CjkUnifiedIdeographsExtensionA { get; }
+        public static UnicodeRange CombiningDiacriticalMarks { get; }
+        public static UnicodeRange CombiningDiacriticalMarksExtended { get; }
+        public static UnicodeRange CombiningDiacriticalMarksforSymbols { get; }
+        public static UnicodeRange CombiningDiacriticalMarksSupplement { get; }
+        public static UnicodeRange CombiningHalfMarks { get; }
+        public static UnicodeRange CommonIndicNumberForms { get; }
+        public static UnicodeRange ControlPictures { get; }
+        public static UnicodeRange Coptic { get; }
+        public static UnicodeRange CurrencySymbols { get; }
+        public static UnicodeRange Cyrillic { get; }
+        public static UnicodeRange CyrillicExtendedA { get; }
+        public static UnicodeRange CyrillicExtendedB { get; }
+        public static UnicodeRange CyrillicSupplement { get; }
+        public static UnicodeRange Devanagari { get; }
+        public static UnicodeRange DevanagariExtended { get; }
+        public static UnicodeRange Dingbats { get; }
+        public static UnicodeRange EnclosedAlphanumerics { get; }
+        public static UnicodeRange EnclosedCjkLettersandMonths { get; }
+        public static UnicodeRange Ethiopic { get; }
+        public static UnicodeRange EthiopicExtended { get; }
+        public static UnicodeRange EthiopicExtendedA { get; }
+        public static UnicodeRange EthiopicSupplement { get; }
+        public static UnicodeRange GeneralPunctuation { get; }
+        public static UnicodeRange GeometricShapes { get; }
+        public static UnicodeRange Georgian { get; }
+        public static UnicodeRange GeorgianSupplement { get; }
+        public static UnicodeRange Glagolitic { get; }
+        public static UnicodeRange GreekandCoptic { get; }
+        public static UnicodeRange GreekExtended { get; }
+        public static UnicodeRange Gujarati { get; }
+        public static UnicodeRange Gurmukhi { get; }
+        public static UnicodeRange HalfwidthandFullwidthForms { get; }
+        public static UnicodeRange HangulCompatibilityJamo { get; }
+        public static UnicodeRange HangulJamo { get; }
+        public static UnicodeRange HangulJamoExtendedA { get; }
+        public static UnicodeRange HangulJamoExtendedB { get; }
+        public static UnicodeRange HangulSyllables { get; }
+        public static UnicodeRange Hanunoo { get; }
+        public static UnicodeRange Hebrew { get; }
+        public static UnicodeRange Hiragana { get; }
+        public static UnicodeRange IdeographicDescriptionCharacters { get; }
+        public static UnicodeRange IpaExtensions { get; }
+        public static UnicodeRange Javanese { get; }
+        public static UnicodeRange Kanbun { get; }
+        public static UnicodeRange KangxiRadicals { get; }
+        public static UnicodeRange Kannada { get; }
+        public static UnicodeRange Katakana { get; }
+        public static UnicodeRange KatakanaPhoneticExtensions { get; }
+        public static UnicodeRange KayahLi { get; }
+        public static UnicodeRange Khmer { get; }
+        public static UnicodeRange KhmerSymbols { get; }
+        public static UnicodeRange Lao { get; }
+        public static UnicodeRange Latin1Supplement { get; }
+        public static UnicodeRange LatinExtendedA { get; }
+        public static UnicodeRange LatinExtendedAdditional { get; }
+        public static UnicodeRange LatinExtendedB { get; }
+        public static UnicodeRange LatinExtendedC { get; }
+        public static UnicodeRange LatinExtendedD { get; }
+        public static UnicodeRange LatinExtendedE { get; }
+        public static UnicodeRange Lepcha { get; }
+        public static UnicodeRange LetterlikeSymbols { get; }
+        public static UnicodeRange Limbu { get; }
+        public static UnicodeRange Lisu { get; }
+        public static UnicodeRange Malayalam { get; }
+        public static UnicodeRange Mandaic { get; }
+        public static UnicodeRange MathematicalOperators { get; }
+        public static UnicodeRange MeeteiMayek { get; }
+        public static UnicodeRange MeeteiMayekExtensions { get; }
+        public static UnicodeRange MiscellaneousMathematicalSymbolsA { get; }
+        public static UnicodeRange MiscellaneousMathematicalSymbolsB { get; }
+        public static UnicodeRange MiscellaneousSymbols { get; }
+        public static UnicodeRange MiscellaneousSymbolsandArrows { get; }
+        public static UnicodeRange MiscellaneousTechnical { get; }
+        public static UnicodeRange ModifierToneLetters { get; }
+        public static UnicodeRange Mongolian { get; }
+        public static UnicodeRange Myanmar { get; }
+        public static UnicodeRange MyanmarExtendedA { get; }
+        public static UnicodeRange MyanmarExtendedB { get; }
+        public static UnicodeRange NewTaiLue { get; }
+        public static UnicodeRange NKo { get; }
+        public static UnicodeRange None { get; }
+        public static UnicodeRange NumberForms { get; }
+        public static UnicodeRange Ogham { get; }
+        public static UnicodeRange OlChiki { get; }
+        public static UnicodeRange OpticalCharacterRecognition { get; }
+        public static UnicodeRange Oriya { get; }
+        public static UnicodeRange Phagspa { get; }
+        public static UnicodeRange PhoneticExtensions { get; }
+        public static UnicodeRange PhoneticExtensionsSupplement { get; }
+        public static UnicodeRange Rejang { get; }
+        public static UnicodeRange Runic { get; }
+        public static UnicodeRange Samaritan { get; }
+        public static UnicodeRange Saurashtra { get; }
+        public static UnicodeRange Sinhala { get; }
+        public static UnicodeRange SmallFormVariants { get; }
+        public static UnicodeRange SpacingModifierLetters { get; }
+        public static UnicodeRange Specials { get; }
+        public static UnicodeRange Sundanese { get; }
+        public static UnicodeRange SundaneseSupplement { get; }
+        public static UnicodeRange SuperscriptsandSubscripts { get; }
+        public static UnicodeRange SupplementalArrowsA { get; }
+        public static UnicodeRange SupplementalArrowsB { get; }
+        public static UnicodeRange SupplementalMathematicalOperators { get; }
+        public static UnicodeRange SupplementalPunctuation { get; }
+        public static UnicodeRange SylotiNagri { get; }
+        public static UnicodeRange Syriac { get; }
+        public static UnicodeRange Tagalog { get; }
+        public static UnicodeRange Tagbanwa { get; }
+        public static UnicodeRange TaiLe { get; }
+        public static UnicodeRange TaiTham { get; }
+        public static UnicodeRange TaiViet { get; }
+        public static UnicodeRange Tamil { get; }
+        public static UnicodeRange Telugu { get; }
+        public static UnicodeRange Thaana { get; }
+        public static UnicodeRange Thai { get; }
+        public static UnicodeRange Tibetan { get; }
+        public static UnicodeRange Tifinagh { get; }
+        public static UnicodeRange UnifiedCanadianAboriginalSyllabics { get; }
+        public static UnicodeRange UnifiedCanadianAboriginalSyllabicsExtended { get; }
+        public static UnicodeRange Vai { get; }
+        public static UnicodeRange VariationSelectors { get; }
+        public static UnicodeRange VedicExtensions { get; }
+        public static UnicodeRange VerticalForms { get; }
+        public static UnicodeRange YijingHexagramSymbols { get; }
+        public static UnicodeRange YiRadicals { get; }
+        public static UnicodeRange YiSyllables { get; }
+    }
+}
 namespace System.Threading {
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
-    public struct AsyncFlowControl : IDisposable {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct AsyncFlowControl : IDisposable {
     }
     [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
     public struct CancellationTokenRegistration : IDisposable, IEquatable<CancellationTokenRegistration> {
+        public CancellationToken Token { get; }
     }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
-    public struct LockCookie {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct LockCookie {
     }
     public sealed class Thread : CriticalFinalizerObject {
+        public static int GetCurrentProcessorId();
     }
+    public static class ThreadingAclExtensions {
+        public static EventWaitHandleSecurity GetAccessControl(this EventWaitHandle handle);
+        public static MutexSecurity GetAccessControl(this Mutex mutex);
+        public static SemaphoreSecurity GetAccessControl(this Semaphore semaphore);
+        public static void SetAccessControl(this EventWaitHandle handle, EventWaitHandleSecurity eventSecurity);
+        public static void SetAccessControl(this Mutex mutex, MutexSecurity mutexSecurity);
+        public static void SetAccessControl(this Semaphore semaphore, SemaphoreSecurity semaphoreSecurity);
+    }
     public static class ThreadPool {
+        public static bool QueueUserWorkItem<TState>(Action<TState> callBack, TState state, bool preferLocal);
     }
 }
+namespace System.Threading.Channels {
+    public enum BoundedChannelFullMode {
+        DropNewest = 1,
+        DropOldest = 2,
+        DropWrite = 3,
+        Wait = 0,
+    }
+    public sealed class BoundedChannelOptions : ChannelOptions {
+        public BoundedChannelOptions(int capacity);
+        public int Capacity { get; set; }
+        public BoundedChannelFullMode FullMode { get; set; }
+    }
+    public static class Channel {
+        public static Channel<T> CreateBounded<T>(int capacity);
+        public static Channel<T> CreateBounded<T>(BoundedChannelOptions options);
+        public static Channel<T> CreateUnbounded<T>();
+        public static Channel<T> CreateUnbounded<T>(UnboundedChannelOptions options);
+    }
+    public abstract class Channel<T> : Channel<T, T> {
+        protected Channel();
+    }
+    public abstract class Channel<TWrite, TRead> {
+        protected Channel();
+        public ChannelReader<TRead> Reader { get; protected set; }
+        public ChannelWriter<TWrite> Writer { get; protected set; }
+        public static implicit operator ChannelReader<TRead> (Channel<TWrite, TRead> channel);
+        public static implicit operator ChannelWriter<TWrite> (Channel<TWrite, TRead> channel);
+    }
+    public class ChannelClosedException : InvalidOperationException {
+        public ChannelClosedException();
+        public ChannelClosedException(Exception innerException);
+        public ChannelClosedException(string message);
+        public ChannelClosedException(string message, Exception innerException);
+    }
+    public abstract class ChannelOptions {
+        protected ChannelOptions();
+        public bool AllowSynchronousContinuations { get; set; }
+        public bool SingleReader { get; set; }
+        public bool SingleWriter { get; set; }
+    }
+    public abstract class ChannelReader<T> {
+        protected ChannelReader();
+        public virtual Task Completion { get; }
+        public virtual ValueTask<T> ReadAsync(CancellationToken cancellationToken=default(CancellationToken));
+        public abstract bool TryRead(out T item);
+        public abstract ValueTask<bool> WaitToReadAsync(CancellationToken cancellationToken=default(CancellationToken));
+    }
+    public abstract class ChannelWriter<T> {
+        protected ChannelWriter();
+        public void Complete(Exception error=null);
+        public virtual bool TryComplete(Exception error=null);
+        public abstract bool TryWrite(T item);
+        public abstract ValueTask<bool> WaitToWriteAsync(CancellationToken cancellationToken=default(CancellationToken));
+        public virtual ValueTask WriteAsync(T item, CancellationToken cancellationToken=default(CancellationToken));
+    }
+    public sealed class UnboundedChannelOptions : ChannelOptions {
+        public UnboundedChannelOptions();
+    }
+}
 namespace System.Threading.Tasks {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ValueTask : IEquatable<ValueTask> {
+        public ValueTask(IValueTaskSource source, short token);
+        public ValueTask(Task task);
+        public bool IsCanceled { get; }
+        public bool IsCompleted { get; }
+        public bool IsCompletedSuccessfully { get; }
+        public bool IsFaulted { get; }
+        public Task AsTask();
+        public ConfiguredValueTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
+        public override bool Equals(object obj);
+        public bool Equals(ValueTask other);
+        public ValueTaskAwaiter GetAwaiter();
+        public override int GetHashCode();
+        public static bool operator ==(ValueTask left, ValueTask right);
+        public static bool operator !=(ValueTask left, ValueTask right);
+        public ValueTask Preserve();
+    }
-    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Size=1)]
-    public struct ValueTask<TResult> : IEquatable<ValueTask<TResult>> {
+    [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential)]
+    public struct ValueTask<TResult> : IEquatable<ValueTask<TResult>> {
+        public ValueTask(IValueTaskSource<TResult> source, short token);
-        public static AsyncValueTaskMethodBuilder<TResult> CreateAsyncMethodBuilder();
+        public ValueTask<TResult> Preserve();
     }
 }
+namespace System.Threading.Tasks.Sources {
+    public interface IValueTaskSource {
+        void GetResult(short token);
+        ValueTaskSourceStatus GetStatus(short token);
+        void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
+    }
+    public interface IValueTaskSource<out TResult> {
+        TResult GetResult(short token);
+        ValueTaskSourceStatus GetStatus(short token);
+        void OnCompleted(Action<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
+    }
+    public enum ValueTaskSourceOnCompletedFlags {
+        FlowExecutionContext = 2,
+        None = 0,
+        UseSchedulingContext = 1,
+    }
+    public enum ValueTaskSourceStatus {
+        Canceled = 3,
+        Faulted = 2,
+        Pending = 0,
+        Succeeded = 1,
+    }
+}
 namespace System.Transactions {
+    public sealed class DistributedTransactionPermission : CodeAccessPermission, IUnrestrictedPermission {
+        public DistributedTransactionPermission(PermissionState state);
+        public override IPermission Copy();
+        public override void FromXml(SecurityElement securityElement);
+        public override IPermission Intersect(IPermission target);
+        public override bool IsSubsetOf(IPermission target);
+        public bool IsUnrestricted();
+        public override SecurityElement ToXml();
+        public override IPermission Union(IPermission target);
+    }
+    public sealed class DistributedTransactionPermissionAttribute : CodeAccessSecurityAttribute {
+        public DistributedTransactionPermissionAttribute(SecurityAction action);
+        public bool Unrestricted { get; set; }
+        public override IPermission CreatePermission();
+    }
 }
+namespace Microsoft.CSharp {
+    public class CSharpCodeProvider : CodeDomProvider {
+        public CSharpCodeProvider();
+        public CSharpCodeProvider(IDictionary<string, string> providerOptions);
+        public override string FileExtension { get; }
+        public override ICodeCompiler CreateCompiler();
+        public override ICodeGenerator CreateGenerator();
+        public override void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options);
+        public override TypeConverter GetConverter(Type type);
+    }
+}
+namespace Microsoft.SqlServer.Server {
+    public enum DataAccessKind {
+        None = 0,
+        Read = 1,
+    }
+    public enum Format {
+        Native = 1,
+        Unknown = 0,
+        UserDefined = 2,
+    }
+    public interface IBinarySerialize {
+        void Read(BinaryReader r);
+        void Write(BinaryWriter w);
+    }
+    public sealed class InvalidUdtException : SystemException {
+    }
+    public class SqlDataRecord : IDataRecord {
+        public SqlDataRecord(params SqlMetaData[] metaData);
+        public virtual int FieldCount { get; }
+        public virtual object this[int ordinal] { get; }
+        public virtual object this[string name] { get; }
+        public virtual bool GetBoolean(int ordinal);
+        public virtual byte GetByte(int ordinal);
+        public virtual long GetBytes(int ordinal, long fieldOffset, byte[] buffer, int bufferOffset, int length);
+        public virtual char GetChar(int ordinal);
+        public virtual long GetChars(int ordinal, long fieldOffset, char[] buffer, int bufferOffset, int length);
+        public virtual string GetDataTypeName(int ordinal);
+        public virtual DateTime GetDateTime(int ordinal);
+        public virtual DateTimeOffset GetDateTimeOffset(int ordinal);
+        public virtual decimal GetDecimal(int ordinal);
+        public virtual double GetDouble(int ordinal);
+        public virtual Type GetFieldType(int ordinal);
+        public virtual float GetFloat(int ordinal);
+        public virtual Guid GetGuid(int ordinal);
+        public virtual short GetInt16(int ordinal);
+        public virtual int GetInt32(int ordinal);
+        public virtual long GetInt64(int ordinal);
+        public virtual string GetName(int ordinal);
+        public virtual int GetOrdinal(string name);
+        public virtual SqlBinary GetSqlBinary(int ordinal);
+        public virtual SqlBoolean GetSqlBoolean(int ordinal);
+        public virtual SqlByte GetSqlByte(int ordinal);
+        public virtual SqlBytes GetSqlBytes(int ordinal);
+        public virtual SqlChars GetSqlChars(int ordinal);
+        public virtual SqlDateTime GetSqlDateTime(int ordinal);
+        public virtual SqlDecimal GetSqlDecimal(int ordinal);
+        public virtual SqlDouble GetSqlDouble(int ordinal);
+        public virtual Type GetSqlFieldType(int ordinal);
+        public virtual SqlGuid GetSqlGuid(int ordinal);
+        public virtual SqlInt16 GetSqlInt16(int ordinal);
+        public virtual SqlInt32 GetSqlInt32(int ordinal);
+        public virtual SqlInt64 GetSqlInt64(int ordinal);
+        public virtual SqlMetaData GetSqlMetaData(int ordinal);
+        public virtual SqlMoney GetSqlMoney(int ordinal);
+        public virtual SqlSingle GetSqlSingle(int ordinal);
+        public virtual SqlString GetSqlString(int ordinal);
+        public virtual object GetSqlValue(int ordinal);
+        public virtual int GetSqlValues(object[] values);
+        public virtual SqlXml GetSqlXml(int ordinal);
+        public virtual string GetString(int ordinal);
+        public virtual TimeSpan GetTimeSpan(int ordinal);
+        public virtual object GetValue(int ordinal);
+        public virtual int GetValues(object[] values);
+        public virtual bool IsDBNull(int ordinal);
+        public virtual void SetBoolean(int ordinal, bool value);
+        public virtual void SetByte(int ordinal, byte value);
+        public virtual void SetBytes(int ordinal, long fieldOffset, byte[] buffer, int bufferOffset, int length);
+        public virtual void SetChar(int ordinal, char value);
+        public virtual void SetChars(int ordinal, long fieldOffset, char[] buffer, int bufferOffset, int length);
+        public virtual void SetDateTime(int ordinal, DateTime value);
+        public virtual void SetDateTimeOffset(int ordinal, DateTimeOffset value);
+        public virtual void SetDBNull(int ordinal);
+        public virtual void SetDecimal(int ordinal, decimal value);
+        public virtual void SetDouble(int ordinal, double value);
+        public virtual void SetFloat(int ordinal, float value);
+        public virtual void SetGuid(int ordinal, Guid value);
+        public virtual void SetInt16(int ordinal, short value);
+        public virtual void SetInt32(int ordinal, int value);
+        public virtual void SetInt64(int ordinal, long value);
+        public virtual void SetSqlBinary(int ordinal, SqlBinary value);
+        public virtual void SetSqlBoolean(int ordinal, SqlBoolean value);
+        public virtual void SetSqlByte(int ordinal, SqlByte value);
+        public virtual void SetSqlBytes(int ordinal, SqlBytes value);
+        public virtual void SetSqlChars(int ordinal, SqlChars value);
+        public virtual void SetSqlDateTime(int ordinal, SqlDateTime value);
+        public virtual void SetSqlDecimal(int ordinal, SqlDecimal value);
+        public virtual void SetSqlDouble(int ordinal, SqlDouble value);
+        public virtual void SetSqlGuid(int ordinal, SqlGuid value);
+        public virtual void SetSqlInt16(int ordinal, SqlInt16 value);
+        public virtual void SetSqlInt32(int ordinal, SqlInt32 value);
+        public virtual void SetSqlInt64(int ordinal, SqlInt64 value);
+        public virtual void SetSqlMoney(int ordinal, SqlMoney value);
+        public virtual void SetSqlSingle(int ordinal, SqlSingle value);
+        public virtual void SetSqlString(int ordinal, SqlString value);
+        public virtual void SetSqlXml(int ordinal, SqlXml value);
+        public virtual void SetString(int ordinal, string value);
+        public virtual void SetTimeSpan(int ordinal, TimeSpan value);
+        public virtual void SetValue(int ordinal, object value);
+        public virtual int SetValues(params object[] values);
+        IDataReader System.Data.IDataRecord.GetData(int ordinal);
+    }
+    public class SqlFunctionAttribute : Attribute {
+        public SqlFunctionAttribute();
+        public DataAccessKind DataAccess { get; set; }
+        public string FillRowMethodName { get; set; }
+        public bool IsDeterministic { get; set; }
+        public bool IsPrecise { get; set; }
+        public string Name { get; set; }
+        public SystemDataAccessKind SystemDataAccess { get; set; }
+        public string TableDefinition { get; set; }
+    }
+    public sealed class SqlMetaData {
+        public SqlMetaData(string name, SqlDbType dbType);
+        public SqlMetaData(string name, SqlDbType dbType, bool useServerDefault, bool isUniqueKey, SortOrder columnSortOrder, int sortOrdinal);
+        public SqlMetaData(string name, SqlDbType dbType, byte precision, byte scale);
+        public SqlMetaData(string name, SqlDbType dbType, byte precision, byte scale, bool useServerDefault, bool isUniqueKey, SortOrder columnSortOrder, int sortOrdinal);
+        public SqlMetaData(string name, SqlDbType dbType, long maxLength);
+        public SqlMetaData(string name, SqlDbType dbType, long maxLength, bool useServerDefault, bool isUniqueKey, SortOrder columnSortOrder, int sortOrdinal);
+        public SqlMetaData(string name, SqlDbType dbType, long maxLength, byte precision, byte scale, long locale, SqlCompareOptions compareOptions, Type userDefinedType);
+        public SqlMetaData(string name, SqlDbType dbType, long maxLength, byte precision, byte scale, long localeId, SqlCompareOptions compareOptions, Type userDefinedType, bool useServerDefault, bool isUniqueKey, SortOrder columnSortOrder, int sortOrdinal);
+        public SqlMetaData(string name, SqlDbType dbType, long maxLength, long locale, SqlCompareOptions compareOptions);
+        public SqlMetaData(string name, SqlDbType dbType, long maxLength, long locale, SqlCompareOptions compareOptions, bool useServerDefault, bool isUniqueKey, SortOrder columnSortOrder, int sortOrdinal);
+        public SqlMetaData(string name, SqlDbType dbType, string database, string owningSchema, string objectName);
+        public SqlMetaData(string name, SqlDbType dbType, string database, string owningSchema, string objectName, bool useServerDefault, bool isUniqueKey, SortOrder columnSortOrder, int sortOrdinal);
+        public SqlMetaData(string name, SqlDbType dbType, Type userDefinedType, string serverTypeName);
+        public SqlMetaData(string name, SqlDbType dbType, Type userDefinedType, string serverTypeName, bool useServerDefault, bool isUniqueKey, SortOrder columnSortOrder, int sortOrdinal);
+        public SqlCompareOptions CompareOptions { get; }
+        public DbType DbType { get; }
+        public bool IsUniqueKey { get; }
+        public long LocaleId { get; }
+        public static long Max { get; }
+        public long MaxLength { get; }
+        public string Name { get; }
+        public byte Precision { get; }
+        public byte Scale { get; }
+        public SortOrder SortOrder { get; }
+        public int SortOrdinal { get; }
+        public SqlDbType SqlDbType { get; }
+        public Type Type { get; }
+        public string TypeName { get; }
+        public bool UseServerDefault { get; }
+        public string XmlSchemaCollectionDatabase { get; }
+        public string XmlSchemaCollectionName { get; }
+        public string XmlSchemaCollectionOwningSchema { get; }
+        public bool Adjust(bool value);
+        public byte Adjust(byte value);
+        public byte[] Adjust(byte[] value);
+        public char Adjust(char value);
+        public char[] Adjust(char[] value);
+        public DateTime Adjust(DateTime value);
+        public DateTimeOffset Adjust(DateTimeOffset value);
+        public decimal Adjust(decimal value);
+        public double Adjust(double value);
+        public Guid Adjust(Guid value);
+        public short Adjust(short value);
+        public int Adjust(int value);
+        public long Adjust(long value);
+        public object Adjust(object value);
+        public float Adjust(float value);
+        public SqlBinary Adjust(SqlBinary value);
+        public SqlBoolean Adjust(SqlBoolean value);
+        public SqlByte Adjust(SqlByte value);
+        public SqlBytes Adjust(SqlBytes value);
+        public SqlChars Adjust(SqlChars value);
+        public SqlDateTime Adjust(SqlDateTime value);
+        public SqlDecimal Adjust(SqlDecimal value);
+        public SqlDouble Adjust(SqlDouble value);
+        public SqlGuid Adjust(SqlGuid value);
+        public SqlInt16 Adjust(SqlInt16 value);
+        public SqlInt32 Adjust(SqlInt32 value);
+        public SqlInt64 Adjust(SqlInt64 value);
+        public SqlMoney Adjust(SqlMoney value);
+        public SqlSingle Adjust(SqlSingle value);
+        public SqlString Adjust(SqlString value);
+        public SqlXml Adjust(SqlXml value);
+        public string Adjust(string value);
+        public TimeSpan Adjust(TimeSpan value);
+        public static SqlMetaData InferFromValue(object value, string name);
+    }
+    public sealed class SqlMethodAttribute : SqlFunctionAttribute {
+        public SqlMethodAttribute();
+        public bool InvokeIfReceiverIsNull { get; set; }
+        public bool IsMutator { get; set; }
+        public bool OnNullCall { get; set; }
+    }
+    public sealed class SqlUserDefinedAggregateAttribute : Attribute {
+        public const int MaxByteSizeValue = 8000;
+        public SqlUserDefinedAggregateAttribute(Format format);
+        public Format Format { get; }
+        public bool IsInvariantToDuplicates { get; set; }
+        public bool IsInvariantToNulls { get; set; }
+        public bool IsInvariantToOrder { get; set; }
+        public bool IsNullIfEmpty { get; set; }
+        public int MaxByteSize { get; set; }
+        public string Name { get; set; }
+    }
+    public sealed class SqlUserDefinedTypeAttribute : Attribute {
+        public SqlUserDefinedTypeAttribute(Format format);
+        public Format Format { get; }
+        public bool IsByteOrdered { get; set; }
+        public bool IsFixedLength { get; set; }
+        public int MaxByteSize { get; set; }
+        public string Name { get; set; }
+        public string ValidationMethodName { get; set; }
+    }
+    public enum SystemDataAccessKind {
+        None = 0,
+        Read = 1,
+    }
+}
 namespace Microsoft.VisualBasic {
+    public class VBCodeProvider : CodeDomProvider {
+        public VBCodeProvider();
+        public VBCodeProvider(IDictionary<string, string> providerOptions);
+        public override string FileExtension { get; }
+        public override LanguageOptions LanguageOptions { get; }
+        public override ICodeCompiler CreateCompiler();
+        public override ICodeGenerator CreateGenerator();
+        public override void GenerateCodeFromMember(CodeTypeMember member, TextWriter writer, CodeGeneratorOptions options);
+        public override TypeConverter GetConverter(Type type);
+    }
 }
+namespace Microsoft.Win32 {
+    public class PowerModeChangedEventArgs : EventArgs {
+        public PowerModeChangedEventArgs(PowerModes mode);
+        public PowerModes Mode { get; }
+    }
+    public delegate void PowerModeChangedEventHandler(object sender, PowerModeChangedEventArgs e); {
+        public PowerModeChangedEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, PowerModeChangedEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, PowerModeChangedEventArgs e);
+    }
+    public enum PowerModes {
+        Resume = 1,
+        StatusChange = 2,
+        Suspend = 3,
+    }
+    public static class Registry {
+        public static readonly RegistryKey ClassesRoot;
+        public static readonly RegistryKey CurrentConfig;
+        public static readonly RegistryKey CurrentUser;
+        public static readonly RegistryKey LocalMachine;
+        public static readonly RegistryKey PerformanceData;
+        public static readonly RegistryKey Users;
+        public static object GetValue(string keyName, string valueName, object defaultValue);
+        public static void SetValue(string keyName, string valueName, object value);
+        public static void SetValue(string keyName, string valueName, object value, RegistryValueKind valueKind);
+    }
+    public static class RegistryAclExtensions {
+        public static RegistrySecurity GetAccessControl(this RegistryKey key);
+        public static RegistrySecurity GetAccessControl(this RegistryKey key, AccessControlSections includeSections);
+        public static void SetAccessControl(this RegistryKey key, RegistrySecurity registrySecurity);
+    }
+    public enum RegistryHive {
+        ClassesRoot = -2147483648,
+        CurrentConfig = -2147483643,
+        CurrentUser = -2147483647,
+        LocalMachine = -2147483646,
+        PerformanceData = -2147483644,
+        Users = -2147483645,
+    }
+    public sealed class RegistryKey : MarshalByRefObject, IDisposable {
+        public SafeRegistryHandle Handle { get; }
+        public string Name { get; }
+        public int SubKeyCount { get; }
+        public int ValueCount { get; }
+        public RegistryView View { get; }
+        public void Close();
+        public RegistryKey CreateSubKey(string subkey);
+        public RegistryKey CreateSubKey(string subkey, bool writable);
+        public RegistryKey CreateSubKey(string subkey, bool writable, RegistryOptions options);
+        public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck);
+        public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck, RegistryOptions registryOptions);
+        public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck, RegistryOptions registryOptions, RegistrySecurity registrySecurity);
+        public RegistryKey CreateSubKey(string subkey, RegistryKeyPermissionCheck permissionCheck, RegistrySecurity registrySecurity);
+        public void DeleteSubKey(string subkey);
+        public void DeleteSubKey(string subkey, bool throwOnMissingSubKey);
+        public void DeleteSubKeyTree(string subkey);
+        public void DeleteSubKeyTree(string subkey, bool throwOnMissingSubKey);
+        public void DeleteValue(string name);
+        public void DeleteValue(string name, bool throwOnMissingValue);
+        public void Dispose();
+        public void Flush();
+        public static RegistryKey FromHandle(SafeRegistryHandle handle);
+        public static RegistryKey FromHandle(SafeRegistryHandle handle, RegistryView view);
+        public RegistrySecurity GetAccessControl();
+        public RegistrySecurity GetAccessControl(AccessControlSections includeSections);
+        public string[] GetSubKeyNames();
+        public object GetValue(string name);
+        public object GetValue(string name, object defaultValue);
+        public object GetValue(string name, object defaultValue, RegistryValueOptions options);
+        public RegistryValueKind GetValueKind(string name);
+        public string[] GetValueNames();
+        public static RegistryKey OpenBaseKey(RegistryHive hKey, RegistryView view);
+        public static RegistryKey OpenRemoteBaseKey(RegistryHive hKey, string machineName);
+        public static RegistryKey OpenRemoteBaseKey(RegistryHive hKey, string machineName, RegistryView view);
+        public RegistryKey OpenSubKey(string name);
+        public RegistryKey OpenSubKey(string name, bool writable);
+        public RegistryKey OpenSubKey(string name, RegistryKeyPermissionCheck permissionCheck);
+        public RegistryKey OpenSubKey(string name, RegistryKeyPermissionCheck permissionCheck, RegistryRights rights);
+        public RegistryKey OpenSubKey(string name, RegistryRights rights);
+        public void SetAccessControl(RegistrySecurity registrySecurity);
+        public void SetValue(string name, object value);
+        public void SetValue(string name, object value, RegistryValueKind valueKind);
+        public override string ToString();
+    }
+    public enum RegistryKeyPermissionCheck {
+        Default = 0,
+        ReadSubTree = 1,
+        ReadWriteSubTree = 2,
+    }
+    public enum RegistryOptions {
+        None = 0,
+        Volatile = 1,
+    }
+    public enum RegistryValueKind {
+        Binary = 3,
+        DWord = 4,
+        ExpandString = 2,
+        MultiString = 7,
+        None = -1,
+        QWord = 11,
+        String = 1,
+        Unknown = 0,
+    }
+    public enum RegistryValueOptions {
+        DoNotExpandEnvironmentNames = 1,
+        None = 0,
+    }
+    public enum RegistryView {
+        Default = 0,
+        Registry32 = 512,
+        Registry64 = 256,
+    }
+    public class SessionEndedEventArgs : EventArgs {
+        public SessionEndedEventArgs(SessionEndReasons reason);
+        public SessionEndReasons Reason { get; }
+    }
+    public delegate void SessionEndedEventHandler(object sender, SessionEndedEventArgs e); {
+        public SessionEndedEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, SessionEndedEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, SessionEndedEventArgs e);
+    }
+    public class SessionEndingEventArgs : EventArgs {
+        public SessionEndingEventArgs(SessionEndReasons reason);
+        public bool Cancel { get; set; }
+        public SessionEndReasons Reason { get; }
+    }
+    public delegate void SessionEndingEventHandler(object sender, SessionEndingEventArgs e); {
+        public SessionEndingEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, SessionEndingEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, SessionEndingEventArgs e);
+    }
+    public enum SessionEndReasons {
+        Logoff = 1,
+        SystemShutdown = 2,
+    }
+    public class SessionSwitchEventArgs : EventArgs {
+        public SessionSwitchEventArgs(SessionSwitchReason reason);
+        public SessionSwitchReason Reason { get; }
+    }
+    public delegate void SessionSwitchEventHandler(object sender, SessionSwitchEventArgs e); {
+        public SessionSwitchEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, SessionSwitchEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, SessionSwitchEventArgs e);
+    }
+    public enum SessionSwitchReason {
+        ConsoleConnect = 1,
+        ConsoleDisconnect = 2,
+        RemoteConnect = 3,
+        RemoteDisconnect = 4,
+        SessionLock = 7,
+        SessionLogoff = 6,
+        SessionLogon = 5,
+        SessionRemoteControl = 9,
+        SessionUnlock = 8,
+    }
+    public sealed class SystemEvents {
+        public static IntPtr CreateTimer(int interval);
+        public static void InvokeOnEventsThread(Delegate method);
+        public static void KillTimer(IntPtr timerId);
+        public static event EventHandler DisplaySettingsChanged;
+        public static event EventHandler DisplaySettingsChanging;
+        public static event EventHandler EventsThreadShutdown;
+        public static event EventHandler InstalledFontsChanged;
+        public static event EventHandler LowMemory;
+        public static event EventHandler PaletteChanged;
+        public static event PowerModeChangedEventHandler PowerModeChanged;
+        public static event SessionEndedEventHandler SessionEnded;
+        public static event SessionEndingEventHandler SessionEnding;
+        public static event SessionSwitchEventHandler SessionSwitch;
+        public static event EventHandler TimeChanged;
+        public static event TimerElapsedEventHandler TimerElapsed;
+        public static event UserPreferenceChangedEventHandler UserPreferenceChanged;
+        public static event UserPreferenceChangingEventHandler UserPreferenceChanging;
+    }
+    public class TimerElapsedEventArgs : EventArgs {
+        public TimerElapsedEventArgs(IntPtr timerId);
+        public IntPtr TimerId { get; }
+    }
+    public delegate void TimerElapsedEventHandler(object sender, TimerElapsedEventArgs e); {
+        public TimerElapsedEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, TimerElapsedEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, TimerElapsedEventArgs e);
+    }
+    public enum UserPreferenceCategory {
+        Accessibility = 1,
+        Color = 2,
+        Desktop = 3,
+        General = 4,
+        Icon = 5,
+        Keyboard = 6,
+        Locale = 13,
+        Menu = 7,
+        Mouse = 8,
+        Policy = 9,
+        Power = 10,
+        Screensaver = 11,
+        VisualStyle = 14,
+        Window = 12,
+    }
+    public class UserPreferenceChangedEventArgs : EventArgs {
+        public UserPreferenceChangedEventArgs(UserPreferenceCategory category);
+        public UserPreferenceCategory Category { get; }
+    }
+    public delegate void UserPreferenceChangedEventHandler(object sender, UserPreferenceChangedEventArgs e); {
+        public UserPreferenceChangedEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, UserPreferenceChangedEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, UserPreferenceChangedEventArgs e);
+    }
+    public class UserPreferenceChangingEventArgs : EventArgs {
+        public UserPreferenceChangingEventArgs(UserPreferenceCategory category);
+        public UserPreferenceCategory Category { get; }
+    }
+    public delegate void UserPreferenceChangingEventHandler(object sender, UserPreferenceChangingEventArgs e); {
+        public UserPreferenceChangingEventHandler(object @object, IntPtr method);
+        public virtual IAsyncResult BeginInvoke(object sender, UserPreferenceChangingEventArgs e, AsyncCallback callback, object @object);
+        public virtual void EndInvoke(IAsyncResult result);
+        public virtual void Invoke(object sender, UserPreferenceChangingEventArgs e);
+    }
+}
 namespace Microsoft.Win32.SafeHandles {
+    public sealed class SafeAccessTokenHandle : SafeHandle {
+        public SafeAccessTokenHandle(IntPtr handle);
+        public static SafeAccessTokenHandle InvalidHandle { get; }
+        public override bool IsInvalid { get; }
+    }
+    public abstract class SafeNCryptHandle : SafeHandleZeroOrMinusOneIsInvalid {
+        protected SafeNCryptHandle();
+        protected SafeNCryptHandle(IntPtr handle, SafeHandle parentHandle);
+        public override bool IsInvalid { get; }
+        protected override bool ReleaseHandle();
+        protected abstract bool ReleaseNativeHandle();
+    }
+    public sealed class SafeNCryptKeyHandle : SafeNCryptHandle {
+        public SafeNCryptKeyHandle();
+        public SafeNCryptKeyHandle(IntPtr handle, SafeHandle parentHandle);
+    }
+    public sealed class SafeNCryptProviderHandle : SafeNCryptHandle {
+        public SafeNCryptProviderHandle();
+    }
+    public sealed class SafeNCryptSecretHandle : SafeNCryptHandle {
+        public SafeNCryptSecretHandle();
+    }
+    public sealed class SafeRegistryHandle : SafeHandleZeroOrMinusOneIsInvalid {
+        public SafeRegistryHandle(IntPtr preexistingHandle, bool ownsHandle);
+        public override bool IsInvalid { get; }
+    }
     public sealed class SafeX509ChainHandle : SafeHandleZeroOrMinusOneIsInvalid {
-        public override bool IsInvalid { get; }
     }
 }
```
